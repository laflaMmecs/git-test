
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
import { o, html } from './libs/sinuous/index.js';
import { on, computed, cleanup, subscribe as subscribe$1, sample } from './libs/sinuous/observable.js';
import { map } from './libs/sinuous/map.js';
import ExcelJS from './libs/exceljs/index.js';
import './libs/docxtemplater/index.js';
import './libs/pizzip/index.js';
import './libs/file-saver/index.js';
import { DateTime } from './libs/luxon/index.js';
import { observe, unobserve } from './libs/disco/index.js';
import { html as html$1 } from './libs/sinuous/style.js';

function styleInject$b(css, ref) {
    if (ref === void 0) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === "undefined") {
        return;
    }

    var head = document.head || document.getElementsByTagName("head")[0];
    var style = document.createElement("style");
    style.type = "text/css";

    if (insertAt === "top") {
        if (head.firstChild) {
            head.insertBefore(style, head.firstChild);
        } else {
            head.appendChild(style);
        }
    } else {
        head.appendChild(style);
    }

    if (style.styleSheet) {
        style.styleSheet.cssText = css;
    } else {
        style.appendChild(document.createTextNode(css));
    }
}

var css_248z$b = "";
styleInject$b(css_248z$b);

class ItemData$2 {
    constructor(props, parent) {
        const self = this;

        this.parent = parent;
        this.value = o(props?.value);
        this.element = o(props?.element || html`<li>${this.value}</li>`);

        let element;

        const element_unsubscribe = on(this.element, (_) => {
            if (!self) {
                element_unsubscribe();
                return;
            }
            if (element) element.classList.remove("list-item");

            element = self.element();
            if (!element) return;

            element.classList.add("list-item");
        });
    }

    /// Get element inner value
    getValue() {
        return this.value();
    }

    /// Set element inner value
    setValue(value) {
        return this.value(value);
    }

    /// Get HTML element
    getElement() {
        return this.element();
    }

    /// Set HTML element
    setElement(element) {
        return this.element(element);
    }

    /// Get parent object
    getParent() {
        return this.parent;
    }

    /// Get index
    getIndex() {
        return this.parent?.getItems()?.indexOf(this);
    }
}

const List$1 = (props) => {
    let items = o(props?.items || []);

    const element = html`<ul class="list">
        ${map(items, (item) => html`${item.element}`)}
    </ul>`;

    /// Get items
    element.getItems = items;

    /// Set items
    element.setItems = items;

    /// Clear items
    element.clearItems = (_) => element.setItems([]);

    /// Get items
    element.getItem = (id) => element.getItems()[id];

    /// Remove item by index
    element.itemRemoveByKey = (id) => {
        let t = element.getItems();
        let datas = id === -1 ? [] : t.splice(id, 1);
        element.setItems(t);
        return datas;
    };

    /// Remove item
    element.itemRemoveByValue = (data) => {
        return element.itemRemoveByKey(data.getIndex());
    };

    /// Push item back into items
    element.itemPush = (data) => {
        element.setItems(element.getItems().concat(data));
        return data;
    };

    /// Insert item at index
    element.itemInsert = (data, id) => {
        let t = element.getItem();
        if (data instanceof Array) {
            t.splice(id, 0, ...data);
        } else {
            t.splice(id, 0, data);
        }
        element.setItems(t);
        return data;
    };

    /// Push item on top into items
    element.itemUnshift = (data) => {
        let t = element.getItems();
        if (data instanceof Array) {
            t.unshift(...data);
        } else {
            t.unshift(data);
        }
        element.setItems(t);
        return data;
    };

    /// Create item assigned to current list
    element.itemCreate = (props) => new ItemData$2(props, element);

    /// Create item assigned to current list and push it back into items
    element.itemCreateAndPush = (props) =>
        element.itemPush(element.itemCreate(props));

    /// Create item assigned to current list and insert it at index
    element.itemCreateAndInsert = (props, id) =>
        element.itemInsert(element.itemCreate(props), id);

    /// Create item assigned to current list and push it on top into items
    element.itemCreateAndUnshift = (props) =>
        element.itemUnshift(element.itemCreate(props));

    /// Create items assigned to current list and push it back into items
    element.itemsCreateAndPush = (parameters) => {
        let items = [];
        for (var i = 0; i < parameters.length; i++)
            items[i] = element.itemCreate(parameters[i]);
        return element.itemPush(items);
    };

    /// Create items assigned to current list and insert it at index
    element.itemsCreateAndInsert = (parameters, id) => {
        let items = [];
        for (var i = 0; i < parameters.length; i++)
            items[i] = element.itemCreate(parameters[i]);
        return element.itemInsert(items, id);
    };

    /// Create items assigned to current list and push it on top into items
    element.itemsCreateAndUnshift = (parameters) => {
        let items = [];
        for (var i = 0; i < parameters.length; i++)
            items[i] = element.itemCreate(parameters[i]);
        return element.itemUnshift(items);
    };

    return element;
};

function styleInject$a(css, ref) {
    if (ref === void 0) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === "undefined") {
        return;
    }

    var head = document.head || document.getElementsByTagName("head")[0];
    var style = document.createElement("style");
    style.type = "text/css";

    if (insertAt === "top") {
        if (head.firstChild) {
            head.insertBefore(style, head.firstChild);
        } else {
            head.appendChild(style);
        }
    } else {
        head.appendChild(style);
    }

    if (style.styleSheet) {
        style.styleSheet.cssText = css;
    } else {
        style.appendChild(document.createTextNode(css));
    }
}

var css_248z$a =
    ".nav-header, .nav-header-section {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between; }\n\n.nav-header-section, .nav-header-item {\n  height: 100%; }\n\n.nav-header-section {\n  list-style-type: none; }\n\n.nav-header-start {\n  align-self: flex-start; }\n\n.nav-header-center {\n  align-self: center; }\n\n.nav-header-end {\n  align-self: flex-end; }\n";
styleInject$a(css_248z$a);

class ItemData$1 extends ItemData$2 {
    constructor(props, parent) {
        super(props, parent);

        const self = this;

        let element;

        const element_unsubscribe = on(this.element, (_) => {
            if (!self) return element_unsubscribe();

            if (element) element.classList.remove("nav-header-item");

            element = self.element();
            if (!element) return;

            element.classList.add("nav-header-item");
        });
    }
}

const NavHeaderSection = (props) => {
    const element = List$1(props);

    element.classList.add("nav-header-section");

    element.itemCreate = (props) => new ItemData$1(props, element);

    return element;
};

const NavHeader = (props) => {
    var sectionStart = NavHeaderSection(props?.sectionStart);
    var sectionCenter = NavHeaderSection(props?.sectionCenter);
    var sectionEnd = NavHeaderSection(props?.sectionEnd);

    sectionStart.classList.add("nav-header-start");
    sectionCenter.classList.add("nav-header-center");
    sectionEnd.classList.add("nav-header-end");

    const element = html`
        <nav class="nav-header">
            ${sectionStart} ${sectionCenter} ${sectionEnd}
        </nav>
    `;

    element.sectionStart = sectionStart;
    element.sectionCenter = sectionCenter;
    element.sectionEnd = sectionEnd;

    return element;
};

function styleInject$9(css, ref) {
    if (ref === void 0) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === "undefined") {
        return;
    }

    var head = document.head || document.getElementsByTagName("head")[0];
    var style = document.createElement("style");
    style.type = "text/css";

    if (insertAt === "top") {
        if (head.firstChild) {
            head.insertBefore(style, head.firstChild);
        } else {
            head.appendChild(style);
        }
    } else {
        head.appendChild(style);
    }

    if (style.styleSheet) {
        style.styleSheet.cssText = css;
    } else {
        style.appendChild(document.createTextNode(css));
    }
}

var css_248z$9 = "";
styleInject$9(css_248z$9);

function WorkSpace(initial_view) {
    var current_view = o(initial_view);

    var workspace = html`<div class="workspace">${current_view}</div>`;

    workspace.view = current_view;

    workspace.getView = current_view;
    workspace.setView = current_view;

    return workspace;
}

function styleInject$8(css, ref) {
    if (ref === void 0) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === "undefined") {
        return;
    }

    var head = document.head || document.getElementsByTagName("head")[0];
    var style = document.createElement("style");
    style.type = "text/css";

    if (insertAt === "top") {
        if (head.firstChild) {
            head.insertBefore(style, head.firstChild);
        } else {
            head.appendChild(style);
        }
    } else {
        head.appendChild(style);
    }

    if (style.styleSheet) {
        style.styleSheet.cssText = css;
    } else {
        style.appendChild(document.createTextNode(css));
    }
}

var css_248z$8 = ".app-shell .workspace {\n  height: 100%; }\n";
styleInject$8(css_248z$8);

function AppShell(props) {
    const element = html`<div class="app-shell"></div>`;

    let header = !props?.useCustomNavbar ? NavHeader(props?.header) : () => {};

    if (!props?.useCustomNavbar) {
        element.sectionStart = header.sectionStart;
        element.sectionCenter = header.sectionCenter;
        element.sectionEnd = header.sectionEnd;
        element.append(header);
        element.header = header;
    }

    const body = WorkSpace(props?.body);
    element.append(body);
    element.body = body;

    element.getView = body.getView;
    element.setView = body.setView;

    return element;
}

function styleInject$7(css, ref) {
    if (ref === void 0) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === "undefined") {
        return;
    }

    var head = document.head || document.getElementsByTagName("head")[0];
    var style = document.createElement("style");
    style.type = "text/css";

    if (insertAt === "top") {
        if (head.firstChild) {
            head.insertBefore(style, head.firstChild);
        } else {
            head.appendChild(style);
        }
    } else {
        head.appendChild(style);
    }

    if (style.styleSheet) {
        style.styleSheet.cssText = css;
    } else {
        style.appendChild(document.createTextNode(css));
    }
}

var css_248z$7 =
    ".breadcrumbs, .breadcrumb {\n  display: flex;\n  flex-direction: row;\n  list-style-type: none; }\n\n.breadcrumb:first-child .breadcrumb-separator {\n  display: none; }\n";
styleInject$7(css_248z$7);

function styleInject$6(css, ref) {
    if (ref === void 0) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === "undefined") {
        return;
    }

    var head = document.head || document.getElementsByTagName("head")[0];
    var style = document.createElement("style");
    style.type = "text/css";

    if (insertAt === "top") {
        if (head.firstChild) {
            head.insertBefore(style, head.firstChild);
        } else {
            head.appendChild(style);
        }
    } else {
        head.appendChild(style);
    }

    if (style.styleSheet) {
        style.styleSheet.cssText = css;
    } else {
        style.appendChild(document.createTextNode(css));
    }
}

var css_248z$6 =
    ".collapse-category:not(.is-active) .collapse-category-body {\n  display: none; }\n";
styleInject$6(css_248z$6);

const CollapseCategory = (props) => {
    let props_header = o(props?.header || html`<div></div>`);
    let props_body = o(props?.body || html`<div></div>`);

    const element = html`<div class="collapse-category">
        ${props_header}${props_body}
    </div>`;

    /// Get header HTML element
    element.getHeader = props_header;

    /// Set header HTML element
    element.setHeader = props_header;

    /// Get body HTML element
    element.getBody = props_body;

    /// Set body HTML element
    element.setBody = props_body;

    /// Get expand state
    element.getExpanded = (_) => element.expanded;

    /// Set expand state
    element.setExpanded = (state) =>
        state ? element.expand() : element.collapse();

    /// Expand
    element.expand = (_) => {
        if (!element.dispatchEvent(new Event("beforeExpand"))) return;

        if (element.expanded) return;
        element.expanded = true;

        element.dispatchEvent(new Event("onExpand"));

        element.classList.add("is-active");
    };

    /// Collapse
    element.collapse = (_) => {
        if (!element.dispatchEvent(new Event("beforeCollapse"))) return;

        if (!element.expanded) return;
        element.expanded = false;

        element.dispatchEvent(new Event("onCollapse"));

        element.classList.remove("is-active");
    };

    /// Toggle expanded
    element.toggle = (_) => element.setExpanded(!element.getExpanded());

    let header;
    let header_OnClick;

    const header_unsubscribe = on(props_header, (_) => {
        if (!element) {
            header_unsubscribe();
            return;
        }
        if (header) {
            header.classList.remove("collapse-category-header");

            header.removeEventListener("click", header_OnClick);
        }
        header = props_header();
        if (!header) return;

        header.classList.add("collapse-category-header");

        header_OnClick = element.toggle;

        header.addEventListener("click", header_OnClick);
    });

    let body;

    const body_unsubscribe = on(props_body, (_) => {
        if (!element) {
            body_unsubscribe();
            return;
        }
        if (body) body.classList.remove("collapse-category-body");

        body = props_body();
        if (!body) return;

        body.classList.add("collapse-category-body");
    });

    element.setExpanded(props?.expanded || false);

    return element;
};

function styleInject$5(css, ref) {
    if (ref === void 0) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === "undefined") {
        return;
    }

    var head = document.head || document.getElementsByTagName("head")[0];
    var style = document.createElement("style");
    style.type = "text/css";

    if (insertAt === "top") {
        if (head.firstChild) {
            head.insertBefore(style, head.firstChild);
        } else {
            head.appendChild(style);
        }
    } else {
        head.appendChild(style);
    }

    if (style.styleSheet) {
        style.styleSheet.cssText = css;
    } else {
        style.appendChild(document.createTextNode(css));
    }
}

var css_248z$5 =
    ".dropdown {\n  position: relative; }\n  .dropdown:not(.is-active) .dropdown-body {\n    display: none; }\n  .dropdown.is-left .dropdown-body {\n    left: 0px; }\n  .dropdown.is-center .dropdown-body {\n    left: 50%;\n    transform: translateX(-50%); }\n  .dropdown.is-right .dropdown-body {\n    right: 0px; }\n\n.dropdown-body {\n  position: absolute;\n  margin: 0;\n  padding: 0;\n  z-index: 1; }\n";
styleInject$5(css_248z$5);

const DropDown = (props) => {
    const element = CollapseCategory(props);

    element.classList.add("dropdown");

    element.isHoverable = props?.isHoverable;

    element.addEventListener(
        "mouseover",
        (_) => {
            if (element.isHoverable) element.expand();
        },
        { capture: true },
    );
    element.addEventListener(
        "mouseout",
        (_) => {
            if (element.isHoverable) element.collapse();
        },
        { capture: true },
    );

    let header;

    const header_unsubscribe = on(element.getHeader, (_) => {
        if (!element) {
            header_unsubscribe();
            return;
        }
        if (header) header.classList.remove("dropdown-header");

        header = element.getHeader();
        if (!header) return;

        header.classList.add("dropdown-header");
    });

    let body;
    let body_event_onClick;

    const body_unsubscribe = on(element.getBody, (_) => {
        if (!element) {
            body_unsubscribe();
            return;
        }
        if (body) {
            body.classList.remove("dropdown-body");

            body.removeEventListener("click", body_event_onClick);
        }
        body = element.getBody();
        if (!body) return;

        body.classList.add("dropdown-body");

        body_event_onClick = (_) => element.collapse();

        body.addEventListener("click", body_event_onClick);
    });

    return element;
};

function styleInject$4(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$4 = ".dropdown-list .dropdown-body {\n  min-width: min-content; }\n\n.dropdown-list.is-active .dropdown-body.list {\n  display: flex;\n  flex-direction: column; }\n";
styleInject$4(css_248z$4);

const DropDownList = props => {
    if (!props) props = {};

    props.body = props.body || List$1(props);

    const element = DropDown(props);

    element.classList.add("dropdown-list");

    element.getItems = _ => element.getBody().getItems(props);
    element.setItems = items => element.getBody().setItems(items);
    element.clearItems = _ => element.getBody().clearItems();
    element.getItem = id => element.getBody().getItem(id);
    element.itemRemoveByKey = id => element.getBody().itemRemoveByKey(id);
    element.itemRemoveByValue = data => element.getBody().itemRemoveByValue(data);
    element.itemPush = data => element.getBody().itemPush(data);
    element.itemInsert = (id, data) => element.getBody().itemInsert(id, data);
    element.itemUnshift = data => element.getBody().itemUnshift(data);
    element.itemCreate = props => element.getBody().itemCreate(props);
    element.itemCreateAndPush = props => element.getBody().itemCreateAndPush(props);
    element.itemCreateAndInsert = (id, props) => element.getBody().itemCreateAndInsert(id, props);
    element.itemCreateAndUnshift = props => element.getBody().itemCreateAndUnshift(props);
    element.itemsCreateAndPush = parameters => element.getBody().itemsCreateAndPush(parameters);
    element.itemsCreateAndInsert = (id, parameters) => element.getBody().itemsCreateAndInsert(id, parameters);
    element.itemsCreateAndUnshift = parameters => element.getBody().itemsCreateAndUnshift(parameters);

    return element;
};

function styleInject$3(css, ref) {
    if (ref === void 0) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === "undefined") {
        return;
    }

    var head = document.head || document.getElementsByTagName("head")[0];
    var style = document.createElement("style");
    style.type = "text/css";

    if (insertAt === "top") {
        if (head.firstChild) {
            head.insertBefore(style, head.firstChild);
        } else {
            head.appendChild(style);
        }
    } else {
        head.appendChild(style);
    }

    if (style.styleSheet) {
        style.styleSheet.cssText = css;
    } else {
        style.appendChild(document.createTextNode(css));
    }
}

var css_248z$3 =
    ".menu {\n  position: absolute;\n  width: max-content;\n  height: max-content;\n  list-style-type: none;\n  z-index: 1; }\n  .menu:not(.is-active) {\n    display: none; }\n";
styleInject$3(css_248z$3);

class ItemData extends ItemData$2 {
    constructor(props, parent) {
        super(props, parent);

        const self = this;

        let isHoverable = props?.isHoverable;

        this.isHoverable = isHoverable === undefined ? true : isHoverable;
        this.menu = o(props?.menu);

        if (!props?.element)
            this.setElement(html`<li>${this.value}${this.menu}</li>`);

        let element;
        let element_event_onMouseOver;

        const element_unsubscribe = on(this.element, (_) => {
            if (!self) return element_unsubscribe();

            if (element) {
                element.classList.remove("menu-item");

                element.removeEventListener(
                    "mouseover",
                    element_event_onMouseOver,
                );
            }
            element = self.element();
            if (!element) return;

            element_event_onMouseOver = (_) => {
                if (self.isHoverable) self.parent?.itemSetActive(self, true);
            };

            element.classList.add("menu-item");

            element.addEventListener("mouseover", element_event_onMouseOver, {
                capture: true,
            });
        });
    }

    /// Get menu HTML element
    getMenu() {
        return this.menu();
    }

    /// Set menu HTML element
    setMenu(menu) {
        this.menu(menu);
    }

    /// Hide menu
    menuHide() {
        this.getMenu()?.hide();
    }

    /// Show menu
    menuShow() {
        let element = this.getElement();
        if (!element) return;

        let menu = this.getMenu();
        if (!menu) return;

        menu.show();

        let parent = this.getParent();
        if (!parent) return;

        let item = menu.getItem(0);
        if (!item) return;

        let item_rect = item.getElement()?.getBoundingClientRect();
        if (!item_rect) return;

        let element_rect = element.getBoundingClientRect();
        let parent_rect = parent.getBoundingClientRect();
        let menu_rect = menu.getBoundingClientRect();

        let x =
            parent_rect.x + parent_rect.width + menu_rect.width >
            window.screen.width
                ? -menu_rect.width
                : parent_rect.width;
        let y = element_rect.y - parent_rect.y - (item_rect.y - menu_rect.y);

        let offscreen_x = x + menu_rect.width - window.screen.width;
        if (offscreen_x > 0) x = x - offscreen_x;

        let offscreen_y = y + menu_rect.height - window.screen.height;
        if (offscreen_y > 0) y = y - offscreen_y;

        menu.setPos(x, y);
    }
}

const Menu = (props) => {
    const element = List$1(props);

    element.classList.add("menu");

    element.itemCreate = (props) => new ItemData(props, element);

    /// Get active item
    element.itemGetActive = (_) => element.itemActive;

    /// Set active item
    element.itemSetActive = (item, show_menu) => {
        let itemPrevious = element.itemActive;
        if (itemPrevious) {
            itemPrevious.getElement()?.classList.remove("is-active");
            itemPrevious.menuHide();
        }
        if (item) {
            item.getElement()?.classList.add("is-active");
            if (show_menu) item.menuShow();
        }
        element.itemActive = item;
    };

    /// Hide menu
    element.hide = (_) => {
        if (
            !element.dispatchEvent(
                new Event("beforeHide", { cancelable: true }),
            )
        )
            return;

        element.classList.remove("is-active");

        element.dispatchEvent(new Event("onHide"));
    };

    /// Show menu
    element.show = (_) => {
        if (
            !element.dispatchEvent(
                new Event("beforeShow", { cancelable: true }),
            )
        )
            return;

        element.itemSetActive();
        element.classList.add("is-active");

        element.dispatchEvent(new Event("onShow"));
    };

    /// Set menu position
    element.setPos = (x, y) => {
        let eventBefore = new Event("beforeSetPos", { cancelable: true });
        eventBefore.positionX = x;
        eventBefore.positionY = y;
        if (!element.dispatchEvent(eventBefore)) return;

        element.style.left = eventBefore.positionX + "px";
        element.style.top = eventBefore.positionY + "px";

        let eventOn = new Event("onSetPos");
        eventOn.positionX = eventBefore.positionX;
        eventOn.positionY = eventBefore.positionY;
        element.dispatchEvent(eventOn);
    };

    return element;
};

function styleInject$2(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z$2 = "";
styleInject$2(css_248z$2);

function styleInject$1(css, ref) {
    if (ref === void 0) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === "undefined") {
        return;
    }

    var head = document.head || document.getElementsByTagName("head")[0];
    var style = document.createElement("style");
    style.type = "text/css";

    if (insertAt === "top") {
        if (head.firstChild) {
            head.insertBefore(style, head.firstChild);
        } else {
            head.appendChild(style);
        }
    } else {
        head.appendChild(style);
    }

    if (style.styleSheet) {
        style.styleSheet.cssText = css;
    } else {
        style.appendChild(document.createTextNode(css));
    }
}

var css_248z$1 =
    ".modal-background {\n  display: flex;\n position: absolute;\n  left: 0;\n  top: 0;\n  width: 100vw;\n height: 100vh;\n  height: 100svh;\n  background-color: #0000004a; }\n\n.modal-window {\n  position: relative;\n  background-color: white;\n  margin: auto; }\n";
styleInject$1(css_248z$1);

// var css_248z =
//     ".table {\n  table-layout: fixed;\n  display: grid; }\n\n.table-header, .table-body, .table-row, .table-row-header {\n  display: contents; }\n\n.table-column {\n  position: relative;\n  color: black; }\n\n.table-cell, .table-column {\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  border: 1px solid; }\n\n.table-divider {\n  position: absolute;\n  top: 0px;\n  bottom: 0px;\n  right: 0px;\n  width: 3px;\n  background-color: black;\n  opacity: 0;\n  cursor: col-resize;\n  user-select: none; }\n  .table-divider.is-active {\n    opacity: 0.5; }\n";
// styleInject(css_248z);

class CellData {
    constructor(props, parent) {
        const self = this;

        this.parent = parent;
        this.value = o(props?.value);
        this.columnKey = props?.columnKey;

        let props_element = props?.element;
        if (props_element === undefined){
            props_element = html`<td data-column-key=${this.columnKey}>
                ${this.value}
            </td>`;
        } else {
            props_element.dataset.columnKey = this.columnKey;
        }

        this.element = o(props_element);

        let element;

        // subscribe on element update to handle it
        const element_unsubscribe = on(this.element, (_) => {
            if (!self) return element_unsubscribe();

            if (element) element.classList.remove("table-cell");

            element = self.element();
            if (!element) return;

            element.classList.add("table-cell");
        });
    }

    /// Get element inner value
    getValue() {
        return this.value();
    }

    /// Set element inner value
    setValue(value) {
        return this.value(value);
    }

    /// Get HTML element
    getElement() {
        return this.element();
    }

    /// Set HTML element
    setElement(element) {
        return this.element(element);
    }

    /// Get parent object
    getParent() {
        return this.parent;
    }

    /// Get index
    getIndex() {
        return this.getParent()?.getCells()?.indexOf(this);
    }
}

class RowData {
    constructor(props, parent) {
        const self = this;

        this.parent = parent;
        this.cells = o(props?.cells || []);

        let props_element = props?.element;
        if (props_element === undefined)
            props_element = html`<tr>
                ${map(this.cells, (cell) => html`${cell.element}`)}
            </tr>`;

        this.element = o(props_element);

        let element;

        // subscribe on element update to handle it
        const element_unsubscribe = on(this.element, (_) => {
            if (!self) return element_unsubscribe();

            if (element) element.classList.remove("table-row");

            element = self.element();
            if (!element) return;

            element.classList.add("table-row");
        });
    }

    /// Get HTML element
    getElement() {
        return this.element();
    }

    /// Set HTML element
    setElement(element) {
        return this.element(element);
    }

    /// Get parent object
    getParent() {
        return this.parent;
    }

    /// Get index
    getIndex() {
        return this.parent?.getRows()?.indexOf(this);
    }

    /// Get cells
    getCells() {
        return this.cells();
    }

    /// Set cells
    setCells(cells) {
        return this.cells(cells);
    }

    /// Clear cells
    clearCells() {
        this.setCells([]);
    }

    /// Get cell
    getCell(id) {
        return this.getCells()[id];
    }

    /// Remove cell by index
    cellRemoveByKey(id) {
        let t = this.getCells();
        let datas = id === -1 ? [] : t.splice(id, 1);
        this.setCells(t);
        return datas;
    }

    /// Remove cell
    cellRemoveByValue(data) {
        return this.cellRemoveByKey(data.getIndex());
    }

    /// Push cell back into cells
    cellPush(data) {
        this.setCells(this.getCells().concat(data));
        return data;
    }

    /// Insert cell at index
    cellInsert(id, data) {
        let t = this.getCells();
        if (data instanceof Array) {
            t.splice(id, 0, ...data);
        } else {
            t.splice(id, 0, data);
        }
        this.setCells(t);
        return data;
    }

    /// Push cell on top into cells
    cellUnshift(data) {
        let t = this.getCells();
        if (data instanceof Array) {
            t.unshift(...data);
        } else {
            t.unshift(data);
        }
        this.setCells(t);
        return data;
    }

    /// Create cell assigned to current row
    cellCreate(props) {
        return new CellData(props, this);
    }

    /// Create cell assigned to current row and push it back into cells
    cellCreateAndPush(props) {
        return this.cellPush(this.cellCreate(props));
    }

    /// Create cell assigned to current row and insert it at index
    cellCreateAndInsert(id, props) {
        return this.cellInsert(id, this.cellCreate(props));
    }

    /// Create cell assigned to current row and push it on top into cells
    cellCreateAndUnshift(id, props) {
        return this.cellUnshift(id, this.cellCreate(props));
    }

    /// Create cells assigned to current row and push it back into cells
    cellsCreateAndPush = (parameters) => {
        const cells = parameters.map((cellProps) => this.cellCreate(cellProps));
        return this.cellPush(cells);
    };

    /// Create cells assigned to current row and insert it at index
    cellsCreateAndInsert = (parameters, id) => {
        let cells = [];
        for (var i = 0; i < parameters.length; i++)
            cells[i] = this.cellCreate(parameters[i]);
        return this.cellInsert(id, cells);
    };

    /// Create cells assigned to current row and push it on top into cells
    cellsCreateAndUnshift = (parameters) => {
        let cells = [];
        for (var i = 0; i < parameters.length; i++)
            cells[i] = this.cellCreate(parameters[i]);
        return this.cellUnshift(cells);
    };
}

class ColumnData {
    constructor(props, parent) {
        const self = this;

        this.parent = parent;
        this.value = o(props?.value);
        this.width = o(props?.width || 0);
        this.doubleClickDuration = props?.doubleClickDuration || 500;

        let props_draggable = props?.draggable;
        if (props_draggable === null || props_draggable === undefined)
            props_draggable = true;

        let props_droppable = props?.droppable;
        if (props_droppable === null || props_droppable === undefined)
            props_droppable = true;

        this.droppable = props_droppable;

        let props_divider = props?.divider;
        if (props_divider === undefined) props_divider = html`<span></span>`;

        this.divider = o(props_divider);

        let props_element = props?.element;
        if (props_element === undefined) {
            props_element = html`<th>${this.value}${this.divider}</th>`;
            if (props_draggable) props_element.setAttribute("draggable", true);
        }
        this.element = o(props_element);

        const { onResized, onMoved } = props ?? {};

        let divider;
        let divider_event_OnPressed;
        let divider_event_OnMove;
        let divider_event_OnReleased;

        // subscribe on divider update to handle it
        const divider_unsubscribe = on(this.divider, (_) => {
            if (!self) return divider_unsubscribe();

            if (divider) {
                divider.classList.remove("table-divider");

                divider.removeEventListener(
                    "mousedown",
                    divider_event_OnPressed,
                );
                divider.removeEventListener(
                    "touchstart",
                    divider_event_OnPressed,
                );

                document.removeEventListener("mousemove", divider_event_OnMove);
                document.removeEventListener(
                    "mouseup",
                    divider_event_OnReleased,
                );

                document.removeEventListener("touchmove", divider_event_OnMove);
                document.removeEventListener(
                    "touchend",
                    divider_event_OnReleased,
                );
                document.removeEventListener(
                    "touchcancel",
                    divider_event_OnReleased,
                );
            }
            divider = self.divider();
            if (!divider) return;

            divider.classList.add("table-divider");

            let divider_event_OnReleased_lastClick;
            let divider_event_OnMove_lastScreenX;

            divider_event_OnPressed = (event) => {
                let lastClick = divider_event_OnReleased_lastClick;
                divider_event_OnReleased_lastClick = event.timeStamp;

                if (
                    lastClick !== undefined &&
                    event.timeStamp - lastClick < self.doubleClickDuration
                )
                    self.fit();

                let touch = event.touches ? event.touches[0] : null;
                if (touch) {
                    divider_event_OnMove_lastScreenX = touch.screenX;
                }
                divider.classList.add("is-active");

                document.addEventListener("mousemove", divider_event_OnMove);
                document.addEventListener("mouseup", divider_event_OnReleased, {
                    once: true,
                });

                document.addEventListener("touchmove", divider_event_OnMove);
                document.addEventListener(
                    "touchend",
                    divider_event_OnReleased,
                    { once: true },
                );
                document.addEventListener(
                    "touchcancel",
                    divider_event_OnReleased,
                    { once: true },
                );

                event.preventDefault();
            };

            divider_event_OnMove = (event) => {
                if (!divider) return;

                let delta = event.movementX;

                let touch = event.touches ? event.touches[0] : null;
                if (touch) {
                    delta = divider_event_OnMove_lastScreenX
                        ? touch.screenX - divider_event_OnMove_lastScreenX
                        : 0;
                    divider_event_OnMove_lastScreenX = touch.screenX;
                }
                if (typeof self.width() === "string") {
                    self.width(self.getElement().getBoundingClientRect().width);
                }
                let base_width = self.width();
                let width = base_width + delta;

                if (Math.round(Math.abs(width - base_width)) < 1) return;

                let minWidth = self.getMinWidth();
                if (width < minWidth) width = minWidth;

                self.width(width);

                event.preventDefault();
            };

            divider_event_OnReleased = (event) => {
                if (divider) divider.classList.remove("is-active");

                document.removeEventListener("mousemove", divider_event_OnMove);
                document.removeEventListener("touchmove", divider_event_OnMove);

                onResized?.({ key: self.index, width: self.width() });

                event.preventDefault();
            };

            divider.addEventListener("mousedown", divider_event_OnPressed);
            divider.addEventListener("touchstart", divider_event_OnPressed);
        });

        // subscribe on width update to recompute table style
        const width_unsubscribe = on(this.width, (_) => {
            if (!self) return width_unsubscribe();

            self.getParent()?.updateWidth();
        });

        let element;
        let element_draggable;
        let element_event_OnDragStart;
        let element_event_OnDragOver;
        let element_event_OnDragEnd;

        // subscribe on element update to handle it
        const element_unsubscribe = on(this.element, (_) => {
            if (!self) return element_unsubscribe();

            if (element) {
                element.classList.remove("table-column");

                element.setAttribute("draggable", element_draggable);

                element.removeEventListener(
                    "dragstart",
                    element_event_OnDragStart,
                );
                element.removeEventListener(
                    "dragover",
                    element_event_OnDragOver,
                );
                element.removeEventListener("drop", element_event_OnDragEnd);
            }
            element = self.element();
            if (!element) return;

            element.classList.add("table-column");

            element_draggable = element.getAttribute("draggable");

            element_event_OnDragStart = (event) =>
                event.dataTransfer.setData(
                    "text/plain",
                    self.getIndex().toString(),
                );
            element_event_OnDragOver = (event) => {
                if (self.droppable) event.preventDefault();
            };
            element_event_OnDragEnd = (event) => {
                event.preventDefault();

                if (!event.dataTransfer) return;

                let id_from = parseInt(
                    event.dataTransfer.getData("text/plain"),
                );
                if (id_from === null || id_from === undefined || id_from < 0)
                    return;

                let id_to = self.getIndex();
                if (id_to === null || id_to === undefined || id_to < 0) return;

                if (id_to === id_from) return;

                let parent = self.getParent();
                if (!parent) return;

                var t_columns = parent.getColumns();
                var column_element = t_columns.splice(id_from, 1)[0];
                if (column_element) t_columns.splice(id_to, 0, column_element);

                var t_rows = parent.getRows();
                for (let row_id = 0; row_id < t_rows.length; row_id++) {
                    var t_cells = t_rows[row_id].getCells();
                    var cell_element = t_cells.splice(id_from, 1)[0];
                    if (cell_element) t_cells.splice(id_to, 0, cell_element);
                    t_rows[row_id].setCells(t_cells);
                }
                parent.setColumns(t_columns);
                onMoved?.({ key: self.index, from: id_from, to: id_to });
            };

            if (props_draggable) {
                element.addEventListener(
                    "dragstart",
                    element_event_OnDragStart,
                    {
                        capture: true,
                    },
                );
                element.addEventListener("dragover", element_event_OnDragOver, {
                    capture: true,
                });
                element.addEventListener("drop", element_event_OnDragEnd, {
                    capture: true,
                });
            }
        });
    }

    /// Get element inner value
    getValue() {
        return this.value();
    }

    /// Set element inner value
    setValue(value) {
        return this.value(value);
    }

    /// Get HTML element
    getElement() {
        return this.element();
    }

    /// Set HTML element
    setElement(element) {
        return this.element(element);
    }

    /// Get divider HTML element
    getDivider() {
        return this.divider();
    }

    /// Set divider HTML element
    setDivider(divider) {
        return this.divider(divider);
    }

    /// Get parent object
    getParent() {
        return this.parent;
    }

    /// Get index
    getIndex() {
        return this.parent?.getColumns()?.indexOf(this);
    }

    /// Get draggable
    getDraggable() {
        return this.getElement()?.getAttribute("draggable");
    }

    /// Set draggable
    setDraggable(draggable) {
        return this.getElement()?.setAttribute("draggable", draggable);
    }

    /// Get droppable
    getDroppable() {
        return this.droppable;
    }

    /// Set droppable
    setDroppable(droppable) {
        this.droppable = droppable;
    }

    /// Get width
    getWidth() {
        return this.width();
    }

    /// Set width
    setWidth(width) {
        return this.width(width);
    }

    /// Get minimum width
    getMinWidth() {
        let element = this.getElement();
        if (!element) return;

        let style = getComputedStyle(element);

        let paddingLeft = parseFloat(style?.paddingLeft);
        if (!paddingLeft || paddingLeft === NaN) paddingLeft = 0;

        let paddingRight = parseFloat(style?.paddingRight);
        if (!paddingRight || paddingRight === NaN) paddingRight = 0;

        let dividerWidth = this.getDivider()?.offsetWidth;
        if (!dividerWidth || dividerWidth === NaN) dividerWidth = 0;

        return dividerWidth + paddingLeft + paddingRight;
    }

    /// Get maximum width
    getMaxWidth() {
        let index = this.getIndex();
        if (index === null || index === undefined || index < 0) return;

        let maxWidth = this.getMinWidth();
        this.setWidth("max-content");

        maxWidth = this.getElement().getBoundingClientRect().width + 1;
        this.setWidth(maxWidth);

        return maxWidth;
    }

    /// Fit width to contents
    fit() {
        let width = this.getMaxWidth();
        if (width === null || width === undefined) return;

        this.setWidth(width);

        return width;
    }

    /// Get double click duration (in milliseconds)
    getDoubleClickDuration() {
        return this.doubleClickDuration;
    }

    /// Set double click duration (in milliseconds)
    setDoubleClickDuration(duration) {
        this.doubleClickDuration = duration;
    }
}

const Table$2 = (props) => {
    let columns = o(props?.columns || []);
    let rows = o(props?.rows || []);

    const { onColumnResized, onColumnMoved } = props ?? {};
    const { class: className, style } = props ?? {};

    const element = html`
        <table class="table ${className ?? ""}" style=${style}>
            <thead class="table-header">
                <tr class="table-row-header">
                    ${map(columns, (column) => html`${column.element}`)}
                </tr>
            </thead>
            <tbody class="table-body">
                ${map(rows, (row) => html`${row.element}`)}
            </tbody>
        </table>
    `;

    element.updateWidth = (_) =>
        (element.style.gridTemplateColumns = columns()
            .map((column) => {
                let width = column.width();
                return typeof width === "string" ? width : width + "px";
            })
            .join(" "));

    // subscribe on columns update to recalculate width (move to drag'n'drop)
    const width_unsubscribe = on(columns, (_) => {
        if (!element) return width_unsubscribe();

        element?.updateWidth();
    });

    /// Get columns
    element.getColumns = columns;

    /// Set columns
    element.setColumns = columns;

    /// Get column
    element.getColumn = (id) => element.getColumns()[id];

    /// Get column by key
    element.getColumnByKey = (key) =>
        element.getColumns().find((col) => col.index === key);

    /// Clear columns
    element.clearColumns = (_) => element.setColumns([]);

    /// Remove column by index
    element.columnRemoveByKey = (id) => {
        let t = element.getColumns();
        let datas = id === -1 ? [] : t.splice(id, 1);
        element.setColumns(t);
        return datas;
    };

    /// Remove column
    element.columnRemoveByValue = (data) => {
        return element.columnRemoveByKey(data.getIndex());
    };

    /// Push column back into columns
    element.columnPush = (data) => {
        element.setColumns(element.getColumns().concat(data));
        return data;
    };

    /// Insert column at index
    element.columnInsert = (data, id) => {
        let t = element.getColumns();
        if (data instanceof Array) {
            t.splice(id, 0, ...data);
        } else {
            t.splice(id, 0, data);
        }
        element.setColumns(t);
        return data;
    };

    /// Push column on top into columns
    element.columnUnshift = (data) => {
        let t = element.getColumns();
        if (data instanceof Array) {
            t.unshift(...data);
        } else {
            t.unshift(data);
        }
        element.setColumns(t);
        return data;
    };

    /// Create column assigned to current table
    element.columnCreate = (props) => {
        const newProps = {
            ...props,
            onResized: onColumnResized,
            onMoved: onColumnMoved,
        };
        return new ColumnData(newProps, element);
    };

    /// Create column assigned to current table and push it back into columns
    element.columnCreateAndPush = (props) =>
        element.columnPush(element.columnCreate(props));

    /// Create column assigned to current table and insert it at index
    element.columnCreateAndInsert = (props, id) =>
        element.columnInsert(element.columnCreate(props), id);

    /// Create column assigned to current table and push it on top into columns
    element.columnCreateAndUnshift = (props) =>
        element.columnUnshift(element.columnCreate(props));

    /// Create columns assigned to current table and push it back into columns
    element.columnsCreateAndPush = (parameters) => {
        let columns = [];
        for (var i = 0; i < parameters.length; i++)
            columns[i] = element.columnCreate(parameters[i]);
        return element.columnPush(columns);
    };

    /// Create columns assigned to current table and insert it at index
    element.columnsCreateAndInsert = (parameters, id) => {
        let columns = [];
        for (var i = 0; i < parameters.length; i++)
            columns[i] = element.columnCreate(parameters[i]);
        return element.columnInsert(columns, id);
    };

    /// Create columns assigned to current table and push it on top into columns
    element.columnsCreateAndUnshift = (parameters) => {
        let columns = [];
        for (var i = 0; i < parameters.length; i++)
            columns[i] = element.columnCreate(parameters[i]);
        return element.columnUnshift(columns);
    };

    /// Get rows
    element.getRows = rows;

    /// Set rows
    element.setRows = rows;

    /// Get row
    element.getRow = (id) => element.getRows()[id];

    /// Clear rows
    element.clearRows = (_) => element.setRows([]);

    /// Remove row by index
    element.rowRemoveByKey = (id) => {
        let t = element.getRows();
        let datas = id === -1 ? [] : t.splice(id, 1);
        element.setRows(t);
        return datas;
    };

    /// Remove row
    element.rowRemoveByValue = (data) => {
        return element.rowRemoveByKey(data.getIndex());
    };

    /// Push row back into rows
    element.rowPush = (data) => {
        element.setRows(element.getRows().concat(data));
        return data;
    };

    /// Insert row at index
    element.rowInsert = (id, data) => {
        let t = element.getRows();
        if (data instanceof Array) {
            t.splice(id, 0, ...data);
        } else {
            t.splice(id, 0, data);
        }
        element.setRows(t);
        return data;
    };

    /// Push row on top into cells
    element.rowUnshift = (data) => {
        let t = element.getRows();
        if (data instanceof Array) {
            t.unshift(...data);
        } else {
            t.unshift(data);
        }
        element.setRows(t);
        return data;
    };

    /// Create row assigned to current table
    element.rowCreate = (props) => new RowData(props, element);

    /// Create row assigned to current table and push it back into rows
    element.rowCreateAndPush = (props) =>
        element.rowPush(element.rowCreate(props));

    /// Create row assigned to current table and insert it at index
    element.rowCreateAndInsert = (props, id) =>
        element.rowInsert(id, element.rowCreate(props));

    /// Create row assigned to current table and push it on top into rows
    element.rowCreateAndUnshift = (props) =>
        element.rowUnshift(element.rowCreate(props));

    /// Create rows assigned to current table and push it back into rows
    element.rowsCreateAndPush = (parameters) => {
        let rows = [];
        for (var i = 0; i < parameters.length; i++)
            rows[i] = element.rowCreate(parameters[i]);
        return element.rowPush(rows);
    };

    /// Create rows assigned to current table and insert it at index
    element.rowsCreateAndInsert = (parameters, id) => {
        let rows = [];
        for (var i = 0; i < parameters.length; i++)
            rows[i] = element.rowCreate(parameters[i]);
        return element.rowInsert(id, rows);
    };

    /// Create rows assigned to current table and push it on top into rows
    element.rowsCreateAndUnshift = (parameters) => {
        let rows = [];
        for (var i = 0; i < parameters.length; i++)
            rows[i] = element.rowCreate(parameters[i]);
        return element.rowUnshift(rows);
    };

    /// Get cells
    element.getCells = (_) => {
        let cells = [];

        let t_rows = element.getRows();
        for (let row = 0; row < t_rows.length; row++) {
            let t_cells = t_rows[row]?.getCells();
            if (t_cells)
                for (let column = 0; column < t_cells.length; column++)
                    cells[cells.length] = t_cells[column];
        }
        return cells;
    };

    /// Get cell
    element.getCell = (row, column) => element.getRows()[row]?.getCell(column);

    return element;
};

function styleInject(css, ref) {
    if (ref === void 0) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === "undefined") {
        return;
    }

    var head = document.head || document.getElementsByTagName("head")[0];
    var style = document.createElement("style");
    style.type = "text/css";

    if (insertAt === "top") {
        if (head.firstChild) {
            head.insertBefore(style, head.firstChild);
        } else {
            head.appendChild(style);
        }
    } else {
        head.appendChild(style);
    }

    if (style.styleSheet) {
        style.styleSheet.cssText = css;
    } else {
        style.appendChild(document.createTextNode(css));
    }
}

var css_248z =
    ".tree-node {\n  width: max-content; }\n  .tree-node > .collapse-category-body > .tree-node {\n    padding-left: 16px; }\n  .tree-node.is-root > .collapse-category-body > .tree-node {\n    padding-left: unset; }\n";
styleInject(css_248z);

class NodeData extends ItemData$2 {
    constructor(props, parent) {
        super(props, parent);

        const self = this;

        this.element = o(
            props?.element ||
                CollapseCategory({
                    header: props?.header || html`<div></div>`,
                    body:
                        props?.body ||
                        List$1({
                            items: props?.items,
                        }),
                }),
        );

        let element;

        const element_unsubscribe = on(this.element, (_) => {
            if (!self) {
                element_unsubscribe();
                return;
            }
            if (element) element.classList.remove("tree-node");

            element = self.element();
            if (!element) return;

            element.classList.add("tree-node");
        });
    }

    /// Get HTML element
    getElement() {
        return this.element();
    }

    /// Set HTML element
    setElement(element) {
        return this.element(element);
    }

    /// Get header HTML element
    getHeader() {
        return this.getElement()?.getHeader();
    }

    /// Set header HTML element
    setHeader(header) {
        return this.getElement()?.setHeader(header);
    }

    /// Get body HTML element
    getBody() {
        return this.getElement()?.getBody();
    }

    /// Set body HTML element
    setBody(body) {
        return this.getElement()?.setBody(body);
    }

    /// Get items
    getItems() {
        return this.getBody()?.getItems();
    }

    /// Set items
    setItems(items) {
        return this.getBody()?.setItems(items);
    }

    /// Clear items
    clearItems() {
        return this.getBody()?.clearItems();
    }

    /// Get item
    getItem(id) {
        return this.getBody()?.getItem(id);
    }

    /// Remove item by index
    itemRemoveByKey(key) {
        return this.getBody()?.itemRemoveByKey(key);
    }

    /// Remove item
    itemRemoveByValue(item) {
        return this.getBody()?.itemRemoveByValue(item);
    }

    /// Push item back into items
    itemPush(item) {
        return this.getBody()?.itemPush(item);
    }

    /// Insert item at index
    itemInsert(item, id) {
        return this.getBody()?.itemInsert(item, id);
    }

    /// Push item on top into items
    itemUnshift(item) {
        return this.getBody()?.itemUnshift(item);
    }

    /// Create item assigned to current node
    itemCreate(props) {
        return this.getBody()?.itemCreate(props);
    }

    /// Create item assigned to current node and push it back into items
    itemCreateAndPush(props) {
        return this.itemPush(this.itemCreate(props));
    }

    /// Create item assigned to current node and insert it at index
    itemCreateAndInsert(props) {
        return this.itemInsert(this.itemCreate(props));
    }

    /// Create item assigned to current node and push it on top into items
    itemCreateAndUnshift(props) {
        return this.itemUnshift(this.itemCreate(props));
    }

    /// Create items assigned to current node and push it back into items
    itemsCreateAndPush(parameters) {
        let items = [];
        for (var i = 0; i < parameters.length; i++)
            items[i] = this.itemCreate(parameters[i]);
        return this.itemPush(items);
    }

    /// Create items assigned to current node and insert it at index
    itemsCreateAndInsert(parameters) {
        let items = [];
        for (var i = 0; i < parameters.length; i++)
            items[i] = this.itemCreate(parameters[i]);
        return this.itemInsert(items);
    }

    /// Create items assigned to current node and push it on top into items
    itemsCreateAndUnshift(parameters) {
        let items = [];
        for (var i = 0; i < parameters.length; i++)
            items[i] = this.itemCreate(parameters[i]);
        return this.itemUnshift(items);
    }

    /// Create node assigned to current node
    nodeCreate(props) {
        return new NodeData(props, this);
    }

    /// Create node assigned to current node and push it back into items
    nodeCreateAndPush(props) {
        return this.itemPush(this.nodeCreate(props));
    }

    /// Create node assigned to current node and insert it at index
    nodeCreateAndInsert(props, id) {
        return this.itemInsert(this.nodeCreate(props), id);
    }

    /// Create node assigned to current node and push it on top into items
    nodeCreateAndUnshift(props) {
        return this.itemUnshift(this.nodeCreate(props));
    }

    /// Create nodes assigned to current node and push it back into items
    nodesCreateAndPush(parameters) {
        let items = [];
        for (var i = 0; i < parameters.length; i++)
            items[i] = this.nodeCreate(parameters[i]);
        return this.itemPush(items);
    }

    /// Create nodes assigned to current node and insert it at index
    nodesCreateAndInsert(parameters, id) {
        let items = [];
        for (var i = 0; i < parameters.length; i++)
            items[i] = this.nodeCreate(parameters[i]);
        return this.itemInsert(items, id);
    }

    /// Create nodes assigned to current node and push it on top into items
    nodesCreateAndUnshift(parameters) {
        let items = [];
        for (var i = 0; i < parameters.length; i++)
            items[i] = this.nodeCreate(parameters[i]);
        return this.itemUnshift(items);
    }

    /// Get node expand state
    getExpanded() {
        return this.getElement()?.getExpanded();
    }

    /// Set node expanded
    setExpanded(expanded) {
        return this.getElement()?.setExpanded(expanded);
    }

    /// Expand node
    expand() {
        return this.getElement()?.expand();
    }

    /// Collapse node
    collapse() {
        return this.getElement()?.collapse();
    }

    /// Toggle node expanded
    toggle() {
        return this.getElement()?.toggle();
    }
}

const Tree$1 = (props) => {
    let root = props?.root || new NodeData(props);

    root.getElement()?.classList.add("is-root");

    const element = html`${root.element}`;

    root.parent = element;

    /// Get root node
    element.getRoot = (_) => root;

    return element;
};

const get$1 = (key) => {
    return localStorage.getItem(key);
};
const set$1 = (key, value) => {
    localStorage.setItem(key, value);
};
const remove = (key) => {
    localStorage.removeItem(key);
};

const localStorageService = {
    get: get$1,
    set: set$1,
    remove,
};

/* eslint-disable no-unused-vars */
class SettingsManagerInterface {
    getByKey(key) {
        throw new Error("Need to implement");
    }

    save({ key, settings }) {
        throw new Error("Need to implement");
    }

    removeByKey(key) {
        throw new Error("Need to implement");
    }
}

const SETTINGS_KEY = "cardFilesSetting";
const VERSION = "0.0.2";
const VERSION_KEY = "__version";

const getCardFilesSettings = () => {
    const settingsString = localStorageService.get(SETTINGS_KEY);
    let settings = settingsString == null ? {} : JSON.parse(settingsString);
    if (settings[VERSION_KEY] != VERSION) {
        localStorageService.remove(SETTINGS_KEY);
        settings = { [VERSION_KEY]: VERSION };
        saveCardFilesSetting(settings);
    }
    return settings;
};
const saveCardFilesSetting = (settings) => {
    localStorageService.set(SETTINGS_KEY, JSON.stringify(settings));
};
const getCardFileSettingsKey = (key) => `${key}.${getUserId()}`;

class CardFileSettingsManager extends SettingsManagerInterface {
    constructor() {
        super();
        this.settings = getCardFilesSettings();
    }

    saveAll() {
        saveCardFilesSetting(this.settings);
    }

    getByKey(key) {
        const cardFileSettings = this.settings[getCardFileSettingsKey(key)];
        return cardFileSettings ?? {};
    }

    save({ key, settings }) {
        this.settings[getCardFileSettingsKey(key)] = settings;
        this.saveAll();
    }

    removeByKey(key) {
        if (delete this.settings?.[getCardFileSettingsKey(key)]) {
            this.saveAll();
        }
    }
}

class CardFileColumnsSettingsManager extends SettingsManagerInterface {
    constructor({ cardFileSettingsManager }) {
        super();
        this.cardFileSettingsManager = cardFileSettingsManager;
    }
    getByKey(key) {
        return this.cardFileSettingsManager.getByKey(key).columns ?? {};
    }
    save({ key, settings }) {
        const cfs = this.cardFileSettingsManager.getByKey(key);
        cfs.columns = settings;
        this.cardFileSettingsManager.save({ key, settings: cfs });
    }
    removeByKey(key) {
        const cfs = this.cardFileSettingsManager.getByKey(key);
        if (delete cfs?.columns) {
            this.cardFileSettingsManager.save({ key, settings: cfs });
        }
    }
}

const cardFileSettingsManager = new CardFileSettingsManager();
const cardFileColumnsSettingsManager =
    new CardFileColumnsSettingsManager({ cardFileSettingsManager });

const KEY = "ROLE_RIGHTS";

class Rights {
    constructor({
        CanAdd: canAdd,
        CanDelete: canDelete,
        CanEdit: canEdit,
        CanVisible: canVisible,
    } = {}) {
        this.canAdd = canAdd ?? true;
        this.canDelete = canDelete ?? true;
        this.canEdit = canEdit ?? true;
        this.canVisible = canVisible ?? true;
    }

    static default() {
        return new Rights({
            CanAdd: true,
            CanDelete: true,
            CanEdit: true,
            CanVisible: true,
        });
    }
}

class RolesRights {
    static #version = "0.0.1";

    constructor() {
        this.__version = RolesRights.#version;
        this.__rights = {};
    }

    get rights() {
        return this.__rights;
    }
    set rights(value) {
        this.__rights = value;
    }

    static get version() {
        return this.#version;
    }

    get(targetClass) {
        const roleId = getCurrentRole();
        if (!roleId) return;

        const roleRights = this.__rights[roleId];
        if (!roleRights) {
            const newRights = Rights.default();
            this.__rights[roleId][targetClass] = newRights;
            localStorageService.set(KEY, JSON.stringify(this));
            return newRights;
        }

        const cardFileRights = roleRights[targetClass];
        if (!cardFileRights) {
            const newRights = Rights.default();
            this.__rights[roleId][targetClass] = newRights;
            localStorageService.set(KEY, JSON.stringify(this));
            return newRights;
        }

        return cardFileRights;
    }

    set(targetClass, rights) {
        const roleId = getCurrentRole();
        if (!roleId) return;

        if (!(rights instanceof Rights)) {
            rights = new Rights(rights);
        }

        if (!this.__rights[roleId]) {
            this.__rights[roleId] = {};
        }

        this.__rights[roleId][targetClass] = rights;
        localStorageService.set(KEY, JSON.stringify(this));

        return rights;
    }

    static read() {
        const rights = JSON.parse(localStorageService.get(KEY));

        const rr = new RolesRights();
        Object.assign(rr, rights);

        return rr;
    }
}

const roleRightsService = RolesRights.read();

let messagesContainer = html`<div class="system-messages"></div>`;

const messageTypes = {
    success: "succes-message",
    error: "error-message",
    info: "info-message",
};

document.body.append(messagesContainer);

const Message$1 = (content, type) => {
    let closeButton = html`<button class="close-icon"></button>`;
    let message = html`<div class="message">
        <div
            class=${messageTypes[type] ?? "info-message"}
            style="margin-bottom: 4px"
        ></div>
        <div class="content">${content ? content : "Процедура пока не доступна"}</div>
        ${closeButton}
    </div>`;
    closeButton.addEventListener("click", () => {
        message.classList.add("disactive");
        message.style.marginBottom = `-${message.clientHeight}px`;
    });

    messagesContainer.append(message);

    message.addEventListener("transitionend", message.remove, false);

    setTimeout(() => {
        message.classList.add("disactive");
        message.style.marginBottom = `-${message.clientHeight}px`;
    }, 10000);
};

/**
 *
 *
 * @export
 * @class Controller
 */
class Controller {
    /**
     * Creates an instance of Controller.
     * @param {{
     *    template: (props) => HTMLElement,
     *    classNames: string[]
     * }}
     * @memberof Controller
     */
    constructor({ template, classNames = [], style }) {
        this.__template = template;
        this.__props = {
            classNames:
                classNames.length === 0 ? "" : ` ${classNames.join(" ")}`,
            style,
        };
    }

    configureTemplate(props = {}, create = true) {
        this.__props = {
            ...this.__props,
            ...props,
            classNames: `${this.__props.classNames} ${props.classNames?.join?.(
                " ",
            )}`,
        };
        if (create) {
            this.element = this.__template(this.__props);
        }
    }
    /**
     *
     *
     * @param {*} props
     * @return {HTMLElement}
     * @memberof Controller
     */
    render(props = undefined) {
        if (props) {
            this.configureTemplate(props);
        }

        if (this.element == null) {
            this.configureTemplate();
        }

        return this.element;
    }
}

const fieldBaseClass = "field-v2";

const FieldTemplate = ({
    disabled,
    title,
    fieldType,
    id,
    inputId,
    classNames,
    active,
    hoverTip,
    isEmpty,
    children,
    moveTitle = true,
    onMouseDown,
    style,
    fieldStyle,
    isCellField,
    isRequired,
    error,
    key,
    className,
    onClick,
}) => {
    const onMiddle = computed(() => {
        return isEmpty() && !active() && moveTitle ? " middle" : "";
    });
    const required = computed(() => {
        if (!isRequired) return "";
        return isEmpty() ? " warn" : "";
    });
    const errorClass = computed(() => {
        return error?.() != null ? " error" : "";
    });
    const displayError = computed(() => {
        const err = error?.();
        if (!err || isCellField) return;
        return html`<span class="${fieldBaseClass}-error-message"
            >${err}</span
        >`;
    });

    const field = html`<div
        class="${fieldBaseClass}${classNames}${() =>
            disabled() ? " disabled" : ""}${() =>
            active() ? " active" : ""}${isCellField
            ? ` ${fieldBaseClass}--cell`
            : ""}${required}${errorClass} ${className ?? ""}"
        title=${hoverTip}
        id=${id}
        onmousedown=${onMouseDown}
        onClick=${onClick}
        data-key=${key ?? ""}
        style=${isCellField ? style : fieldStyle}
    >
        ${children}
        ${!isCellField
            ? html`<label
                  class="${fieldBaseClass}-title ${fieldType}-field-title${onMiddle}"
                  htmlFor=${inputId}
              >
                  ${title}
              </label>`
            : null}
    </div>`;
    /**@type {HTMLDivElement} */
    const fieldcontainer = html`
        <div
            class="${fieldBaseClass}-container"
            style=${isCellField ? "display: contents;" : style}
            data-key=${key ?? ""}
        >
            ${field} ${displayError}
        </div>
    `;
    (isCellField ? field : fieldcontainer).setAttribute(
        `data-${fieldType}`,
        ""
    );

    return isCellField ? field : fieldcontainer;
};

class Field$1 extends Controller {
    // todo: clear ids on element remove
    static lastId = 0;
    constructor({
        key,
        value,
        onChange,
        disabled = false,
        title,
        fieldType,
        classNames = [],
        id,
        style,
        placeholder,
        inputStyle,
        fieldStyle,
        cellField = false,
        required = false,
        error,
        visible = true,
        className,
        class: cn,
        tooltip,
        readOnly = false,
    }) {
        super({ template: FieldTemplate, classNames: classNames, style });
        this.key = key;
        this.value = typeof value === "function" ? value : o(value);
        this.onChange = onChange;
        this.disabled = getObservable(disabled);
        this.title = title;
        this.fieldType = fieldType;
        this.isEmpty = computed(() => !this.value());
        this.active = o(false);
        if (!id) {
            id = `${this.key ?? Field$1.lastId++}_${this.fieldType}`;
        }
        this.id = id;
        this.placeholder = o(placeholder ?? "");
        this.inputId = id + "-input";
        this.inputStyle = inputStyle;
        this.isCellField = cellField;
        this.isRequired = required;
        this.error = error;
        this.visible = visible;
        this.className = className ?? cn;
        this.fieldStyle = fieldStyle;
        this.tooltip = tooltip;
        this.readOnly = getObservable(readOnly);
    }

    getPlaceholder() {
        return this.placeholder();
    }

    setPlaceholder(placeholder) {
        this.placeholder(placeholder);
    }

    getKey() {
        return this.key;
    }

    setActive(value) {
        this.active(value);
    }

    setValue(newValue) {
        if (newValue === this.value()) return;
        this.value(newValue);
        this.onChange?.({ key: this.key, value: newValue });
    }

    getValue() {
        return this.value();
    }

    setDisabled(disabled) {
        this.disabled(disabled);
    }

    setReadOnly(readOnly) {
        this.readOnly(readOnly);
    }

    toggleDisabled() {
        this.disabled(!this.disabled());
    }

    handleKeyUp() {}

    handleKeyDown() {}

    handleFocus() {
        if (this.disabled()) return;
        this.setActive(true);
    }

    handleBlur() {
        this.setActive(false);
    }

    handleMouseDown(ev) {
        if (ev.target === this.inputElement) return;
        ev.preventDefault();
        if (!this.active()) {
            this.inputElement?.focus?.();
        }
    }

    configureTemplate(props, ...children) {
        const { classNames = [], ...rest } = props ?? {};
        const {
            value,
            disabled,
            readOnly,
            title,
            fieldType,
            id,
            active,
            inputId,
            isEmpty,
            isCellField,
            isRequired,
            error,
            key,
            fieldStyle,
        } = this;

        super.configureTemplate({
            disabled,
            title,
            fieldType,
            readOnly,
            id,
            inputId,
            active,
            hoverTip: this.tooltip ?? value,
            isEmpty,
            children,
            classNames: [`${this.fieldType}-field`, ...(classNames || [])],
            isCellField,
            isRequired,
            error,
            key,
            className: this.className,
            fieldStyle,
            onMouseDown: (ev) => this.handleMouseDown(ev),
            ...rest,
        });
    }

    configureInputTemplate({ inputTemplate, classNames, ...rest }) {
        const handleChange = (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
            this.setValue(ev.target.value);
        };

        const {
            key,
            value,
            disabled,
            fieldType,
            inputId,
            active,
            isEmpty,
            placeholder,
            inputStyle,
            readOnly,
        } = this;

        /**@type {HTMLInputElement} */
        this.inputElement = inputTemplate({
            value,
            key,
            onChange: handleChange,
            disabled,
            fieldType,
            id: inputId,
            active,
            isEmpty,
            placeholder,
            readOnly,
            onKeyDown: (ev) => this.handleKeyDown(ev),
            onKeyUp: (ev) => this.handleKeyUp(ev),
            onFocus: (ev) => this.handleFocus(ev),
            onBlur: (ev) => this.handleBlur(ev),
            style: inputStyle,
            ...rest,
            classNames: [
                `${fieldBaseClass}-input`,
                `${fieldType}-field-input`,
                ...(classNames || []),
            ],
        });
    }

    render(...args) {
        if (this.visible) return super.render(...args);
        return null;
    }
}

const ShowPasswordBtn = ({ onClick, iconName, disabled }) => {
    const button = Button({
        icon: { name: iconName },
        onClick: onClick,
        classNames: ["--transparent", "field-button"],
        disableTabFocus: true,
    });
    return html`${() => (disabled() ? null : button)}`;
};

const TextInput = ({
    key,
    value,
    onChange,
    disabled,
    placeholder,
    type,
    id,
    classNames,
    onKeyUp,
    onKeyDown,
    onFocus,
    onBlur,
    // fieldType,
    active,
    style,
    readOnly,
}) => {
    return html`
        <!-- prettier-ignore-attribute -->
        <input
            value=${value}
            name=${key}
            onchange=${onChange}
            disabled=${disabled}
            placeholder=${placeholder}
            class="${classNames.join(" ")}${() => (active() ? " active" : "")}"
            id=${id}
            onkeydown=${onKeyDown}
            onkeyup=${onKeyUp}
            onblur=${onBlur}
            onfocus=${onFocus}
            type=${type}
            style=${style}
            readOnly=${readOnly}
        />
    `;
};

class TextField extends Field$1 {
    constructor({ type = "text", ...fieldProps }) {
        super({
            fieldType: type,
            ...fieldProps,
        });

        this.type = o(type);
        setup$b(this);
    }
    togglePasswordVisibility() {
        if (this.fieldType !== "password") return;
        this.type(this.type() === "password" ? "text" : "password");
    }
    isPasswordVisible() {
        if (this.fieldType !== "password") return;
        return this.type() === "text";
    }
    setValue(value) {
        if (this.fieldType !== "password") {
            super.setValue(value);
        } else {
            value = value?.trim?.();
            this.value(value);
            this.onChange?.({ key: this.key, value });
        }
    }
}

/**
 *
 * @param {TextField} textField
 */
function setup$b(textField) {
    textField.configureInputTemplate({
        inputTemplate: TextInput,
        type: textField.type,
    });
    if (textField.fieldType !== "password") {
        textField.configureTemplate(null, textField.inputElement);
        return;
    }

    /**@type {HTMLDivElement} */
    const showPassBtn = ShowPasswordBtn({
        onClick: () => {
            textField.togglePasswordVisibility();
        },
        iconName: () =>
            `visibility-${textField.isPasswordVisible() ? "off" : "on"}`,
        disabled: textField.disabled,
    });
    textField.configureTemplate(
        { hoverTip: textField.tooltip ?? "" },
        textField.inputElement,
        showPassBtn
    );
}

const defaultFormatters = {
    rub: Intl.NumberFormat("ru-RU", { currency: "RUB", style: "currency" }),
    usd: Intl.NumberFormat("ru-RU", { currency: "USD", style: "currency" }),
    eur: Intl.NumberFormat("ru-RU", { currency: "EUR", style: "currency" }),
    number: Intl.NumberFormat("ru-RU", {
        maximumFractionDigits: 2,
        minimumFractionDigits: 2,
    }),
    integer: Intl.NumberFormat("ru-RU", { maximumFractionDigits: 0 }),
};

const formatNumber = (number = 0, formatter) => {
    if (formatter instanceof Intl.NumberFormat) return formatter.format(number);
    return formatter?.(number);
};

const NumberInput = ({
    value,
    key,
    onChange,
    onInput,
    disabled,
    onKeyUp,
    onKeyDown,
    onFocus,
    onBlur,
    classNames,
    id,
    step,
    active,
    placeholder,
    style,
    readOnly,
}) => {
    const isTransparent = computed(() => {
        return !active() ? " transparent" : " active";
    });
    classNames.push("test");
    return html`
        <!-- prettier-ignore-attribute -->
        <input
            value=${value}
            type="number"
            name=${key}
            placeholder=${placeholder}
            oninput=${onInput}
            onchange=${onChange}
            disabled=${disabled}
            id=${id}
            onkeydown=${onKeyDown}
            onkeyup=${onKeyUp}
            onfocus=${onFocus}
            onblur=${onBlur}
            class="${classNames.join(" ")}${isTransparent}"
            step=${step}
            style=${style}
            readOnly=${readOnly}
        />
    `;
};

class NumberField extends Field$1 {
    /**
     * Creates an instance of NumberField.
     * @param {{format: "rub" | "usd" | "eur" | "number" | "integer"}} { format, formatter, ...fieldProps }
     * @memberof NumberField
     */
    constructor({ format, formatter, ...fieldProps }) {
        formatter =
            formatter != null
                ? formatter
                : defaultFormatters[format] ?? defaultFormatters.number;

        super({
            ...fieldProps,
            fieldType: "number",
        });

        this.step = format === "integer" ? 1 : 0.01;
        this.formattedValue = computed(() =>
            formatNumber(this.value(), formatter)
        );

        this.isEmpty = computed(() => this.value() == null);
        this.onInput = fieldProps.onInput;

        setup$a(this);
    }
}

/**
 *
 * @param {NumberField} numberField
 */
function setup$a(numberField) {
    const labelHidden = () => {
        return numberField.active() || numberField.isEmpty() ? " hidden" : "";
    };

    const formattedNumberElement = html`
        <label
            class="field-v2-label number-field-label${labelHidden}"
            htmlFor=${numberField.inputId}
        >
            ${numberField.formattedValue}
        </label>
    `;

    const handleChange = (ev) => {
        ev.preventDefault();
        const value = Number(ev.target.value);
        if (!isNaN(value) && isFinite(value)) numberField.setValue(value);
        else console.warn(`value is not a number: ${value}! not set!`);
    };

    function handleInput(ev) {
        ev.preventDefault();
        const value = Number(ev.target.value);
        if (isNaN(value) || !isFinite(value)) {
            console.warn(`value is not a number: ${value}! not set!`);
            return;
        }
        if (numberField.value() === value) {
            return;
        }
        numberField.onInput?.({ value, key: numberField.key });
    }

    numberField.configureInputTemplate({
        inputTemplate: NumberInput,
        step: numberField.step,
        onChange: handleChange,
        onInput: handleInput,
    });

    numberField.configureTemplate(
        null,
        numberField.inputElement,
        formattedNumberElement
    );
}

const CheckboxInput = ({
    key,
    id,
    value,
    onChange,
    disabled,
    onFocus,
    onBlur,
    classNames,
    style,
    readOnly,
}) => {
    function handleChange(ev) {
        if (readOnly()) {
            ev.target.checked = value();
            return;
        }
        onChange(ev);
    }
    const checkbox = html`
        <!-- prettier-ignore-attribute -->
        <input
            type="checkbox"
            name=${key}
            id=${id}
            checked=${value}
            onchange=${handleChange}
            disabled=${disabled}
            class=${classNames.join(" ")}
            onfocus=${onFocus}
            onblur=${onBlur}
            style=${style}
            readOnly=${readOnly}
        />
    `;
    return checkbox;
};

class CheckboxField extends Field$1 {
    constructor({ ...rest }) {
        super({ ...rest, fieldType: "checkbox" });
        setupCheckbox(this);
    }
}

/**
 *
 * @param {CheckboxField} cbf
 */
function setupCheckbox(cbf) {
    const handleChange = (ev) => {
        ev.preventDefault();
        cbf.setValue(ev.target.checked);
    };
    cbf.configureInputTemplate({
        inputTemplate: CheckboxInput,
        onChange: handleChange,
    });
    cbf.configureTemplate(
        { hoverTip: cbf.tooltip ?? cbf.title, moveTitle: false },
        cbf.inputElement
    );
    cbf.element.addEventListener("mousedown", (ev) => ev.preventDefault());
}

/**
 *
 * @param {{name: "mark" | "close", size?: string, color?: string?}} param0
 * @returns
 */
const Icon$1 = ({ name, size, color }) =>
    html`<i
        class="icon icon-${name}"
        style=${{ "--icon-size": size, "--color": color }}
    ></i>`;

const Button = (
    {
        text,
        classNames = [],
        className,
        onClick,
        icon,
        disableTabFocus = false,
        type = "button",
        class: cName,
        ...rest
    },
    ...children
) => {
    /**@type {HTMLButtonElement} */
    const button = html`<button
        ...${rest}
        class="button${classNames.length > 0
            ? ` ${classNames.join(" ")}`
            : ""} ${className ?? ""} ${cName ?? ""}"
        type=${type}
    >
        ${text} ${icon && Icon$1(icon)}${children}
    </button>`;
    button.addEventListener("click", onClick);
    if (disableTabFocus) button.setAttribute("tabindex", "-1");
    return button;
};

const Icon = ({ name, ...rest }) => {
    return html`<i ...${rest} class="icon2 icon-${name}"></i>`;
};

// import { throttle } from "Core/utils/index.js";

const modals = o([]);
const modalsList = html`${map(modals, (m) => m.__element)}`;
document.body.append(modalsList);

const ModalBackGround = ({ onClick } = {}, ...children) => {
    /**@type {HTMLDivElement}*/
    const element = html`<div class="new-modal__bg" onclick=${onClick}>
        ${children}
    </div>`;
    return element;
};

const ModalWindow = (props, ...children) => {
    const { onCloseBtnClick, showCloseButton = true } = props ?? {};
    /**@type {HTMLDivElement}*/
    const element = html`<div
        class="new-modal-window"
        onmousedown=${handleMouseDown}
    >
        <${Button}
            class="transparent grey borderless close-btn"
            style=${showCloseButton ? "" : "display: none"}
            onclick=${onCloseBtnClick}
        >
            <${Icon} name="xmark" />
        <//>
        <div class="new-modal-window__content">${children}</div>
    </div>`;

    const startPosition = { x: 0, y: 0 };
    const lastShift = { x: 0, y: 0 };
    const onMouseMove = handleMouseMove; /* throttle(handleMouseMove, 15) */

    function handleMouseDown(ev) {
        if (ev.target !== element) {
            return;
        }

        ev.preventDefault();
        const { pageX: x, pageY: y } = ev;
        startPosition.x = x - lastShift.x;
        startPosition.y = y - lastShift.y;

        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", handleMouseUp);
    }
    function handleMouseUp() {
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", handleMouseUp);
    }

    function handleMouseMove(ev) {
        ev.preventDefault();

        const rect = element.getBoundingClientRect();
        let cursorXShift = ev.pageX - startPosition.x;
        let cursorYShift = ev.pageY - startPosition.y;

        const windowLeftShift = rect.left + cursorXShift - lastShift.x;
        const windowRightShift = rect.right + cursorXShift - lastShift.x;
        const windowTopShift = rect.top + cursorYShift - lastShift.y;
        const windowBottomShift = rect.bottom + cursorYShift - lastShift.y;

        if (windowLeftShift < 0) {
            cursorXShift = (rect.width - document.body.clientWidth) / 2;
        } else if (windowRightShift > document.body.clientWidth) {
            cursorXShift = (document.body.clientWidth - rect.width) / 2;
        }

        if (windowTopShift < 0) {
            cursorYShift = (rect.height - document.body.clientHeight) / 2;
        } else if (windowBottomShift > document.body.clientHeight) {
            cursorYShift = (document.body.clientHeight - rect.height) / 2;
        }

        if (cursorXShift === lastShift.x && cursorYShift === lastShift.y) {
            return;
        }

        lastShift.x = cursorXShift;
        lastShift.y = cursorYShift;
        const transform = `translate(${lastShift.x}px, ${lastShift.y}px)`;

        element.style.transform = transform;
    }

    return element;
};

const hideModal = (props) => {
    if (modals().length === 0) return;

    const arr = [...modals()];
    const { id } = props;
    let modal;
    if (id) {
        const index = arr.findIndex((m) => m.id == id);
        modal = arr.splice(index, 1)[0];
    } else {
        modal = arr.pop();
    }
    modals(arr);

    modal.shown = false;
    modal.onHide?.(props);
};

/**
 *
 * @param {KeyboardEvent} ev
 * @returns
 */
const handleEscKeyUp = (ev) => {
    if (ev.keyCode !== 27 || ev.key == "ESC") return;
    ev.stopPropagation();
    ev.preventDefault();
    hideModal({ escape: true });
};

document.addEventListener("keyup", handleEscKeyUp);

const Modal = ({
    content,
    onShow,
    onHide,
    showCloseButton,
    class: className,
    closeOnBackground = false,
    ...rest
} = {}) => {
    const c = o(content);
    const classNames = mergeClasses("new-modal", className);

    const modal = {
        shown: false,
        onShow,
        onHide,
        id: uuidv4(),
        closeOnBackground,
    };

    function show() {
        if (modal.shown) return;
        modal.shown = true;

        /**
         * @type {HTMLDivElement}
         */
        const element = html`<div class=${classNames} data-id=${modal.id}>
            <${ModalBackGround}
                onClick=${() => {
                    if (!modal.shown) return;
                    if (!modal.closeOnBackground) return;

                    hideModal({ background: true, id: modal.id });
                }}
            />
            <${ModalWindow}
                ...${rest}
                onCloseBtnClick=${hide}
                showCloseButton=${showCloseButton}
                >${c}<//
            >
        </div>`;

        const arr = modals();

        element.dataset.modalId = arr.length;
        modal.__element = element;

        arr.push(modal);
        modals(arr);
        modal.onShow?.();
    }

    function hide() {
        if (!modal.shown) return;
        hideModal({ id: modal.id });
    }

    modal.show = show;
    modal.hide = hide;
    modal.setContent = (content) => c(content);
    modal.showCloseButton = (show) => (showCloseButton = show);

    return modal;
};

const InputTemplate = ({
    key,
    value,
    dataId,
    onInput,
    disabled,
    readOnly,
    id,
    onKeyDown,
    onChange,
    onFocus,
    onBlur,
    classNames,
    active,
    placeholder,
    style,
    canSearch,
    multiselect,
    onClick,
}) => {
    const isDisabled = computed(() => disabled() || !canSearch || "");
    const isReadOnly = computed(
        () => readOnly() ?? (multiselect || disabled())
    );
    /**@type {HTMLInputElement} */
    const input = html`
        <!-- prettier-ignore-attribute -->
        <input
            type="text"
            name=${key}
            value=${value}
            data-id=${dataId}
            placeholder=${placeholder}
            disabled=${isDisabled}
            readOnly=${isReadOnly}
            id=${id}
            class="${classNames.join(" ")}${() => (active() ? " active" : "")}"
            style=${style}
            autocomplete="off"
        />
    `;

    input.addEventListener("keyup", handleKeyUp);
    input.addEventListener("keydown", onKeyDown);
    input.addEventListener("focus", onFocus);
    input.addEventListener("blur", onBlur);
    input.addEventListener("input", onInput);
    input.addEventListener("click", onClick);

    function handleKeyUp(ev) {
        if (ev.keyCode !== 13) return;
        onChange({ search: ev.target.value });
    }

    return input;
};

class CardFileField extends Field$1 {
    constructor({
        value: data,
        path = "Name",
        idPath = "docid",
        cardFile,
        displayValue,
        filter,
        constFilter,
        searchKeys = [],
        isHierarchycal = true,
        canSearch = true,
        beforeSelect,
        initTree,
        multiselect = false,
        cardFileProps,
        ...rest
    }) {
        path =
            path === "Name" && displayValue?.length > 0 ? displayValue : path;
        super({
            ...rest,
            fieldType: "reference",
        });
        this.data = getObservable(data);
        this.value = o("");
        this.path = path;
        this.idPath = idPath;
        this.cardFile = cardFile;
        this.searchKeys = searchKeys;
        this.canSearch = canSearch;
        this.beforeSelect = beforeSelect;
        this.multiselect = multiselect;
        this.dataId = !multiselect
            ? computed(() => get(this.data, this.idPath) ?? "")
            : o();

        this.cardFileProps = cardFileProps ?? {};
        if (filter) {
            this.cardFileProps.filter = filter;
        }
        if (constFilter) {
            this.cardFileProps.constFilter = constFilter;
        }
        if (
            isHierarchycal != null &&
            this.cardFileProps.isHierarchycal == null
        ) {
            this.cardFileProps.isHierarchycal = isHierarchycal;
        }
        if (initTree != null) {
            this.cardFileProps.initTree = initTree;
        }

        this.isEmpty = computed(() => {
            const currentData = this.data();
            if (multiselect) {
                return !(currentData?.length > 0);
            }
            if (currentData == null) return true;
            return this.dataId() === "";
        });
        this.cardFileOpened = false;
        this.updateTargetClass();

        cleanup(
            subscribe$1(() =>
                this.value(
                    getDisplayValue({ data: this.data(), path: this.path })
                )
            )
        );

        setup$9(this);
    }

    setData(data) {
        if (Array.isArray(data)) {
            this.data(data);
            this.onChange?.({ key: this.key, value: data });
            return;
        }
        const newId = get(data, this.idPath) ?? "";
        if (this.isEmpty() && newId === "") return;
        if (data) {
            data.targetClass = this.targetClass;
        }

        this.data(data);
        this.onChange?.({ key: this.key, value: data });
    }

    getData() {
        return this.data();
    }

    getValue() {
        if (!this.multiselect) {
            const id = this.dataId();
            return id
                ? { [this.idPath]: id, targetClass: this.targetClass }
                : {};
        }

        return (
            this.data()?.map((record) => ({
                [this.idPath]: record?.[this.idPath],
                targetClass: this.targetClass,
            })) ?? []
        );
    }

    setValue(data) {
        this.setData(data);
    }

    setCardFile(cardFile) {
        if (this.cardFile && this.getData() != null) {
            this.setData(this.multiselect ? [] : {});
        }
        this.cardFile = cardFile;
        this.updateTargetClass();
    }

    setFilter(filter) {
        this.cardFileProps.filter = filter;
    }

    setConstFilter(constFilter) {
        this.cardFileProps.constFilter = constFilter;
    }

    clear() {
        this.setData(this.multiselect ? [] : {});
    }

    handleBlur() {
        if (this.cardFileOpened) return;

        if (this.isEmpty()) this.value("");
        super.handleBlur();
    }

    updateTargetClass() {
        this.targetClass =
            this.cardFile?.targetClass ??
            this.cardFile?.settings?.targetClass ??
            (typeof this.cardFile === "function"
                ? this.cardFile().targetClass
                : "");
    }
}

/**
 *
 * @param {CardFileField} cff
 */
function setup$9(cff) {
    const loading = o(false);

    const button = Button({
        classNames: ["--transparent", "field-button"],
        onClick: () =>
            cff.multiselect ? openTable() : openCardFile({ prefetch: false }),
        disabled: () => cff.disabled() || cff.readOnly() || loading(),
        disableTabFocus: true,
        text: () =>
            loading()
                ? html`<span class="spinner" />`
                : Icon({ name: "ellipsis" }),
    });

    const clearButton = Button({
        classNames: ["--transparent", "field-button"],
        onClick: () => cff.clear(),
        disableTabFocus: true,
        text: () => Icon({ name: "xmark" }),
    });

    async function openCardFile({ search = "", prefetch = true }) {
        if (cff.cardFileOpened) return;
        if (!cff.active()) return;
        if (!cff.cardFile) return;

        // создаем фильтр на основе ключей по которым нужно искать
        const cardFileSearch =
            prefetch && search.length > 0
                ? [
                      `Match(${cff.path},'*${search}*')`,
                      ...cff.searchKeys.map(
                          (key) => `Match(${key},'*${search}*')`
                      ),
                  ].join(" or ")
                : "";

        const isHierarchycal = !(search?.length > 0)
            ? cff.cardFileProps.isHierarchycal
            : false;

        const dynamicFilter =
            typeof cff.cardFileProps.filter === "function"
                ? cff.cardFileProps.filter()
                : cff.cardFileProps.filter;

        const filter = [dynamicFilter, cardFileSearch]
            .filter((f) => !!f)
            .join(" and ");

        // строим картотеку
        const content = cff.cardFile({
            ...cff.cardFileProps,
            constFilter:
                typeof cff.cardFileProps.constFilter === "function"
                    ? cff.cardFileProps.constFilter()
                    : cff.cardFileProps.constFilter,
            inModal: async (...args) => {
                if (cff.beforeSelect) {
                    let result = cff.beforeSelect(...args);
                    if (result instanceof Promise) {
                        result = await result;
                    }
                    if (!result) {
                        return;
                    }
                }
                cff.setData(...args);
                modal?.hide();
            },
            filter: filter,
            isHierarchycal,
        });
        if (cff.cardFileProps.order) {
            content.setConstOrder(cff.cardFileProps.order);
        }

        if (prefetch) {
            // делаем запрос как минимум 2 записей
            loading(true);
            const result = await content.fetchData?.({
                targetClass: content.targetClass,
                filter: [cff.filter, cardFileSearch]
                    .filter((f) => !!f)
                    .join(" and "),
                isHierarchycal,
                start: 0,
                length: 2,
            });

            // если в результате вернулась одна запись, то ставим ее
            if (
                !(result instanceof Error) &&
                Object.keys(result).length === 1
            ) {
                loading(false);
                return cff.setData(result[0]);
            }
        }

        const modal = Modal({
            content,
            onShow: () => {
                cff.cardFileOpened = true;
                cff.inputElement.blur();
            },
            onHide: () => {
                loading(false);
                cff.cardFileOpened = false;
                if (cff.isEmpty()) {
                    cff.value("");
                    cff.setActive(false);
                } else {
                    cff.inputElement.focus();
                }
            },
        });
        modal.show();
    }

    async function openTable() {
        const tableData = o([]);
        function updateValueInArray({ key: index, value }) {
            if (
                typeof index !== "number" ||
                index < 0 ||
                !Number.isInteger(index)
            ) {
                throw new Error("Error: invalid index");
            }
            let recordsArray = [...tableData()];
            if (Array.isArray(value)) {
                recordsArray.splice(index, 1, ...value);
            } else {
                recordsArray[index] = value;
            }

            const hasEmptyCell =
                recordsArray.findIndex((r) => !r?.docid && !r?.[cff.idPath]) !==
                -1;

            if (!hasEmptyCell) {
                recordsArray.push({});
            }

            recordsArray = recordsArray.filter(
                (record, i, arr) =>
                    arr.findIndex(
                        (r) => r[cff.idPath] === record[cff.idPath]
                    ) === i
            );

            tableData(recordsArray);
            cff.setValue(tableData().filter((r) => !!r?.[cff.idPath]));
        }
        function addNewRow() {
            const recordsArray = [...tableData(), {}];
            tableData(recordsArray);
        }
        const Table = ({
            title,
            key,
            data,
            onCellChange: onChange,
            ...rest
        }) => {
            return html`<table
                class="table"
                style="grid-template-columns: minmax(150px, 300px)"
            >
                <thead class="table-header">
                    <th class="table-column">${title ?? key}</th>
                </thead>
                <tbody class="table-body">
                    ${map(data, (data, _, arr) => {
                        const index = arr.indexOf(data);
                        const field = new CardFileField({
                            ...rest,
                            multiselect: false,
                            value: data,
                            onChange,
                            key: index,
                            id: cff.key + index,
                            cellField: true,
                            cardFile: (props) =>
                                rest.cardFile({ ...props, multiselect: true }),
                        });
                        return html`<tr class="table-row" data-index=${index}>
                            <td class="table-cell">${field.render()}</td>
                        </tr>`;
                    })}
                </tbody>
            </table>`;
        };

        const TableContainer = ({ onPlusClick, data, ...rest }) => {
            return html`<div
                style="display: flex; flex-grow: 1; overflow: hidden"
            >
                <div class="scrollable">
                    <${Table} ...${rest} data=${data} />
                </div>
                <${Button} onClick=${onPlusClick} style="display: none;">
                    <${Icon} name="plus" />
                <//>
            </div>`;
        };
        const modal = Modal({
            content: html`<${TableContainer}
                ...${cff}
                onPlusClick=${addNewRow}
                onCellChange=${updateValueInArray}
                data=${tableData}
            />`,
            onShow: () => {
                tableData([...(cff.getData() ?? []), {}]);
            },
        });
        modal.show();
    }

    cff.configureInputTemplate({
        inputTemplate: InputTemplate,
        onInput: (ev) => {
            const value = ev.target.value;
            if (!cff.isEmpty()) {
                cff.clear();
                cff.value(ev.inputType.includes("delete") ? "" : value);
            } else {
                cff.value(value);
            }
        },
        dataId: cff.dataId,
        onChange: openCardFile,
        canSearch: cff.canSearch,
        multiselect: cff.multiselect,
        onClick: cff.multiselect ? openTable : null,
    });

    /**
     *
     * @param {MouseEvent} ev
     */
    const handleClick = (ev) => {
        if (!isLeftMouseBtnEvent(ev)) return;
        if (!isOnlyCtrlPressed(ev)) return;
        if (cff.isEmpty()) return;
        if (!cff.cardFile?.settings?.urlPath) return;

        const path = `/#cardfile/${cff.cardFile.settings.urlPath}?id=${
            cff.getValue().docid
        }`;
        window.open(path, "_blank").focus();
    };

    cff.configureTemplate(
        { onClick: handleClick },
        cff.inputElement,
        button,
        cff.multiselect
            ? () => (!cff.isEmpty() && !cff.disabled() ? clearButton : null)
            : null
    );
}

function getDisplayValue({ data, path }) {
    const getText = (data) =>
        get(data, path) ?? get(data, "Name") ?? get(data, "docid") ?? "";
    return Array.isArray(data)
        ? data
              .map(getText)
              .filter((text) => !!text)
              .join(", ")
        : getText(data);
}

const DateInput = ({
    onChange,
    disabled,
    inputType,
    type,
    value,
    onKeyDown,
    onKeyUp,
    onFocus,
    onBlur,
    classNames,
    id,
    style,
    readOnly,
}) => {
    const withSeconds = type === "timeFull" || type === "dateTimeFull";
    const date = html`
        <!-- prettier-ignore-attribute -->
        <input
            type=${inputType}
            onchange=${onChange}
            value=${value}
            disabled=${disabled}
            step=${withSeconds ? 1 : ""}
            onkeydown=${onKeyDown}
            onkeyup=${onKeyUp}
            onfocus=${onFocus}
            onblur=${onBlur}
            class=${classNames.join(" ")}
            id=${id}
            style=${style}
            readOnly=${readOnly}
        />
    `;
    return date;
};

class DateField extends Field$1 {
    constructor({ type = "date", format, ...rest }) {
        super({
            ...rest,
            fieldType: "date",
        });
        this.type = type in types ? type : "date";
        this.settings = {
            ...types[this.type],
            format: format ?? types[this.type].format,
        };
        this.date = DateTime.fromFormat(
            this.getValue() ?? "",
            this.settings.format
        );
        this.displayValue = o("");

        on(this.value, () => {
            const val = this.getValue();
            if (!val) {
                this.date.invalid = true;
                this.displayValue("");
            } else {
                const date = DateTime.fromFormat(val, this.settings.format);
                this.displayValue(date.toFormat(this.settings.jsFormat));
                if (this.date?.toMillis() === date.toMillis()) return;

                this.date = date;
            }
        });

        setup$8(this);
    }
    setValue(dateSrc) {
        const dateSrcType = typeof dateSrc;

        this.date =
            dateSrcType === "string"
                ? DateTime.fromISO(dateSrc)
                : dateSrcType === "number"
                ? DateTime.fromMillis(dateSrc)
                : dateSrc?.isLuxonDateTime
                ? dateSrc
                : DateTime.fromJSDate(dateSrc);

        if (this.date.invalid) {
            if (this.getValue() != null) {
                super.setValue(null);
            }
            return;
        }
        super.setValue(this.date.toFormat(this.settings.format));
    }
    getDate() {
        return this.date;
    }
    clear() {
        this.displayValue("");
    }

    handleBlur(...params) {
        super.handleBlur(...params);
        const [ev] = params;

        if (this.displayValue() === ev.target.value) return;

        this.setValue(ev.target.value);
    }

    handleKeyUp(...params) {
        super.handleKeyDown(...params);
        /**
         * @type {KeyboardEvent}
         */
        const ev = params[0];

        if (
            ev.key.toLocaleLowerCase() !== "enter" ||
            ev.shiftKey ||
            ev.ctrlKey ||
            ev.metaKey ||
            ev.altKey
        ) {
            return;
        }

        if (this.displayValue() === ev.target.value) return;

        this.setValue(ev.target.value);
    }
}

/**
 *
 * @param {DateField} df
 */
function setup$8(df) {
    df.configureInputTemplate({
        inputTemplate: DateInput,
        value: df.displayValue,
        onChange: () => {},
        inputType: df.settings.inputType,
        type: df.type,
    });

    df.configureTemplate({ moveTitle: false }, df.inputElement);
}

const ConfirmationModal = (props) => {
    const {
        content,
        onConfirm,
        onReject,
        confirmButtonText: cbt,
        rejectButtonText: rbt,
        class: className,
    } = props;
    const confirmBtn = Button({
        text: cbt ?? Icon({ name: "check" }),
        onClick: (ev) => {
            onConfirm?.(ev);
            // confirmationModal.hide();
        },
        type: "button",
    });

    const rejectBtn = Button({
        text: rbt ?? Icon({ name: "xmark" }),
        onClick: (ev) => {
            onReject?.(ev);
            // confirmationModal.hide();
        },
        className: "--grey --outline",
        type: "button",
    });

    const modalContent = html`<div class="confirmation-modal${className ?? ""}">
        ${content}
        <div class="footer">
            <div class="buttons">${rejectBtn}${confirmBtn}</div>
        </div>
    </div>`;

    const confirmationModal = Modal({
        content: modalContent,
        onHide: ({ escape, background } = {}) => {
            if (escape || background) {
                onReject?.();
            }
        },
    });
    return confirmationModal;
};

// import {}

/**
 * 
 * @returns {HTMLLIElement}
 */
const ListItem = ({ data, component, ...rest }, ...children) => {
    const li = html`<li
        ...${rest}
        class="list-item ${rest.class ?? ""} ${rest.className ??
        ""} ${rest.classNames ?? ""}"
    >
        ${component ? component({ data }) : data} ${children}
    </li>`;

    return li;
};

// import {}
/**
 * 
 * @returns {HTMLUListElement} 
 */
const List = ({ classNames = "", items, className, ...rest }, ...children) => {
    return html`<ul
        ...${rest};
        class="list ${rest.class ?? ""} ${className ?? ""} ${classNames ?? ""}"
    >
        ${items && map(items, (data) => ListItem({ data }))} ${children}
    </ul>`;
};

const FileItem = ({
    data,
    path,
    onFileClick,
    isNew,
    onFileDelete,
    disabled,
    readOnly,
    tooltip,
}) => {
    const value = data instanceof File ? data.name : get(data, path);
    const deleteButton = Button({
        text: html`<${Icon} name="xmark" />`,
        type: "button",
        disableTabFocus: true,
        className: "--transparent --borderless file-delete-btn",
        title: "Удалить",
        onClick: (ev) => {
            ev.stopPropagation();
            onFileDelete(data);
        },
    });
    const li = html`<${ListItem}
        className="files-list-v2-item${isNew ? " new" : ""}"
        title=${!tooltip ? value : tooltip({ data, path })}
    >
        <span class="file-name">${value}</span>
        ${() => (!disabled() && !readOnly() ? deleteButton : null)}
    <//>`;

    li.addEventListener("click", () => onFileClick(data));
    return li;
};

const FilesList = ({ files, newFiles, isEmpty, FileItemComponent = FileItem, ...rest }) => {
    const createListItem =
        (isNew = false) =>
        (data) =>
            FileItemComponent({ ...rest, data, isNew });
    const list = html`<div class="scrollable">
        <${List} classNames="files-list-v2">
            ${() => (files()?.length > 0 ? map(files, createListItem()) : null)}
            ${map(newFiles, createListItem(true))}
        <//>
    </div>`;
    return html`${() => (isEmpty() ? null : list)}`;
};

const AddFileButton$2 = ({ id, addFileBtnText, class: className }) => {
    return html`<label
        class="button field-button files-upload-field-button add-btn ${className ??
        ""}"
        htmlFor=${id}
        type="button"
        >${addFileBtnText}</label
    >`;
};

const FilesInputTemplate = ({
    onChange,
    id,
    key,
    classNames,
    onFocus,
    onBlur,
    files,
    disabled,
    accept,
    multiple,
    readOnly,
}) => {
    const input = html`
        <!-- prettier-ignore-attribute -->
        <input
            type="file"
            multiple=${multiple}
            accept=${accept || "*"}
            name=${key}
            id=${id}
            onchange=${onChange}
            class=${classNames.join(" ")}
            onfocus=${onFocus}
            onblur=${onBlur}
            files=${files}
            disabled=${disabled}
            readOnly=${readOnly}
        />
    `;
    return input;
};

class FilesUploadField extends Field$1 {
    constructor({
        onSaveFile: uploadFileRequest,
        title = "Файлы",
        addFileBtnText = "Добавить",
        uploadFilesBtnText = "Загрузить",
        displayValue = "name",
        path,
        value,
        files,
        onSaveClick,
        onUploadFiles,
        onDeleteFile: deleteFileRequest = deleteFile,
        confirmDelete = false,
        acceptFiles,
        multiple = true,
        onAllFilesSaved,
        fileTooltip,
        FileItemComponent,
        uploadButton: uploadBtnCfg,
        addButton: addBtnCfg,
        confirmUpload = true,
        ...rest
    }) {
        super({ ...rest, fieldType: "files-upload", title });
        this.files = getObservable(files ?? value ?? []);
        this.newFilesList = o();
        this.newFiles = computed(() => Array.from(this.newFilesList() ?? []));
        this.uploadFileRequest = uploadFileRequest;
        this.deleteFileRequest = deleteFileRequest;
        this.addFileBtnText = addFileBtnText;
        this.uploadFilesBtnText = uploadFilesBtnText;
        this.path = path ?? displayValue;
        this.onSaveClick = onSaveClick;
        this.onUploadFiles = onUploadFiles;
        this.acceptFiles = acceptFiles;
        this.multiple = multiple;
        this.onAllFilesSaved = onAllFilesSaved;
        this.fileTooltip = fileTooltip;
        this.isEmpty = computed(
            () => !(this.files()?.length > 0) && !(this.newFiles().length > 0)
        );
        this.confirmDelete = confirmDelete;
        this.FileItemComponent = FileItemComponent;
        this.addBtnCfg = addBtnCfg;
        this.uploadBtnCfg = uploadBtnCfg;
        this.confirmUpload = confirmUpload;
        this.loading = o(false);
        setup$7(this);
    }

    setFiles(files) {
        this.files(files);
        this.onChange?.({ key: this.key, value: files });
    }

    setNewFiles(newFiles) {
        this.newFilesList(newFiles);
    }

    clearNewFiles() {
        this.newFilesList(undefined);
    }

    setValue(files) {
        this.setFiles(files);
    }

    getValue() {
        return this.getFiles();
    }

    getFiles() {
        return this.files();
    }

    handleMouseDown() {}

    async uploadFiles() {
        if (this.disabled()) return;
        if (this.newFiles().length === 0) return;

        if (this.onUploadFiles) {
            await this.onUploadFiles();
        }

        const newFiles = this.newFiles();
        this.loading(true);

        const filesUploads = newFiles.map(async (file) => {
            const { name } = file;
            const data = await getFileData(file);
            return this.uploadFileRequest({ name, data });
        });

        try {
            const results = await Promise.all(filesUploads);
            const savedFiles = results
                .map((res, i) => {
                    const { name } = newFiles[i];
                    if (!res.isOk) {
                        Message$1(`Не загрузился файл: ${name}`, "info");
                        console.error(res.error);
                        return;
                    }
                    const docid = get(res, "data.docid");
                    return { name, docid };
                })
                .filter((f) => f != null);
            const currentFiles = this.files() ?? [];

            this.setFiles(currentFiles.concat(savedFiles));
            this.clearNewFiles();
            this.inputElement.value = "";
            this.onAllFilesSaved?.();
        } catch (error) {
            console.error(error);
        } finally {
            this.loading(false);
        }
    }

    async deleteFile(fileToDelete) {
        const { docid, name } = fileToDelete;

        // удаляем файл, если он не загружен в бд
        if (!docid) {
            /**@type {Array} */
            const list = this.newFiles();
            const dt = new DataTransfer();

            list.filter((f) => f.name !== name).forEach((f) => dt.items.add(f));

            this.setNewFiles(dt.files);

            return;
        }

        const deleteFile = async (docid) => {
            // проверяем, описан ли запрос для удаления файла
            if (typeof this.deleteFileRequest !== "function") {
                console.warn("onDeleteFile not implemented");
                return;
            }
            const loader = Loader();
            loader.show();

            try {
                // удаляем файл
                const result = await this.deleteFileRequest({ docid });
                if (result.isOk) {
                    // если файл удален в бд, то удаляем и на вебе
                    const files = this.files().filter(
                        (file) => file.docid !== docid
                    );
                    this.setFiles(files);
                }
            } catch (error) {
                console.error(error);
            } finally {
                loader.hide();
            }
        };

        if (this.confirmDelete) {
            const modal = ConfirmationModal({
                content: html`<p style=${{ "text-align": "center" }}>
                    Вы уверены, что хотите удалить этот файл?<br />
                    ${name ? `"${name}"` : ""}
                </p>`,
                onConfirm: async () => {
                    await deleteFile(docid);
                    modal.hide();
                },
                onReject: () => modal.hide(),
            });
            modal.show();
        } else {
            await deleteFile(docid);
        }
    }
}

/**
 *
 * @param {FilesUploadField} fuf
 */
const downloadFile = async ({ docid }) => {
    const httpTypeByMimeType = {
        text: "application/plain",
        txt: "text/plain",
        png: "image/png",
        jpeg: "image/jpeg",
        svg: "image/svg+xml",
        xls: "application/x-excel",
        xlsx: "application/x-excel",
        zip: "application/zip",
    };
    if (!docid) return console.warn("Cant download file! id required");
    try {
        const result = await getFile(docid);
        const fileName = result.Filename;
        const index = fileName.lastIndexOf(".");
        if (index === -1) {
            throw new Error("There is no mime type in file from server file");
        }
        const mime = fileName.substring(index + 1);
        const type = httpTypeByMimeType[mime];

        const { Data: fileData } = result;
        const fileDataLength = fileData.length;
        const array = new Uint8Array(fileDataLength);
        for (let i = 0; i < fileDataLength; i++) {
            array[i] = fileData.charCodeAt(i);
        }

        const fileBlob = new Blob([array], { type });
        const link = html`<a
            href=${URL.createObjectURL(fileBlob)}
            download=${result.Filename}
        ></a>`;
        link.click();
    } catch (error) {
        Message$1(
            "Не получилось скачать файл.\nПовторите попытку позднее",
            "info"
        );
        console.error(error);
    }
};

/**
 *
 * @param {FilesUploadField} fuf
 */
const setup$7 = (fuf) => {
    const isEmptyNewFiles = computed(() => fuf.newFiles().length === 0);
    const filesList = FilesList({
        files: fuf.files,
        newFiles: fuf.newFiles,
        path: fuf.path,
        FileItemComponent: fuf.FileItemComponent,
        onFileClick: downloadFile,
        onFileDelete: (data) => fuf.deleteFile(data),
        isEmpty: () => fuf.isEmpty(),
        disabled: fuf.disabled,
        readOnly: fuf.readOnly,
        tooltip: fuf.fileTooltip,
    });
    const addBtn = AddFileButton$2({
        id: fuf.inputId,
        addFileBtnText: fuf.addBtnCfg?.content ?? fuf.addFileBtnText,
        class: fuf.addBtnCfg?.class,
    });
    const handleClick = fuf.onSaveClick ?? fuf.uploadFiles.bind(fuf);
    const uploadBtn = Button({
        text: fuf.uploadBtnCfg?.content ?? fuf.uploadFilesBtnText,
        disabled: fuf.disabled,
        class: [
            "green",
            "field-button",
            "files-upload-field-button",
            "upload-btn",
            fuf.uploadBtnCfg?.class,
        ]
            .filter((v) => !!v)
            .join(" "),
        onClick: handleClick,
        disableTabFocus: true,
    });
    const renderButtons = () => {
        if (fuf.disabled()) return;
        if (fuf.readOnly()) return;
        if (fuf.loading()) return;
        if (fuf.multiple || fuf.files().length === 0) {
            return isEmptyNewFiles()
                ? addBtn
                : fuf.confirmUpload
                ? uploadBtn
                : null;
        }
    };

    function handleAddFiles(ev) {
        fuf.setNewFiles(ev.target.files);
        if (!fuf.confirmUpload) {
            handleClick();
        }
    }

    fuf.configureInputTemplate({
        inputTemplate: FilesInputTemplate,
        onChange: handleAddFiles,
        files: fuf.newFilesList,
        accept: fuf.acceptFiles,
        multiple: fuf.multiple,
    });

    fuf.configureTemplate(
        { moveTitle: false },
        fuf.inputElement,
        filesList,
        renderButtons,
        () => (fuf.loading() ? html`<span class="spinner" />` : null)
    );

    fuf.element.addEventListener("dragenter", () => {
        fuf.inputElement.classList.add("on-top");
    });

    fuf.element.addEventListener("drop", () => {
        fuf.inputElement.classList.remove("on-top");
    });
};

const defaultCalcStyle = (parentRect, elementRect) => {
    const changePosition =
        parentRect.bottom + elementRect.height > document.body.clientHeight;
    const topPosition = changePosition ? "auto" : `${parentRect.bottom}px`;
    const bottomPosition = changePosition
        ? `${document.body.clientHeight - parentRect.top}px`
        : "auto";

    return {
        top: topPosition,
        left: `${parentRect.left}px`,
        bottom: bottomPosition,
        width: `${parentRect.width}px`,
    };
};

const updateStyle = (element, styleObject) => {
    for (const key of Object.keys(styleObject)) {
        element.style[key] = styleObject[key];
    }
};

const FloatingWindow = (
    {
        className = "",
        parentRect,
        calcStyle = defaultCalcStyle,
        updatePositionObservable,
        visible,
        onOutsideClick,
    },
    ...children
) => {
    /**@type {HTMLDivElement} */
    const floatingWindow = html`<div class="floating-window ${className}">
        ${children}
    </div>`;

    const handleDocumentClick = (ev) => {
        if (!visible()) return;
        const fw = ev.target.closest(".floating-window");
        if (fw != null) return;
        onOutsideClick(ev);
    };

    /**
     *
     * @param {KeyboardEvent} ev
     */
    const handleEscKeyUp = (ev) => {
        if (ev.key.toLowerCase() !== "escape") return;
        visible(false);
        onOutsideClick?.(ev);
    };

    observe(floatingWindow);
    floatingWindow.addEventListener("connected", (ev) => {
        document.addEventListener("mousedown", handleDocumentClick);
        document.addEventListener("keyup", handleEscKeyUp);

        if (typeof updatePositionObservable === "function") {
            on(updatePositionObservable, () => {
                const newStyle = calcStyle(
                    parentRect(),
                    floatingWindow.getBoundingClientRect(),
                );
                updateStyle(floatingWindow, newStyle);
            });
        } else {
            const newStyle = calcStyle(
                parentRect(),
                ev.target.getBoundingClientRect(),
            );
            updateStyle(floatingWindow, newStyle);
        }
    });
    floatingWindow.addEventListener("disconnected", () => {
        document.removeEventListener("mousedown", handleDocumentClick);
        document.removeEventListener("keyup", handleEscKeyUp);
    });

    return html`${on(visible, () => (visible() ? floatingWindow : null))}`;
};

const SelectedOption = ({ value, text, onDelete, disabled }) => {
    const btn = Button({
        classNames: ["--transparent", "selected-option__btn"],
        disabled,
        icon: { name: "close" },
        onClick: (ev) => {
            ev.stopPropagation();
            onDelete?.({ value, text });
        },
    });
    return html`<${ListItem} classNames="selected-option">
        <span class="selected-option__label">${text}</span>
        ${btn}
    <//>`;
};

const OptionsListItem = ({
    value,
    text,
    selected,
    onChange,
    key: fieldKey,
}) => {
    const id = `${fieldKey == null ? "" : `${fieldKey}_`}${uid()}-${value}`;
    const option = html`<${ListItem}
        classNames="options-list-item${() => (selected?.() ? " selected" : "")}"
    >
        <input
            checked=${selected}
            id=${id}
            type="checkbox"
            class="options-list-item__cb"
            onchange=${() => onChange?.(value)}
        />

        <label htmlFor=${id} class="options-list-item__label"> ${text} </label>
    <//>`;
    return option;
};

const OptionsList = ({
    options,
    onSelectItem,
    isSelected,
    onMouseDown,
    fieldRect,
    visible,
    onOutsideClick,
    optionsListStyle,
    calcStyle,
    isCellField,
    ...rest
}) => {
    const handleSelect = (value) => {
        onSelectItem?.(value);
    };

    /**@type {HTMLUListElement} */
    const optionsList = html`<${List}
        classNames="options-list${isCellField ? " cell-field": ""}"
        style=${optionsListStyle}
    >
        ${map(options, (op) =>
            OptionsListItem({
                ...op,
                ...rest,
                selected:
                    typeof isSelected === "function"
                        ? computed(() => isSelected(op.value))
                        : () => false,
                onChange: handleSelect,
            }),
        )}
    <//>`;
    optionsList.onmousedown = onMouseDown;
    return FloatingWindow(
        {
            parentRect: fieldRect,
            onOutsideClick,
            visible,
            calcStyle,
            className: "select-fw",
        },
        optionsList
    );
};

const SelectInput = ({
    value,
    onChange,
    onClick,
    disabled,
    onFocusOut,
    onKeyUp,
    onKeyDown,
    onFocus,
    onBlur,
    classNames,
    id,
    placeholder,
    active,
    searchable,
    readOnly,
}) => {
    const input = html`
        <!-- prettier-ignore-attribute -->
        <input
            type="text"
            value=${value}
            placeholder=${placeholder}
            data-select-input
            onclick=${onClick}
            name="select"
            oninput=${onChange}
            disabled=${disabled}
            onfocusout=${onFocusOut}
            onkeyup=${onKeyUp}
            onkeydown=${onKeyDown}
            onfocus=${onFocus}
            onblur=${onBlur}
            class="${classNames.join(" ")}${() => (active() ? " active" : "")}"
            id=${id}
            readOnly=${() => readOnly() || !searchable()}
            autocomplete="off"
        />
    `;

    return input;
};

class SelectField extends Field$1 {
    constructor({
        options = [],
        multiple = false,
        searchable = true,
        optionsListStyle,
        calcListPosition,
        ...rest
    } = {}) {
        const fieldType = `select${multiple ? "-multi" : ""}`;
        super({
            ...rest,
            fieldType,
        });
        this.defaultOptions = getObservable(options);
        this.options = o(this.defaultOptions());
        this.isOptionsListShown = o(false);
        this.inputText = o("");
        this.multiple = multiple;
        this.searchable = o(multiple ? true : searchable);
        this.calcListPosition = calcListPosition;
        this.isEmpty = computed(() => {
            const val = this.getValue();
            if (!this.multiple) return val == null || val === "";
            return !(val?.length > 0);
        });
        if (!this.searchable()) {
            subscribe$1(() => {
                this.active(this.isOptionsListShown());
            });
        }

        on(this.value, () => {
            const val = this.getValue();
            if (val == null) {
                this.inputText("");
            } else {
                if (this.multiple) return;
                const option = this.options().find((opt) => opt.value === val);
                this.inputText(option?.inputText ?? option?.text ?? "");
            }
        });

        on(this.defaultOptions, () => {
            this.options(this.defaultOptions());
        });

        setup$6(this, { optionsListStyle });
    }

    toggleOptionsList() {
        this.isOptionsListShown(!this.isOptionsListShown());
    }
    showOptionsList() {
        !this.isOptionsListShown() && this.isOptionsListShown(true);
    }
    hideOptionsList() {
        this.isOptionsListShown() && this.isOptionsListShown(false);
    }

    setCurrentOptions(newOptions) {
        this.options(newOptions);
    }
    getCurrentOptions() {
        return this.options();
    }

    // setDefaultOptions(newOptions) {
    //     this.defaultOptions(newOptions);
    //     // this.setCurrentOptions(newOptions);
    // }
    getDefaultOptions() {
        return this.defaultOptions();
    }

    setValue(newValue, updateLabel = true) {
        const currentValue = this.getValue();
        if (!this.multiple && newValue == currentValue) {
            return;
        }
        if (
            this.multiple &&
            JSON.stringify(currentValue) == JSON.stringify(newValue)
        ) {
            return;
        }

        if (updateLabel && !this.multiple) {
            const option = this.options().find((opt) => opt.value === newValue);
            this.inputText(option?.inputText ?? option?.text ?? "");
            this.hideOptionsList();
            this.setCurrentOptions(this.defaultOptions());
        }
        this.value(newValue);
        this.onChange?.({ key: this.key, value: newValue });

        if (!this.multiple) return;
        this.setCurrentOptions(
            this.getDefaultOptions().filter((op) => {
                return !newValue?.includes?.(op.value);
            })
        );
    }

    clear() {
        this.setValue(null);
        this.inputText("");
    }

    handleKeyUp(ev) {
        if (ev.keyCode !== 13) return;

        ev.preventDefault();
        if (!this.isOptionsListShown()) {
            ev.target.blur();
            return;
        }

        const [firstOption] = this.getCurrentOptions();
        if (!firstOption) {
            return;
        }

        if (!this.multiple) {
            this.setValue(firstOption.value);
        } else {
            const selectedOptions = this.getValue() || [];
            this.setValue(selectedOptions.concat(firstOption.value));
            this.inputText("");
        }
        ev.target.blur();
    }

    handleBlur(ev) {
        if (this.isEmpty()) {
            this.inputText("");
            this.setCurrentOptions(this.getDefaultOptions());
        }
        super.handleBlur(ev);
    }
}

/**
 *
 * @param {SelectField} sf
 */
function setup$6(sf, params) {
    const dropDownBtn = Button({
        classNames: ["--transparent", "field-button"],
        icon: { name: "select" },
        onClick: () => {
            if (sf.disabled()) return;
            if (sf.readOnly()) return;
            sf.toggleOptionsList();
        },
        disabled: () => sf.disabled() || sf.readOnly(),
        disableTabFocus: true,
    });

    const clearBtn = Button({
        classNames: ["--transparent", "field-button"],
        icon: { name: "close" },
        onClick: () => sf.clear(),
        disabled: sf.disabled,
        disableTabFocus: true,
    });

    const isSelected = (optionValue) => {
        return sf.getValue() == optionValue;
    };

    const { optionsListStyle } = params;

    const optionsList = OptionsList({
        options: () => sf.getCurrentOptions(),
        visible: () => sf.isOptionsListShown(),
        onSelectItem: (...args) => {
            sf.hideOptionsList();
            handleSelect(...args);
        },
        isSelected: sf.multiple ? null : isSelected,
        onMouseDown: (ev) => sf.handleMouseDown(ev),
        fieldRect: () => sf.element.getBoundingClientRect(),
        onOutsideClick: (ev) => {
            const field = ev.target.closest(
                sf.multiple ? ".select-multi-field" : ".select-field"
            );

            if (field == null || field.dataset.key !== sf.key) {
                sf.inputElement.blur();
                sf.hideOptionsList();
            }
        },
        optionsListStyle,
        calcStyle: sf.calcListPosition,
        key: sf.key,
        isCellField: sf.isCellField
    });

    function handleSelect(optionValue) {
        if (!sf.multiple) {
            sf.setValue(optionValue);
        } else {
            const value = sf.getValue() ?? [];
            sf.setValue(value.concat(optionValue), false);
        }
    }

    function handleUnselect(option) {
        const currentValue = sf.getValue().filter((o) => o != option.value);
        sf.setValue(currentValue, false);
    }

    function handleFilterList(ev) {
        if (!sf.multiple) {
            sf.setValue(null, false);
        }
        sf.showOptionsList();
        sf.inputText(ev.target.value);

        const regexp = new RegExp(`.*${ev.target.value}.*`, "i");
        const filteredOptions = sf.getDefaultOptions().filter((opt) => {
            const test = regexp.test(opt.text);
            if (!sf.multiple) return test;
            const value = sf.getValue();
            if (value == null) return test;
            return test && !value.some((val) => val === opt.value);
        });

        sf.setCurrentOptions(filteredOptions);
    }

    sf.configureInputTemplate({
        inputTemplate: SelectInput,
        onChange: handleFilterList,
        onClick: () => {
            if (sf.disabled()) return;
            if (sf.readOnly()) return;
            sf.toggleOptionsList();
        },
        value: sf.inputText,
        onFocusOut: () => {
            sf.hideOptionsList();
        },
        searchable: sf.searchable,
    });

    if (!sf.multiple) {
        sf.configureTemplate(
            { hoverTip: sf.tooltip ?? "" },
            sf.inputElement,
            dropDownBtn
        );
    } else {
        const selectedOptions = () => {
            return (
                sf
                    .getValue()
                    ?.map((val) =>
                        sf.getDefaultOptions().find(({ value }) => value == val)
                    ) || []
            );
        };
        sf.configureTemplate(
            { hoverTip: sf.tooltip ?? "" },
            html`<${List} classNames="${sf.fieldType}-field-content">
                ${map(selectedOptions, (op) =>
                    SelectedOption({
                        ...op,
                        onDelete: handleUnselect,
                        disabled: sf.disabled,
                    })
                )}
                <${ListItem}
                    data=${sf.inputElement}
                    classNames="${sf.fieldType}-field-content__input-container"
                />
            <//>`,
            () => (sf.disabled() || sf.readOnly() ? null : clearBtn),
            dropDownBtn
        );
    }

    observe(sf.element);

    sf.element.addEventListener("connected", (/* ev */) => {
        document.body.appendChild(optionsList);
    });
    sf.element.addEventListener("disconnected", () => {
        sf.hideOptionsList();
    });
}

const TextArea = ({
    value,
    onChange,
    disabled,
    rowsCount,
    classNames,
    // onKeyUp,
    // onKeyDown,
    onFocus,
    onBlur,
    id,
    placeholder,
    style,
    readOnly,
}) => {
    const textarea = html`
        <!-- prettier-ignore-attribute -->
        <textarea
            value=${value}
            onchange=${onChange}
            placeholder="textarea"
            disabled=${disabled}
            oninput=${onChange}
            rows=${rowsCount}
            placeholder=${placeholder}
            id=${id}
            class=${classNames.join(" ")}
            onfocus=${onFocus}
            onblur=${onBlur}
            style=${style}
            readOnly=${readOnly}
        />
    `;
    return textarea;
};

class TextAreaField extends Field$1 {
    constructor({ rowsCount = 3, ...rest }) {
        super({
            ...rest,
            fieldType: "textarea",
        });
        this.rowsCount = rowsCount;
        setup$5(this);
    }
}

/**
 *
 * @param {TextAreaField} taf
 */
function setup$5(taf) {
    taf.configureInputTemplate({
        inputTemplate: TextArea,
        rowsCount: taf.rowsCount,
    });
    taf.configureTemplate({ moveTitle: false }, taf.inputElement);
}

const DisplayValueElement = ({ value, classNames, style }) => {
    const displayedValue = () => {
        const v = value();
        return v ? v : "\u00A0";
    };
    const val = html`<div class=${classNames?.join?.(" ") ?? ""} style=${style}>
        ${displayedValue}
    </div>`;

    return val;
};

class DefaultField extends Field$1 {
    constructor(props) {
        super({ ...props, fieldType: "default", disabled: true });
        this.configureInputTemplate({ inputTemplate: DisplayValueElement });
        this.configureTemplate(null, this.inputElement);
    }
    setValue() {
        throw new TypeError("Can't set value in default Field");
    }
    setDisabled() {}
}

const DateInterval = ({ from, till, periodType, onButtonClick }) => {
    const tillDateRender = on(periodType, () =>
        periodType() === 1 ? null : till,
    );
    const dateInterval = html`<div class="date-interval__input-container">
        ${from}${tillDateRender}
    </div>`;
    const nextBtn = Button({
        onClick: () => {
            onButtonClick("next");
        },
        icon: { name: "chevron-right" },
        classNames: ["date-interval__btn"],
    });
    const prevBtn = Button({
        onClick: () => {
            onButtonClick("prev");
        },
        icon: { name: "chevron-left" },
        classNames: ["date-interval__btn"],
    });

    const interval = html`
        <div class="date-interval">
            ${on(periodType, () =>
                [0, 4, 8].includes(periodType()) ? null : prevBtn,
            )}
            ${dateInterval}
            ${on(periodType, () =>
                [0, 4, 8].includes(periodType()) ? null : nextBtn,
            )}
        </div>
    `;

    return periodType() === 8 ? null : interval;
};

const periodTypes = {
    0: {
        value: 0,
        text: "Период",
    },
    1: {
        value: 1,
        text: "День",
        inc: {
            type: "days",
            value: 1,
        },
    },
    2: {
        value: 2,
        text: "Неделя",
        inc: {
            type: "weeks",
            value: 1,
        },
    },
    3: {
        value: 3,
        text: "Месяц",
        inc: {
            type: "months",
            value: 1,
        },
    },
    4: {
        value: 4,
        text: "Последний месяц",
        inc: {
            type: "months",
            value: 1,
        },
    },
    5: {
        value: 5,
        text: "Квартал",
        inc: { type: "months", value: 3 },
    },
    6: {
        value: 6,
        text: "Полугодие",
        inc: { type: "months", value: 6 },
    },
    7: {
        value: 7,
        text: "Год",
        inc: { type: "years", value: 1 },
    },
    8: {
        value: 8,
        text: "Все время",
    },
};

const calcEndDate = ({ periodTypeId, fromDate = DateTime.now() }) => {
    let tillDate = null;
    const { inc } = periodTypes[periodTypeId];
    switch (periodTypeId) {
        case 2:
        case 4: {
            tillDate = fromDate.plus({ [inc.type]: inc.value });
            break;
        }
        case 3:
        case 5:
        case 6:
        case 7: {
            tillDate = fromDate.plus({ [inc.type]: inc.value, days: -1 });
        }
    }
    return tillDate;
};

const calcInitialDate = ({
    periodTypeId,
    fromDate = DateTime.now(),
    weekBeginWith
}) => {
    switch (periodTypeId) {
        case 2: {
            if (weekBeginWith != null) {
                fromDate = fromDate.set({weekday: weekBeginWith});
            }
            break;
        }
        case 3: {
            fromDate = fromDate.set({
                day: 1,
                month: fromDate.get("mont"),
                year: fromDate.get("year"),
            });
            break;
        }
        case 4: {
            fromDate = DateTime.now().plus({ month: -1 });
            break;
        }
        case 5: {
            const currentMonth = fromDate.get("month");
            const quarter = Math.ceil(currentMonth / 3);

            fromDate = DateTime.fromObject({
                month: (quarter - 1) * 3 + 1,
                day: 1,
                year: fromDate.get("year"),
            });
            break;
        }
        case 6: {
            const currentMonth = fromDate.get("month");
            const half = Math.ceil(currentMonth / 6);

            fromDate = DateTime.fromObject({
                month: (half - 1) * 6 + 1,
                day: 1,
                year: fromDate.get("year"),
            });
            break;
        }
        case 7: {
            fromDate = DateTime.fromObject({
                month: 1,
                day: 1,
                year: fromDate.get("year"),
            });
            break;
        }
    }
    return fromDate;
};

/**
 *
 * @param {{periodTypeId, date: DateTime, direction: "next" | "prev"}} param0
 */
const calcDate = ({
    periodTypeId,
    date = DateTime.now(),
    direction,
}) => {
    const multiplier = direction === "next" ? 1 : -1;
    const { inc } = periodTypes[periodTypeId];
    if (!inc) return date;
    return date.plus({ [inc.type]: inc.value * multiplier });
};

/**
 *
 * @param {{periodTypeId: number, fromDate: DateTime, direction?: "next" | "prev"}} param0
 */
const calcInterval = ({
    periodTypeId,
    fromDate = DateTime.now(),
    direction,
    weekBeginWith
}) => {
    if (periodTypeId === 8) return { allTime: true };

    const from =
        direction == null
            ? calcInitialDate({ periodTypeId, fromDate, weekBeginWith })
            : calcDate({ periodTypeId, date: fromDate, direction });

    if (from.invalid) return null;

    if (periodTypeId === 1) return { from: from.toFormat(defaultFormats.DATE) };

    const till = calcEndDate({ periodTypeId, fromDate: from });
    return {
        from: from.toFormat(defaultFormats.DATE),
        till: till.toFormat(defaultFormats.DATE),
    };
};

const calcStyle = (parentRect, elementRect) => {
    const changePosition =
        parentRect.bottom + elementRect.height > document.body.clientHeight;
    const topPosition = changePosition ? "auto" : `${parentRect.bottom}px`;
    const bottomPosition = changePosition
        ? `${document.body.clientHeight - parentRect.top}px`
        : "auto";

    const result = {
        top: topPosition,
        left: `${parentRect.left}px`,
        bottom: bottomPosition,
    };
    if (parentRect.width > elementRect) {
        result.width = `${parentRect.width}px`;
    }

    return result;
};

const PeriodMenu = ({
    periodTypesOptions,
    onPeriodTypeChange,
    dateFrom,
    dateTill,
    periodType,
    fieldRect,
    onDateIntervalChange,
    onDateChange,
    onOutsideClick,
    visible,
    weekBeginWith,
    isPeriodFixed
}) => {
    const select = new SelectField({
        value: () => periodType(),
        onChange: handlePeriodTypeChange,
        options: periodTypesOptions,
        title: "Тип периода",
        searchable: false,
        optionsListStyle: { "max-height": "initial" },
    });
    const from = new DateField({
        type: "date",
        value: dateFrom,
        onChange: handleDateChange,
        key: "from",
        title: "Дата с:",
        style: { flex: 1 },
    });
    const till = new DateField({
        type: "date",
        value: dateTill,
        onChange: handleDateChange,
        key: "till",
        title: "Дата по:",
        style: { flex: 1 },
    });

    /**
     * @type {HTMLDivElement}
     */
    const menu = html`<${FloatingWindow}
        className=${"period-field-menu"}
        parentRect=${fieldRect}
        updatePositionObservable=${periodType}
        visible=${visible}
        onOutsideClick=${handleOutsideClick}
        calcStyle=${calcStyle}
    >
        ${isPeriodFixed ? null : select.render()}
        <${DateInterval}
            from=${from.render()}
            till=${till.render()}
            periodType=${periodType}
            onButtonClick=${handleButtonClick}
        />
    <//>`;

    function handleButtonClick(direction) {
        const periodTypeId = periodType();
        if (periodTypeId === 0 || periodTypeId === 8 || periodTypeId === 4)
            return;
        let fromDate = from.getDate();
        const interval = calcInterval({ periodTypeId, fromDate, direction });
        onDateIntervalChange(interval);
    }

    function handleDateChange(props) {
        const periodTypeId = periodType();
        if (periodTypeId === 0) {
            return onDateChange(props);
        }

        const fromDate = from.getDate();
        const interval = calcInterval({
            periodTypeId,
            fromDate,
        });
        onDateIntervalChange(interval);
    }

    const updateDisabled = (periodTypeId) => {
        if ([0, 1].includes(periodTypeId)) {
            from.setDisabled(false);
            till.setDisabled(false);
        } else if (periodTypeId === 2) {
            from.setDisabled(weekBeginWith != null);
            till.setDisabled(true);
        } else {
            from.setDisabled(true);
            till.setDisabled(true);
        }
    };

    subscribe$1(() => {
        const periodTypeId = periodType();
        updateDisabled(periodTypeId);
        if (periodTypeId === 0) return;
        const fromDate =
            from.getDate() ??
            DateTime.fromFormat(from.getValue(), defaultFormats.DATE);
        const interval = calcInterval({
            periodTypeId,
            fromDate: fromDate.invalid ? undefined : fromDate,
            weekBeginWith,
        });
        onDateIntervalChange(interval);
    });

    function handlePeriodTypeChange({ value }) {
        const periodTypeId = value;
        onPeriodTypeChange(periodTypeId);
    }

    function handleOutsideClick(...params){
        from.inputElement.blur();
        till.inputElement.blur();
        onOutsideClick(...params);
    }

    return menu;
};

const Input = ({
    value,
    key,
    disabled,
    classNames,
    id,
    placeholder,
    style,
    onClick,
}) => {
    return html`
        <!-- prettier-ignore-attribute -->
        <input
            value=${value}
            name=${key}
            placeholder=${placeholder}
            disabled=${disabled}
            id=${id}
            class=${classNames.join(" ")}
            style=${style}
            readOnly=${true}
            onclick=${onClick}
        />
    `;
};

/* 
    {from, till}
*/
class PeriodField extends Field$1 {
    constructor({ period: pid = 0, weekBeginWith, fixedPeriod, ...rest }) {
        super({ ...rest, fieldType: "period" });
        this.periodType = o(
            periodTypes[fixedPeriod ?? pid].value ?? periodTypes[0].value
        );
        this.isPeriodFixed = fixedPeriod != null;
        this.isEmpty = on(this.value, () => {
            const value = this.getValue();
            const periodType = this.getPeriodType();
            if (periodType === 8) return !value?.allTime;
            if (periodType === 1) return !value?.from;
            return !value?.from || !value?.till;
        });
        this.isMenuOpened = o(false);
        this.active = this.isMenuOpened;
        this.weekBeginWith = weekBeginWith;
        setup$4(this);
    }
    setPeriodType(id) {
        this.periodType(periodTypes[id]?.value ?? periodTypes[0].value);
    }
    getPeriodType() {
        return this.periodType();
    }
    setValue(newValue) {
        if (JSON.stringify(newValue) === JSON.stringify(this.getValue()))
            return;
        super.setValue(newValue);
        if (newValue?.allTime) {
            this.hideMenu();
        }
    }

    toggleMenu() {
        this.isMenuOpened(!this.isMenuOpened());
    }
    showMenu() {
        if (!this.isMenuOpened()) this.isMenuOpened(true);
    }
    hideMenu() {
        if (this.isMenuOpened()) this.isMenuOpened(false);
    }
    handleMouseDown() {}
}

/**
 *
 * @param {PeriodField} pf
 */
function setup$4(pf) {
    const handleDateChange = (data) => {
        const value = pf.getValue() ?? {};
        if (value?.allTime) {
            delete value.allTime;
        }
        pf.setValue({ ...value, [data.key]: data.value });
    };

    const formattedValue = computed(() => {
        const { from, till, allTime } = pf.getValue() ?? {};
        return allTime
            ? "all time"
            : !from
            ? ""
            : `${from}${!till ? "" : ` - ${till}`}`;
    });
    pf.configureInputTemplate({
        inputTemplate: Input,
        value: formattedValue,
        onClick: () => {
            if (pf.disabled()) return;
            if (pf.readOnly()) return;
            pf.toggleMenu();
        },
    });

    const periodTypesOptions = Object.values(periodTypes).map(
        ({ text, value }) => ({
            text,
            value,
        })
    );

    const menu = PeriodMenu({
        dateFrom: computed(() => pf.getValue()?.from),
        dateTill: computed(() => pf.getValue()?.till),
        fieldRect: () => pf.element.getBoundingClientRect(),
        onPeriodTypeChange: (value) => pf.setPeriodType(value),
        periodType: computed(() => pf.getPeriodType()),
        periodTypesOptions: periodTypesOptions,
        onOutsideClick: (ev) => {
            if (ev.target.closest(".period-field") != null) {
                return;
            }
            pf.hideMenu();
        },
        onDateIntervalChange: (value) => pf.setValue(value),
        onDateChange: handleDateChange,
        visible: pf.isMenuOpened,
        weekBeginWith: pf.weekBeginWith,
        isPeriodFixed: pf.isPeriodFixed,
    });

    pf.configureTemplate(
        { hoverTip: pf.tooltip ?? formattedValue },
        pf.inputElement,
        () =>
            pf.disabled() || pf.readOnly()
                ? null
                : Button({
                      classNames: ["--transparent", "field-button"],
                      disabled: pf.disabled,
                      onClick: () => {
                          pf.setPeriodType(0);
                          pf.setValue(null);
                      },
                      disableTabFocus: true,
                      text: Icon({ name: "xmark" }),
                  })
    );

    observe(pf.element);
    pf.element.addEventListener("connected", () => {
        document.body.append(menu);
    });
    pf.element.addEventListener("disconnected", () => {
        pf.hideMenu();
    });
}

const EmailInput = ({
    key,
    value,
    onChange,
    disabled,
    placeholder,
    id,
    classNames,
    onKeyUp,
    onKeyDown,
    onFocus,
    onBlur,
    active,
    style,
    readOnly,
}) => {
    return html`
        <!-- prettier-ignore-attribute -->
        <input
            value=${value}
            name=${key}
            oninput=${onChange}
            onchange=${onChange}
            disabled=${disabled}
            placeholder=${placeholder}
            class="${classNames.join(" ")}${() => (active() ? " active" : "")}"
            id=${id}
            onkeydown=${onKeyDown}
            onkeyup=${onKeyUp}
            onblur=${onBlur}
            onfocus=${onFocus}
            type="email"
            style=${style}
            readOnly=${readOnly}
        />
    `;
};

class EmailField extends Field$1 {
    constructor(props) {
        super({
            ...props,
            fieldType: "email",
        });
        setup$3(this);
    }
}

/**
 *
 * @param {EmailField} emailField
 */
function setup$3(emailField) {
    emailField.configureInputTemplate({
        inputTemplate: EmailInput,
        type: emailField.type,
    });

    emailField.configureTemplate(null, emailField.inputElement);
}

const Template$1 = ({
    key,
    value,
    onChange,
    disabled,
    placeholder,
    id,
    classNames,
    onKeyUp,
    onKeyDown,
    onFocus,
    onBlur,
    active,
    style,
    readOnly,
}) => {
    return html`
        <!-- prettier-ignore-attribute -->
        <input
            value=${value}
            name=${key}
            oninput=${onChange}
            onchange=${onChange}
            disabled=${disabled}
            placeholder=${placeholder}
            class="${classNames.join(" ")}${() => (active() ? " active" : "")}"
            id=${id}
            onkeydown=${onKeyDown}
            onkeyup=${onKeyUp}
            onblur=${onBlur}
            onfocus=${onFocus}
            type="tel"
            style=${style}
            readOnly=${readOnly}
        />
    `;
};

class PhoneField extends Field$1 {
    constructor(props) {
        super({
            ...props,
            fieldType: "phone",
        });
        setup$2(this);
    }
}

/**
 *
 * @param {PhoneField} phoneField
 */
function setup$2(phoneField) {
    phoneField.configureInputTemplate({
        inputTemplate: Template$1,
        type: phoneField.type,
    });

    phoneField.configureTemplate(null, phoneField.inputElement);
}

/**
 *
 * @param {Field.properties} props
 * @returns {import("./baseField/baseField").default}
 */
const FieldController = (props) => {
    const { key, value, type, width, height, data } = props;
    let { style } = props;
    const typeOfStyle = typeof style;

    if (typeOfStyle === "string") {
        if (width) style += `width: ${width}px`;
    } else {
        if (typeOfStyle !== "object") {
            style = {};
        }
        if (width) style.width = `${width}px`;
    }
    let inputStyle = {};
    if (height) {
        inputStyle.height = `${height}px`;
    }

    let fieldController;

    const currentValue =
        value ??
        (typeof data == "function" ? () => get(data, key) : get(data, key));

    switch (type) {
        case "text":
        case "string":
        case "password": {
            fieldController = new TextField({
                ...props,
                type,
                value: currentValue,
                key,
                style,
                inputStyle,
            });
            break;
        }
        case "integer":
        case "numeric":
        case "number": {
            fieldController = new NumberField({
                ...props,
                format: type === "integer" ? type : props.format,
                value: currentValue,
                key,
                style,
                inputStyle,
            });
            break;
        }
        case "boolean":
        case "logical":
        case "checkbox": {
            fieldController = new CheckboxField({
                ...props,
                value: currentValue,
                key,
                style,
                inputStyle,
            });
            break;
        }
        case "date":
        case "dateTime":
        case "dateTimeFull":
        case "time":
        case "timeFull":
        case "month": {
            fieldController = new DateField({
                ...props,
                type,
                value: currentValue,
                key,
                style,
                inputStyle,
            });
            break;
        }
        case "reference": {
            fieldController = new CardFileField({
                ...props,
                value: currentValue,
                key,
                style,
                canSearch: false,
                onChange: (value) => {
                    props.onChange?.(value);
                    props.callback?.(value);
                },
                inputStyle,
            });
            break;
        }
        case "select": {
            fieldController = new SelectField({
                ...props,
                value: currentValue,
                key,
                style,
                inputStyle,
                searchable: props?.searchable ?? false,
            });
            break;
        }
        case "multi-select": {
            fieldController = new SelectField({
                ...props,
                value: currentValue,
                multiple: true,
                key,
                style,
                inputStyle,
            });
            break;
        }
        case "textarea": {
            fieldController = new TextAreaField({
                ...props,
                value: currentValue,
                key,
                style,
                inputStyle,
            });
            break;
        }
        case "files-upload": {
            fieldController = new FilesUploadField({
                ...props,
                onSaveFile: props.onSaveFile ?? props.uploadFileRequest,
                value: currentValue,
                key,
                style,
                inputStyle,
            });
            break;
        }
        case "period":
        case "date-period": {
            fieldController = new PeriodField({
                ...props,
                value: currentValue,
                key,
                style,
                inputStyle,
            });
            break;
        }
        case "email": {
            fieldController = new EmailField({
                ...props,
                value: currentValue,
                key,
                style,
                inputStyle,
            });
            break;
        }
        case "phone":
        case "tel": {
            fieldController = new PhoneField({
                ...props,
                value: currentValue,
                key,
                style,
                inputStyle,
            });
            break;
        }
        default: {
            const cardFile = props.reference || props.cardFile;
            if (cardFile) {
                fieldController = new CardFileField({
                    ...props,
                    value: currentValue,
                    path: cardFile?.settings?.recordDescription || props.path,
                    cardFile,
                    key,
                    style,
                    onChange: (value) => {
                        props.onChange?.(value);
                        props.callback?.(value);
                    },
                    inputStyle,
                });
            } else {
                fieldController = new DefaultField({
                    ...props,
                    value: currentValue,
                    key,
                    style,
                    inputStyle,
                });
                // console.warn("There is no type: " + type);
            }
        }
    }

    return fieldController;
};
/**
 *
 * @param {Field.properties} props
 * @returns {HTMLElement & Field.methods}
 */
const Field = (props) => {
    const { type } = props;
    const externalField = Field.externalTypes[type];
    if (externalField) {
        return externalField(props);
    }

    const fieldController = FieldController(props);

    const element = externalField ?? fieldController.render();
    if (element == null) return element;

    element.input = () => fieldController.inputElement;
    element.getKey = () => fieldController.getKey();
    element.getValue = () => fieldController.getValue();
    element.setValue = (v) => fieldController.setValue(v);
    element.setDisabled = (d) => fieldController.setDisabled(d);
    element.setPlaceholder =
        fieldController.setPlaceholder.bind(fieldController);
    element.getData = () => fieldController.getData?.();
    element.setCardFile = (cardFile) => fieldController.setCardFile?.(cardFile);
    element.setFilter = (filter) => fieldController.setFilter?.(filter);
    element.setConstFilter = (cf) => fieldController.setConstFilter?.(cf);
    element.setReference = ({
        reference,
        cardFile,
        placeHolder,
        placeholder,
    } = {}) => {
        fieldController.setCardFile?.(reference || cardFile);
        fieldController.setPlaceholder?.(placeHolder || placeholder);
    };
    element.setPeriodType = (periodType) =>
        fieldController.setPeriodType?.(periodType);
    element.setReadOnly = (readOnly) => fieldController.setReadOnly(readOnly);

    return element;
};

Field.externalTypes = {};
Field.addExternalType = (type, createFunc) => {
    if (type in Field.externalTypes)
        return console.warn(`Type ${type} already exists. Not added`);
    Field.externalTypes[type] = createFunc;
};

const Loader = () => {
    let loaderElement;

    let loader = {
        show: () => {
            if (loaderElement) loaderElement.remove();
            loaderElement = html`<img
                class="loader-image"
                src="assets/image/logo-preloader.svg"
            />`;
            loaderElement.addEventListener("load", () =>
                loaderElement.classList.add("is-active"),
            );
            document.body.append(loaderElement);
        },
        hide: () => {
            loaderElement.addEventListener(
                "transitionend",
                loaderElement.remove,
                false,
            );
            loaderElement.classList.remove("is-active");
        },
    };
    return loader;
};

const TabView = (props = {}) => {
    let titles = o([]);
    let contents = o([]);

    let activeContent = o();

    let tabs = o([]);
    const {
        tabTitlesListClassNames,
        tabTitlesClassName,
        class: className,
    } = props;

    const tabView = html`
        <div class="tab-view ${className ?? ""}">
            <div
                class="tab-titles${tabTitlesListClassNames?.length > 0
                    ? ` ${tabTitlesListClassNames.join(" ")}`
                    : tabTitlesClassName ?? ""}"
            >
                ${map(titles, (title) => title)}
            </div>
            <div class="tab-contents">${activeContent}</div>
        </div>
    `;

    let activeTab = null;

    tabView.addTab = (title, content, { class: className } = {}) => {
        const tabContentClassNames = mergeClasses("tab-content", className);
        let tabTitle = html`<div class="tab-title" title=${title}>
            ${title}
        </div>`;
        let tabContent = html`<div class=${tabContentClassNames}>
            ${content}
        </div>`;

        let tab = {
            title: tabTitle,
            content: tabContent,
            id: contents().length,
        };

        tabTitle.addEventListener("click", () => {
            if (props.handleTabClick) {
                props.handleTabClick(tab);
            } else {
                tabView.activate(tab);
            }
        });

        tab.isActive = (reload = false) => {
            tabView.activate(tab, reload);
        };

        tab.hide = () => {
            tabTitle.style.display = "none";
            tabTitle.classList.remove("is-active");
            activeContent(null);
        };

        tab.show = () => {
            tabTitle.style.display = "inline-block";
        };

        let titlesArr = titles();
        let contentsArr = contents();
        let tabsArr = tabs();

        titlesArr.push(tabTitle);
        titles(titlesArr);

        contentsArr.push(tabContent);
        contents(contentsArr);

        tabsArr.push(tab);
        tabs(tabsArr);
        return tab;
    };

    tabView.activate = (tab, reload = false) => {
        if (activeTab) {
            activeTab.title.classList.remove("is-active");
        }
        activeTab = tab;
        activeTab.title.classList.add("is-active");
        if (reload) activeContent("");
        activeContent(activeTab.content);
    };

    tabView.getTab = (index) => {
        let list = tabs();
        return list[index];
    };

    tabView.removeTab = (index) => {
        let list = tabs();
        list.splice(index, 1);
        tabs(list);
    };

    tabView.hideTab = (index) => {
        let list = tabs();
        list[index].hide();
    };

    tabView.showTab = (index) => {
        let list = tabs();
        list[index].show();
    };

    tabView.getTabs = tabs;

    tabView.clearTabs = () => tabs([]);

    return tabView;
};

function Table$1(props) {
    const { savedSettingsKey = "" } = props ?? {};

    const [settingsStorageType, settingsKey] = savedSettingsKey.split("/");
    const settingsManager =
        settingsStorageType === "cardFile"
            ? cardFileColumnsSettingsManager
            : null;

    if (settingsManager != null) {
        props = applySavedColumnsSettings(props);
        props.onColumnResized = () => handleColumnsSettingsChanged();
        props.onColumnMoved = () => handleColumnsSettingsChanged();
    }

    const table = Table$2(props);
    let tableProps = props;
    let hideHeaderMenu = props.hideHeaderMenu;

    const handleColumnsSettingsChanged = debounce$1(() => {
        if (!settingsManager) return;
        const hiddenColumns = table.getHiddenColumns();

        const columnsSettings = table
            .getColumns()
            .reduce((result, col, columnOrder) => {
                const hiddenColumn = hiddenColumns.find(
                    (hc) => hc.data.index === col.index
                );
                result[col.index] = {
                    hidden: hiddenColumn != null,
                    width: col.width() || hiddenColumn?.width,
                    columnOrder,
                };
                return result;
            }, {});
        settingsManager.save({ key: settingsKey, settings: columnsSettings });
    }, 1000);

    table.menu = Menu();
    table.menu.classList.add("table-menu");

    let onClickAway;

    table.menu.addEventListener("onHide", (event) => {
        event.stopPropagation();

        document.body.removeChild(table.menu);
        document.removeEventListener("click", onClickAway);
    });

    table.menu.addEventListener("onShow", (event) => {
        event.stopPropagation();

        document.body.append(table.menu);

        table.menu.clearItems();

        onClickAway = table.menu.hide;

        document.addEventListener("click", onClickAway);

        let hiddenColumns = table.getHiddenColumns();
        let hidden_count = hiddenColumns.length;
        if (hidden_count < table.getColumns().length - 1)
            table.menu
                .itemCreateAndPush({ value: html`<span>Скрыть столбец</span>` })
                .getElement()
                .addEventListener("click", () =>
                    table.hideColumn(table.menu.currentColumn)
                );

        const { headerMenuItems = [] } = props;

        if (headerMenuItems.length > 0) {
            headerMenuItems.forEach((item) =>
                table.menu.itemCreateAndPush({ value: item })
            );
        }

        if (hidden_count === 0) return;

        let item = table.menu.itemCreateAndPush({
            value: html`<span>Показать столбец</span>`,
            menu: Menu(),
        });

        let menu = item.getMenu();

        for (let i = 0; i < hiddenColumns.length; i++) {
            let hiddenColumn = hiddenColumns[i];

            menu.itemCreateAndPush({ value: hiddenColumn.title })
                .getElement()
                .addEventListener("click", (event) => {
                    event.stopPropagation();

                    table.showColumn(hiddenColumn);

                    table.menu.hide();
                });
        }

        item.getElement().addEventListener("click", (event) => {
            event.stopPropagation();

            const hiddenColumns = table.getHiddenColumns();
            for (let i = hiddenColumns.length - 1; i >= 0; i--)
                table.showColumn(hiddenColumns[i]);

            table.menu.hide();
        });
    });

    const column_props = props.column_props;
    const { onSort, sortConfig } = props;
    const sortTable = sortTableWith(sortConfig)(table);

    let lastOrdered = undefined;
    let prevHidden = [];

    for (let i = 0; i < column_props.length; i++) {
        let arrow = html`<div class="order-arrow"></div>`;
        let backButtonImage = html`<div class="back-button"></div>`;

        let props = { ...column_props[i] }; // TODO: do this
        let backButton = html`<div
            class="header-content"
            style=${props.style}
            title=${props.text}
        >
            ${backButtonImage}
        </div>`;
        const sortable =
            tableProps.setOrder || (sortConfig && props.id in sortConfig);
        if (props.id == "IsGroup") {
            props.value = backButton;
        } else {
            props.value =
                props.value ??
                html`<div
                    class="header-content"
                    style=${props.style}
                    title=${props?.title ?? props.text}
                >
                    ${sortable ? arrow : null}
                    <span
                        class="header-content-text${props.noWrap
                            ? " --no-wrap"
                            : ""}"
                    >
                        ${props.text}
                    </span>
                </div>`;
        }

        table.backButton = backButton;

        let column = table.columnCreateAndPush(props);
        if (props.isHidden) prevHidden.push(column);
        if (props?.headStyle)
            Object.entries(props.headStyle).forEach(([prop, value]) => {
                column.element?.()?.style.setProperty(prop, value);
            });

        column.index = props.id;
        column.order = o(props?.initOrder ?? 0);
        column.getOrder = column.order;
        column.setOrder = column.order;

        column.order_query = props.order;

        let column_order_unsubscribe = on(column.order, () => {
            if (!column || !arrow) {
                column_order_unsubscribe();
                return;
            }

            arrow.classList.remove("is-up");
            arrow.classList.remove("is-down");

            switch (column.order()) {
                case 1:
                    arrow.classList.add("is-up");
                    break;
                case 2:
                    arrow.classList.add("is-down");
                    break;
            }
        });

        column.getArrow = () => arrow;

        if (!hideHeaderMenu) {
            column.getElement().addEventListener("contextmenu", (event) => {
                event.preventDefault();

                table.menu.currentColumn = column;
                table.menu.setPos(event.pageX, event.pageY);
                table.menu.show();
            });
        }

        if (column.index === "IsGroup") {
            column
                .getValue()
                .addEventListener("click", tableProps.backButtonAction, false);
        } else {
            if (!sortable) continue;
            column.getValue().addEventListener("click", (event) => {
                if (event.target === column.getDivider()) return;

                if (lastOrdered && lastOrdered !== column) lastOrdered.order(0);

                let order_state = column.order();
                order_state = order_state == 2 ? 0 : order_state + 1;
                column.order(order_state);

                lastOrdered = column;

                let order_query = column.order_query;
                switch (order_state) {
                    case 0:
                        order_query = "";
                        break;
                    case 1:
                        order_query += "+";
                        break;
                    case 2:
                        order_query += "-";
                        break;
                }
                if (typeof tableProps?.setOrder === "function") {
                    tableProps.setOrder(order_query);
                } else if (sortConfig) {
                    sortTable(column);
                }
                if (typeof onSort === "function") {
                    onSort(column);
                }
            });
        }
    }

    table.hiddenColumns = [];

    table.getHiddenColumns = () => table.hiddenColumns;
    table.setHiddenColumns = (columns) => (table.hiddenColumns = columns);

    table.hideColumn = (column) => {
        if (table.getHiddenColumn()) return;

        const column_element = column?.getElement();

        column.__setWidth = column.__setWidth || column.setWidth;
        column.setWidth = (width) => {
            let hidden = table.getHiddenColumn(column);
            if (!hidden) return column.__setWidth(width);
            hidden.width = width;
        };

        table.hiddenColumns[table.hiddenColumns.length] = {
            title: column_element?.textContent || "Без наименования",
            width: column?.getWidth(),
            data: column,
        };

        column?.__setWidth(0);
        column_element?.classList.add("is-hidden");

        let index = column?.getIndex();
        if (index !== null && index !== undefined && index !== -1) {
            let rows = table.getRows();
            for (let i = 0; i < rows.length; i++)
                rows[i]
                    ?.getCell(index)
                    ?.getElement()
                    ?.classList.add("is-hidden");
        }
        handleColumnsSettingsChanged();
    };
    table.getHiddenColumn = (column) => {
        let hiddenColumns = table.getHiddenColumns();
        for (let i = 0; i < hiddenColumns.length; i++) {
            let hiddenColumn = hiddenColumns[i];
            if (hiddenColumn?.data === column) return hiddenColumn;
        }
    };
    table.getHiddenColumnByKey = (key) => {
        return table.getHiddenColumns().find(hc => hc.data.index === key);
    };
    table.showColumn = (hiddenColumn) => {
        if (!hiddenColumn) return;

        let column = hiddenColumn.data;

        table.hiddenColumns.splice(
            table.hiddenColumns.indexOf(hiddenColumn),
            1
        );

        column?.setWidth(hiddenColumn.width);
        column?.getElement()?.classList.remove("is-hidden");

        let index = column?.getIndex();
        if (index !== null && index !== undefined && index !== -1) {
            let rows = table.getRows();
            for (let i = 0; i < rows.length; i++)
                rows[i]
                    ?.getCell(index)
                    ?.getElement()
                    ?.classList.remove("is-hidden");
        }
        handleColumnsSettingsChanged();
    };

    prevHidden.forEach((column) => table.hideColumn(column));

    function applySavedColumnsSettings(props) {
        const { column_props } = props;
        const savedColumnsSettingsList = settingsManager?.getByKey(settingsKey);
        if (!savedColumnsSettingsList) return props;
        column_props
            .sort((cp1, cp2) => {
                return (
                    savedColumnsSettingsList[cp1.id]?.columnOrder -
                    savedColumnsSettingsList[cp2.id]?.columnOrder
                );
            })
            .forEach((cp) => {
                const savedColumnSetting = savedColumnsSettingsList[cp.id];
                if (!savedColumnSetting) return;
                cp.fixWidth = savedColumnSetting.width;
                if (savedColumnSetting.width) delete cp.width;
                cp.isHidden = savedColumnSetting.hidden;
            });
        return props;
    }

    // observe(table);
    // table.addEventListener("disconnected", handleColumnsSettingsChanged);

    return table;
}

// import "./index.sass";

const Table = (props) => {
    let { groupHierarchy, column_props } = createGroupProps(
        props?.column_props,
        props?.groupHierarchy,
        props?.groupsStyles
    );
    props.column_props = column_props;

    let { disableContextMenu = false } = props ?? {};
    disableContextMenu = getObservable(disableContextMenu);

    const table = Table$1(props);

    table.columns_hash = undefined;
    let tableWidth = props?.tableWidth ? props.tableWidth : 50;

    /**
     *
     * @param {Group} group
     * @returns
     */
    const createGroup = (group) => {
        /**@type {HTMLElement} */
        const column = html`<th class="table-column group">
            <div
                class="header-content "
                title=${group.name}
                style=${group.style}
            >
                <span class="header-content-text ">${group.name}</span>
            </div>
        </th>`;

        column.style.gridColumn = `${group.startPos}/${
            group.startPos + group.width
        }`;
        column.style.gridRow = `${group.level}/${group.level + group.height}`;

        return column;
    };

    /**
     *
     * @param {HTMLElement} thead
     * @param {Group[]} groups
     */
    const addGroupRow = (thead, groups) => {
        const _groups = o(groups);
        const tr = thead.querySelector(".table-row-header:not(.groups)");
        const headRow = html`<tr class="table-row-header groups">
            ${map(_groups, (group) => createGroup(group))}
        </tr>`;

        thead.insertBefore(headRow, tr);
    };

    if (groupHierarchy && groupHierarchy.length > 0) {
        /**@type {HTMLElement} */
        const head = table.querySelector("thead");
        head.classList.add("have-groups");

        addGroupRow(head, groupHierarchy);
    }

    let resizeTable = (_) => {
        let windowWidth = (window.innerWidth / 100) * tableWidth - 20;

        let columnWidth = {};
        for (let i = 0; i < props.column_props.length; i++) {
            props.column_props[i].width
                ? (columnWidth[props.column_props[i].id] =
                      (windowWidth / 100) * props.column_props[i].width)
                : (columnWidth[props.column_props[i].id] =
                      props.column_props[i].fixWidth);
        }

        let columns = table.getColumns();

        let columns_hash = {};
        for (let i = 0; i < columns.length; i++)
            columns_hash[columns[i].index] = columns[i];

        for (let key in columnWidth)
            columns_hash[key].setWidth(columnWidth[key]);
    };

    window.addEventListener("resize", resizeTable, false);
    resizeTable();

    const updateRow = (row, _data, rowIdx) => {
        row.clearCells();

        let cells = [];

        let columns = table.getColumns();
        let columns_hash = {};
        for (let i = 0; i < columns.length; i++)
            columns_hash[columns[i].index] = i;
        table.columns_hash = columns_hash;

        const data = { ..._data };

        for (let i = 0; i < props.column_props.length; i++) {
            let element;
            props.column_props[i]?.required;
            let disabled = props.column_props[i]?.disabled;
            let placeHolder = props.column_props[i]?.placeHolder;
            let fieldEllipsis = props.column_props[i]?.fieldEllipsis;
            let onSelect = props.column_props[i]?.onSelect;
            let dependentKey = props.column_props[i]?.dependentKey;
            const {
                createCellColor,
                createFullCellColor,
                path,
                displayedValue,
                displayValue,
                searchKeys,
                onChange,
                onDoubleClick,
                isHierarchycal = true,
                createDependentFilter,
                id: key,
                width,
                tooltip,
                ...columnProps
            } = props.column_props[i] ?? {};

            const initialValue = data[key];
            const elementTooltip =
                typeof tooltip === "function"
                    ? tooltip({
                          data: data[props.column_props[i].id],
                          rowData: data,
                          key: props.column_props[i].id,
                      })
                    : undefined;

            if (columnProps.reference) {
                element = Field({
                    ...columnProps,
                    path: path || displayValue || displayedValue,
                    key: key,
                    value: initialValue,
                    onChange: ({ value: recordData }) => {
                        onSelect?.({
                            columnProps: props,
                            element,
                            data,
                            cells,
                            columns_hash,
                            recordData,
                            key,
                            row,
                        });
                        onChange?.({
                            tableProps: props,
                            element,
                            rowData: data,
                            value: recordData,
                            cells,
                            columns_hash,
                            key: props.column_props[i].id,
                            row,
                            data: recordData,
                        });
                        data[key] = recordData;
                    },
                    style: columnProps.styleCell,
                    placeholder: placeHolder,
                    searchKeys,
                    cellField: true,
                    isHierarchycal,
                    tooltip: elementTooltip,
                });
                if (dependentKey && createDependentFilter) {
                    const dependentData = data[dependentKey];
                    element.setConstFilter(
                        createDependentFilter({
                            key,
                            dependentKey,
                            value: initialValue,
                            dependentData,
                        })
                    );
                }
            } else if (columnProps.refs) {
                const dependentDocid = data[dependentKey]?.docid;
                const reference = columnProps.refs[dependentDocid];

                element = Field({
                    ...columnProps,
                    key,
                    path: path || displayedValue || displayValue,
                    value: initialValue,
                    onChange: ({ value: recordData }) => {
                        onSelect?.({
                            columnProps: props,
                            element,
                            data,
                            cells,
                            columns_hash,
                            recordData,
                            key: props.column_props[i].id,
                            row,
                        });
                        onChange?.({
                            tableProps: props,
                            element,
                            rowData: data,
                            value: recordData,
                            cells,
                            columns_hash,
                            key: props.column_props[i].id,
                            row,
                        });
                        data[key] = recordData;
                    },
                    style: columnProps.styleCell,
                    placeholder: placeHolder,
                    searchKeys,
                    cellField: true,
                    isHierarchycal,
                    reference: columnProps?.reference ?? reference ?? true,
                    tooltip: elementTooltip,
                });
                if (dependentDocid) {
                    element.setFilter(
                        columnProps.filters
                            ? columnProps.filters[dependentDocid]
                            : ""
                    );
                }
            } else if (fieldEllipsis) {
                const value = o(initialValue);
                element = html`<label
                    class="field-v2 field-v2--cell"
                    data-key=${key}
                    style=${columnProps.styleCell}
                    title=${elementTooltip ?? value}
                >
                    <!-- prettier-ignore-attribute -->
                    <input
                        class="field-v2-input"
                        type="text"
                        readOnly
                        value=${value}
                    />
                    <${Button} class="transparent field-button">
                        <${Icon}
                            name="ellipsis"
                            style="color: var(--color-main); cursor: pointer;"
                            onmousedown=${(ev) => ev.preventDefault()}
                        />
                    <//>
                </label>`;
                element.setValue = (v) => {
                    value(v);
                    data[key] = value();
                    onChange?.({
                        value: value(),
                        data: value(),
                        key,
                        columnProps: column_props,
                        element,
                        rowData: data,
                        cells,
                        columns_hash,
                        row,
                    });
                };
                element.getValue = () => value();
            } else if (columnProps.type) {
                const type = columnProps.type;
                const dataType = columnProps.dataType;
                const handleOnChange = ({ key, value }) => {
                    data[key] = value;
                    onChange?.({
                        value,
                        data: value,
                        key,
                        columnsProps: column_props,
                        element,
                        rowData: data,
                        cells,
                        columns_hash,
                        row,
                    });
                };
                switch (type) {
                    case "input": {
                        element = Field({
                            ...columnProps,
                            disabled,
                            value: initialValue,
                            placeholder: placeHolder,
                            key,
                            classNames: [
                                !fieldEllipsis ? "" : "field-ellipsis",
                            ],
                            cellField: true,
                            type: dataType === "number" ? "number" : "text",
                            onChange: handleOnChange,
                            style: columnProps.styleCell,
                            tooltip: elementTooltip,
                        });
                        break;
                    }
                    default: {
                        element = Field({
                            ...columnProps,
                            disabled,
                            value: initialValue,
                            type,
                            cellField: true,
                            key,
                            classNames: [
                                !fieldEllipsis ? "" : "field-ellipsis",
                            ],
                            onChange: handleOnChange,
                            style: columnProps.styleCell,
                            tooltip: tooltip,
                        });
                    }
                }
            } else if (props.column_props[i].changeValue) {
                const elementValue = o(
                    props.column_props[i].changeValue(
                        data[props.column_props[i].id],
                        data,
                        rowIdx,
                        {
                            cells,
                            columns_hash,
                        },
                        props.column_props[i].id
                    )
                );
                const tooltip =
                    elementTooltip ?? data[props.column_props[i].id];
                element = html`<div
                    style=${props.column_props[i].styleCell}
                    title=${tooltip}
                >
                    ${elementValue}
                </div>`;
                element.getValue = () => data[props.column_props[i].id];
                element.setValue = (value) => {
                    data[props.column_props[i].id] = value;

                    elementValue(
                        props.column_props[i].changeValue(
                            value,
                            data,
                            rowIdx,
                            {
                                cells,
                                columns_hash,
                            },
                            props.column_props[i].id
                        )
                    );
                };
            } else {
                element = html`<div
                    style=${props.column_props[i].styleCell}
                    title=${elementTooltip ?? data[props.column_props[i].id]}
                >
                    ${data[props.column_props[i].id]}
                </div>`;
                element.getValue = (_) => element.innerText;
                element.setValue = (value) => (element.innerText = value);
            }
            /**
             * @type {HTMLTableCellElement}
             */
            const cell = html`<td>${element}</td>`;

            // check if full cell need to set color by custom condition
            if (typeof createFullCellColor === "function") {
                const color = createFullCellColor({
                    id: props.column_props[i].id,
                    data: data[props.column_props[i].id],
                    rowData: data,
                    rowIndex: rowIdx,
                });
                if (typeof color === "string" && color.length > 0) {
                    cell.style.backgroundColor = color;
                }
            }

            // check if cell content need to set color by custom condition
            if (typeof createCellColor === "function") {
                const color = createCellColor({
                    id: props.column_props[i].id,
                    data: data[props.column_props[i].id],
                    rowData: data,
                    rowIndex: rowIdx,
                });
                if (typeof color === "string" && color.length > 0) {
                    element.style.backgroundColor = color;
                }
            }
            onDoubleClick &&
                cell.addEventListener("dblclick", (event) => {
                    const key = props.column_props[i].id;
                    onDoubleClick({
                        event,
                        element,
                        key,
                        rowData: data,
                        row,
                        columnProps: column_props,
                        cells,
                        columns_hash,
                    });
                });
            if (
                props.column_props[i].callback ||
                props.column_props[i].onCellClick
            ) {
                cell.addEventListener("click", (ev) => {
                    props.column_props[i].callback?.({
                        data,
                        cells,
                        columns_hash,
                        id: props.column_props[i].id,
                        event: ev,
                    });
                    props.column_props[i].onCellClick?.({
                        data,
                        cells,
                        columns_hash,
                        id: props.column_props[i].id,
                        event: ev,
                    });
                });
            }

            if (typeof element.getKey !== "function") {
                element.getKey = () => key;
            }
            cells[columns_hash[props.column_props[i].id]] = {
                value: element,
                element: cell,
                columnKey: key,
            };
        }

        row.cellsCreateAndPush(cells);
        //TODO: remove getData(rewrite filterTable)
        row.getData = () => data;

        let row_cells = row.getCells();
        for (let i = 0; i < row_cells.length; i++) {
            let column = columns[i];
            let cell = row_cells[i];

            if (!table.getHiddenColumn(column)) continue;

            cell?.getElement()?.classList.add("is-hidden");
        }
    };

    // ! TEST MENU ON TABLE ROW +
    table.menu_row = Menu();
    table.menu_row.classList.add("table-menu");
    table.menu_row.style.zIndex = 999;

    let onClickAway;

    table.menu_row.addEventListener("onHide", (event) => {
        event.stopPropagation();

        table.menu_row.remove();
    });

    //TODO: remove this method, when override filter table
    table.createRowMenuItems = () => {
        let duplicateRow = table.menu_row.itemCreateAndPush({
            value: html`<span style="display: flex; align-items: center;">
                <div class="duplicate-icon"></div>
                Дублировать
            </span>`,
        });

        duplicateRow.getElement().addEventListener("click", (_) => {
            if (props?.rowMenu?.duplicate) {
                props.rowMenu.duplicate(table.menu_row.currentRow);
            } else {
                table.createRows([table.menu_row.currentRow.nodeData]);
            }
            if (props?.onDuplicate) {
                props?.onDuplicate(table);
            }
            table.menu_row.hide();
        });

        let removeRow = table.menu_row.itemCreateAndPush({
            value: html`<span style="display: flex; align-items: center;">
                <div class="trash-icon"></div>
                Удалить строку
            </span>`,
        });

        removeRow.getElement().addEventListener("click", (_) => {
            if (props?.rowMenu?.remove) {
                props.rowMenu.remove(table.menu_row.currentRow);
            } else {
                table.rowRemoveByValue(table.menu_row.currentRow.row);
            }
            if (props?.onRemove) {
                props?.onRemove(table);
            }
            table.menu_row.hide();
        });

        let moveUpRow = table.menu_row.itemCreateAndPush({
            value: html`<span style="display: flex; align-items: center;">
                <div class="row-up-icon"></div>
                Поднять строку
            </span>`,
        });

        moveUpRow.getElement().addEventListener("click", (_) => {
            if (props?.rowMenu?.moveUp) {
                return props.rowMenu.moveUp(table.menu_row.currentRow);
            }
            let prevElement =
                table.menu_row.currentRow.row.element().previousElementSibling;
            let currentRow = table.menu_row.currentRow.row.element();
            if (prevElement) {
                table
                    .querySelector("tbody")
                    .insertBefore(currentRow, prevElement);
                let rows = table.getRows();
                for (let i = 0; i < rows.length; i++) {
                    if (rows[i].element() == currentRow) {
                        let curRow = rows.splice(i, 1)[0];
                        rows.splice(i - 1, 0, curRow);
                    }
                }
            }
            if (props?.onMoveUpRow) {
                props?.onMoveUpRow(table);
            }
        });

        let moveDownRow = table.menu_row.itemCreateAndPush({
            value: html`<span style="display: flex; align-items: center;">
                <div class="row-down-icon"></div>
                Опустить строку
            </span>`,
        });

        moveDownRow.getElement().addEventListener("click", (_) => {
            if (props?.rowMenu?.moveDown) {
                return props.rowMenu.moveDown(table.menu_row.currentRow);
            }

            let nextElement =
                table.menu_row.currentRow.row.element().nextElementSibling;
            let currentRow = table.menu_row.currentRow.row.element();
            if (nextElement) {
                table
                    .querySelector("tbody")
                    .insertBefore(nextElement, currentRow);
                let rows = table.getRows();
                for (let i = 0; i < rows.length; i++) {
                    if (rows[i].element() == currentRow) {
                        let curRow = rows.splice(i, 1)[0];
                        rows.splice(i + 1, 0, curRow);
                    }
                }
            }
            if (props?.onMoveDownRow) {
                props?.onMoveDownRow(table);
            }
        });
    };

    table.menu_row.addEventListener("onShow", (event) => {
        event.stopPropagation();

        document.body.append(table.menu_row);

        table.menu_row.clearItems();

        onClickAway = table.menu_row.hide;

        document.addEventListener("click", onClickAway, { once: true });

        table.createRowMenuItems();
    });
    // ! TEST MENU ON TABLE ROW -

    const addMenuToRow = ({ row, nodeData }) => {
        if (!table.menu_row) return;

        row.getElement().addEventListener("contextmenu", (event) => {
            event.preventDefault();

            table.menu_row.currentRow = { row, nodeData };
            table.menu_row.setPos(event.pageX, event.pageY);
            table.menu_row.show();
        });
    };

    table.createRows = (props, is_unshift, scroll) => {
        let count = 0;
        for (let _ in props) count++;
        let hack = new Array(count);

        const columns_hidden = [];
        const columns = table.getColumns();

        for (let i = 0; i < columns.length; i++)
            columns_hidden[i] = !!table.getHiddenColumn(columns[i]);

        const rowCount = table.getRows().length;

        const datas = is_unshift
            ? table.rowsCreateAndUnshift(hack)
            : table.rowsCreateAndPush(hack);
        for (var i = 0; i < datas.length; i++) {
            const row = datas[i];

            table.updateRow(
                row,
                props[i],
                rowCount === 0 || is_unshift ? i : rowCount + i
            );

            let nodeData = props[i];

            if (!disableContextMenu()) {
                table.addMenuToRow({ row, nodeData });
            }
            let row_cells = row.getCells();
            for (let i = 0; i < row_cells.length; i++) {
                if (columns_hidden[i])
                    row_cells[i]?.getElement()?.classList.add("is-hidden");
            }
        }

        // if(scroll) {
        //     if(is_unshift) { view.deleteTickets(datas.length, false); } else { view.deleteTickets(datas.length, true); };  // delete after creations
        // };

        return datas;
    };

    table.createEmptyRow = (defaultValues = {}) => {
        const emptyRow = props.column_props.reduce((row, colProp) => {
            if (colProp.id in defaultValues)
                return { ...row, [colProp.id]: defaultValues[colProp.id] };
            if (colProp.reference || colProp.refs)
                return { ...row, [colProp.id]: {} };
            if (colProp.type != null) {
                if (
                    colProp.dataType === "string" ||
                    colProp.type === "reference" ||
                    colProp.type === "date"
                )
                    return { ...row, [colProp.id]: "" };
                if (colProp.dataType === "number")
                    return { ...row, [colProp.id]: 0 };
            }
            return { ...row, [colProp.id]: "" };
        }, {});
        table.createRows([emptyRow]);
    };

    table.getColumnsHash = (_) => table.columns_hash;

    table.getData = ({ full = false } = {}) => {
        let data = [];
        let rows = table.getRows();
        rows.forEach((row) => {
            let cells = row.getCells();
            let dataElement = {};
            cells.forEach((cell) => {
                let element = cell.getValue();
                if (!full) {
                    dataElement[element.getKey()] = element.getValue();
                } else {
                    const value = element.getData?.() ?? element.getValue();
                    dataElement[element.getKey()] = value;
                }
            });
            data.push(dataElement);
        });
        return data;
    };

    table.updateRow = updateRow;
    table.addMenuToRow = addMenuToRow;

    return table;
};

/**
 *
 *
 * @class Group
 * @constructor
 * @public
 */
class Group {
    /**
     * Creates an instance of Group.
     * @param {GroupHierarchyItem & { parent?: Group|undefined }} props
     * @memberof Group
     */
    constructor({ name, children = [], style = "", parent = undefined }) {
        /**
         * @type {string}
         * @public
         */
        this.name = name;

        /**
         * @type {Group[]}
         * @public
         */
        this.children = children.map(
            (child) => new Group({ ...child, parent: this })
        );

        /**
         * @type {number}
         * @private
         */
        this._width = 0;

        /**
         * @type {number}
         * @public
         */
        this.height = 0;

        /**
         * @type {number}
         * @public
         */
        this.depth = 0;

        /**
         * @type {Group | undefined}
         * @public
         */
        this.parent = parent;

        /**
         * @type {number}
         * @private
         */
        this._startPos = Infinity; //

        this.lvl = 0;

        this.style = style;

        this.setGroupDepth();
        this.setMinWidth();
    }

    /**
     *
     *
     * @return {undefined}
     * @memberof Group
     * @private
     */
    setGroupDepth() {
        if (!this?.children) return;
        this.depth =
            this.children
                .map((child) => child.depth)
                .reduce((max, value) => Math.max(max, value), -1) + 1;
    }

    /**
     *
     *
     * @return {undefined}
     * @memberof Group
     * @private
     */
    setMinWidth() {
        if (this.children.length === 0) this._width = 1;
        else
            this._width = this.children.reduce((sum, g) => {
                return sum + g.width;
            }, 0);
    }

    /**
     *
     *
     * @readonly
     * @memberof Group
     * @returns {Group[]}
     */
    get descendants() {
        if (this.children.length === 0) return [];
        return [
            ...this.children,
            ...this.children.map((group) => group.descendants),
        ]
            .flat()
            .filter((descendant) => descendant);
    }

    /**
     *
     *
     * @readonly
     * @memberof Group
     */
    get siblings() {
        return this.parent && this.parent.children
            ? this.parent.children.filter((group) => group.name !== this.name)
            : [];
    }

    /**
     *
     *
     * @memberof Group
     * @type {number}
     */
    set width(value) {
        const diff = value - this._width;
        this._width = value;
        if (!this.parent) return;

        this.parent.width += diff;
    }

    /**
     *
     *
     * @memberof Group
     */
    get width() {
        return this._width;
    }

    /**
     *
     * @memberof Group
     */
    set startPos(value) {
        this._startPos = Math.min(this._startPos, value);
        if (this.parent) this.parent.startPos = value;
    }

    get startPos() {
        return this._startPos;
    }

    get level() {
        if (this.lvl > 0) return this.lvl;
        let lvl = 1;
        let parent = this.parent;
        while (parent) {
            lvl++;
            if (parent.height > 1) lvl += parent.height - 1;
            parent = parent.parent;
        }
        this.lvl = lvl;

        return lvl;
    }

    /**
     *
     *
     * @static
     * @param {Group} g1
     * @param {Group} g2
     * @memberof Group
     */
    static compareByPosition = (g1, g2) => g1.startPos - g2.startPos;

    /**
     *
     *
     * @static
     * @param {Group} g1
     * @param {Group} g2
     * @memberof Group
     */
    static compareByDepth = (g1, g2) => g1.depth - g2.depth;

    /**
     *
     *
     * @static
     * @param {Group} g1
     * @param {Group} g2
     * @memberof Group
     */
    static compareByLevel = (g1, g2) => g1.level - g2.level;
}

/**@typedef {{name: string, children?:[GroupHierarchyItem]}} GroupHierarchyItem*/

/**
 *
 * @param {[*]?} columnProps
 * @param {[GroupHierarchyItem]?} groupHierarchy
 * @param {*} groupsStyles
 * @returns
 */
function createGroupProps(
    columnProps = [],
    groupHierarchy = [],
    groupsStyles = {}
) {
    const propsWithGroups = columnProps.filter((column) =>
        Object.keys(column).includes("group")
    );

    if (propsWithGroups.length === 0 && groupHierarchy.length === 0)
        return { column_props: columnProps };

    if (groupHierarchy.length === 0) {
        groupHierarchy = [
            ...propsWithGroups
                .map((props) => props.group)
                .filter((gname, idx, arr) => {
                    return arr.indexOf(gname) === idx;
                })
                .map((name) => ({ name })),
        ];
    }

    /**@type {[Group]} */
    let allGroups = [];

    for (const _group of groupHierarchy) {
        const group = new Group(_group);
        allGroups.push(group, ...group.descendants);
    }

    const maxDepth = allGroups.reduce(
        (max, group) => Math.max(max, group.depth),
        0
    );

    allGroups.forEach((group) => {
        let columnsInGroup = propsWithGroups.filter(
            (column) => column.group === group.name
        );

        if (columnsInGroup.length === 0) {
            group.height = 1;
            return;
        }

        // get width by contents of groups
        group.width =
            group.children.length === 0
                ? columnsInGroup.length
                : group.width + columnsInGroup.length;

        // set start pos in table
        columnProps.forEach((props, index) => {
            if (columnsInGroup.includes(props))
                group.startPos = Math.min(index + 1, group.startPos);
        });

        // set height
        if (group.children.length !== 0) {
            group.height += group.depth + 1;
        } else if (!group.parent) group.height += maxDepth + 1;
        else if (group.siblings.length !== 0) {
            let maxSiblingDepth = group.siblings.reduce(
                (max, g) => Math.max(max, g.depth + 1),
                0
            );
            group.height += maxSiblingDepth;
        } else {
            group.height += 1;
        }
    });

    const maxLevel = allGroups
        .map((g) => g.level)
        .reduce((max, level) => Math.max(max, level), 0);

    // set columns styles
    const columnStyleWithoutGroup = {
        height: "100%",
        "grid-row": `1/${maxLevel + 2}`,
    };

    columnProps
        .filter((props) => !propsWithGroups.includes(props))
        .forEach((props) => (props.headStyle = columnStyleWithoutGroup));

    allGroups.forEach((group) => {
        const columnsInGroup = propsWithGroups.filter(
            (column) => column.group === group.name
        );
        columnsInGroup.forEach((columnProps) => {
            const minLevel = group.descendants.reduce(
                (min, g) => Math.min(min, g.level),
                Infinity
            );

            if (Math.abs(minLevel - group.level) > 1 && isFinite(minLevel)) {
                const columnHeadStyle = {
                    height: "100%",
                    "grid-row": `${group.height + group.level}/${maxLevel + 2}`,
                };
                columnProps.headStyle = columnHeadStyle;
            }
        });
    });

    allGroups.sort(Group.compareByPosition).sort(Group.compareByLevel);

    const paramKeys = Object.keys(groupsStyles);
    if (groupsStyles.style)
        allGroups.forEach((g) => (g.style += groupsStyles.style));
    if (paramKeys.length >= 1) {
        paramKeys.forEach((groupName) => {
            const group = allGroups.filter((group) => group.name === groupName);
            if (group.length === 1) group[0].style = groupsStyles[groupName];
        });
    }

    return {
        column_props: columnProps,
        groupHierarchy: allGroups,
    };
}

const validator = (rules) => (data) => {
    const errors = {};
    Object.keys(rules).forEach((fieldKey) => {
        const fieldRules = rules[fieldKey];
        if (Array.isArray(fieldRules)) {
            for (const { verify, message } of fieldRules) {
                if (verify(data[fieldKey], data)) {
                    errors[fieldKey] = message ?? "Not valid " + fieldKey;
                    break;
                }
            }
        } else {
            const { verify, message } = fieldRules;
            if (verify(data[fieldKey], data)) {
                errors[fieldKey] = message ?? "Not valid " + fieldKey;
            }
        }
    });

    return Object.keys(errors).length > 0 ? errors : null;
};

const HelpLink = (props) => {
    const {
        projectId,
        sourceId,
        size = 28,
        tooltip,
        class: className,
        href = projectId
            ? `https://project.integer.ru/#cardfile/openTickets?projectId=${projectId}${
                  sourceId ? "&sourceId=" + sourceId : ""
              }`
            : undefined,
        routerIgnore,
        target = "_blank",
        ...rest
    } = props ?? {};
    // if (!projectId) return null;
    return html`<a
        ...${rest}
        class="help-link ${className ?? ""}"
        href=${href}
        style="--font-size: ${size}px;${rest?.style ?? ""}"
        title=${tooltip ?? TITLE_TEXT}
        target=${target}
        data-ignore-router=${routerIgnore ? routerIgnore : null}
    >
        <${Icon} name="circle-question" />
    </a>`;
};

const TITLE_TEXT = "Кликните для размещения заявки в техподдержку";

observe(".blank");

const Blank = (props) => {
    const blankTables = {};
    const blankFields = {};

    let {
        data: {
            cardFile,
            applyButtonAction: onApply,
            cancelButtonAction: onCancel,
            userRights,
            ...initialData
        } = {},
        applyBtnText = "Ок",
        cancelBtnText = "Отмена",
        cancelButtonAction,
        applyButtonAction,
        docid,
        title,
        class: className,
        validationConfig = {},
        userRights: urParam,
    } = props ?? {};

    if (!cancelButtonAction && onCancel) {
        cancelButtonAction = onCancel;
    }

    if (!applyButtonAction && onApply) {
        applyButtonAction = onApply;
    }

    if (!userRights && urParam) {
        userRights = urParam;
    }

    const validate = validator(validationConfig ?? {});
    const errors = o();

    const blankData = o({
        docid: initialData?.docid ?? docid ?? "",
        groupDoc: initialData?.groupDoc ?? { docid: "" },
        isGroup: initialData?.IsGroup,
    });

    const blankActionsViewItems = o([]);
    const blankItems = o([]);
    const headerLeftItems = o([]);
    const headerRightItems = o([]);

    const blankCancelButton = Button({
        text: cancelBtnText,
        type: "button",
        class: "outline grey cancel-btn",
        title: "При нажатии, все введенные данные будут потеряны и окно редактирования будет закрыто",
        onClick: () => blank.cancelButtonAction(),
    });
    const blankApplyButton = Button({
        text: applyBtnText,
        class: "apply-btn",
        title: "При нажатии, все введенные данные будут сохранены и окно редактирования будет закрыто",
        onClick: (ev) => {
            ev.preventDefault();
            if (!blank.isValid()) return;
            blank.applyButtonAction();
        },
    });

    const blankActionsView = html`<div class="blank-actions-view">
        ${map(blankActionsViewItems, (item) => item)}
    </div>`;

    const blankView = html`<div class="blank-view">
        ${map(blankItems, (item) => item)}
    </div>`;

    const renderApplyButton = () => {
        if (!userRights || userRights().canEdit) return blankApplyButton;
    };

    const blankHeaderItems = html`<div class="blank-header">
        <h2>${title}</h2>
        <div class="blank-header-tools">
            <div class="blank-header-left">
                ${map(headerLeftItems, (item) => item)}
            </div>
            <div class="blank-header-right">
                ${map(headerRightItems, (item) => item)}
                ${props?.[HELP_KEYS.PROJECT]
                    ? html`<${HelpLink}
                          projectId=${props?.[HELP_KEYS.PROJECT]}
                      />`
                    : null}
                <div class="blank-buttons">
                    ${blankCancelButton}${renderApplyButton}
                </div>
            </div>
        </div>
    </div>`;

    /**@type {HTMLDivElement} */

    const blank = html`
        <form class="blank ${className ?? ""}">
            ${blankHeaderItems}
            <div class="blank-content">${blankView} ${blankActionsView}</div>
        </form>
    `;

    blank.addEventListener("submit", (e) => e.preventDefault());

    blank.addHeaderLeftItems = (items = []) => {
        /**@type {Array} */
        const list = headerLeftItems();
        list.push(...items);
        headerLeftItems(list);
    };

    blank.addHeaderRightItems = (items = []) => {
        /**@type {Array} */
        const list = headerRightItems();
        list.push(...items);
        headerRightItems(list);
    };
    blank.addHeaderLeftItem = (...items) => {
        blank.addHeaderLeftItems(items);
    };

    blank.addHeaderRightItem = (...items) => {
        blank.addHeaderRightItems(items);
    };

    blank.addItem = (item) => {
        const list = blankItems();
        list.push(item);
        blankItems(list);
    };
    blank.addItems = (items) => {
        const list = blankItems();
        blankItems(list.concat(items));
    };

    blank.getItems = () => blankItems();

    blank.getItem = (index) => {
        const list = blankItems();
        return list[index];
    };

    blank.removeItem = (item) => {
        let list = blankItems();
        list = list.filter((listItem) => listItem !== item);
        blankItems(list);
    };

    blank.removeItemByIndex = (index) => {
        const item = blank.getItem(index);
        blank.removeItem(item);
    };

    blank.removeItems = (items = []) => {
        items.forEach((item) => blank.removeItem(item));
    };

    blank.actionView = (show) => {
        if (show) {
            blankActionsView.classList.add("is-active");
        } else {
            blankActionsView.classList.remove("is-active");
        }
        return blankActionsView;
    };

    blankActionsView.addItem = (item) => {
        const list = blankActionsViewItems();
        list.push(item);
        blankActionsViewItems(list);
    };

    blankActionsView.addItems = (items) => {
        const list = blankActionsViewItems();
        blankActionsViewItems(list.concat(items));
    };

    const handleChange = ({ key, value }) => {
        const d = blankData();
        d[key] = value;
        blankData(d);
    };

    blank.createComponent = ({
        Component,
        key,
        value: initialValue,
        keys,
        values: initialValues,
        onChange,
        ...rest
    }) => {
        if (key) {
            if (!key.includes(".")) {
                set(blankData, key, get(initialData, key) ?? initialValue);
            }
            const value = () => get(blankData, key);

            const component = Component({
                ...rest,
                value,
                key,
                onChange: (params) => {
                    handleChange(params);
                    onChange?.(params);
                },
            });

            return component;
        }
        if (Array.isArray(keys)) {
            const values = keys.reduce((obj, key) => {
                if (!key.includes(".")) {
                    set(
                        blankData,
                        key,
                        get(initialData, key) ?? initialValues?.[key]
                    );
                }
                return { ...obj, [key]: () => get(blankData, key) };
            }, {});
            const component = Component({
                ...rest,
                values,
                keys,
                onChange: (params) => {
                    handleChange(params);
                    onChange?.(params);
                },
            });

            return component;
        }
    };

    blank.createField = (props) => {
        const { key = "", value: initialValue } = props ?? {};
        if (!key.includes(".")) {
            set(blankData, key, get(initialData, key) ?? initialValue);
        }
        const value = computed(() => get(blankData, key));

        const error = computed(() => props.error?.() ?? errors()?.[key]);

        const field = Field({
            ...props,
            value,
            onChange: (fieldData) => {
                handleChange(fieldData);
                props.onChange?.(fieldData);
            },
            error,
        });

        blankFields[key] = field;

        return field;
    };

    blank.createTable = (props) => {
        set(blankData, props.key, initialData?.[props.key]);

        props.hideHeaderMenu =
            props.hideHeaderMenu == null ? true : props.hideHeaderMenu;
        if (!props.column_props.some((cp) => cp.id === "Index")) {
            props.column_props.push({
                id: "Index",
                disabled: true,
                isHidden: true,
                type: "input",
                dataType: "number",
                title: "idx",
            });
        }
        const table = Table(props);
        if (props.filter) {
            const tableData = get(blankData, props.key) ?? "";
            const filteredData = [];
            if (tableData) {
                tableData[props.key].forEach((row) => {
                    if (row[props.filter.key] == row[props.filter.value])
                        filteredData.push(row);
                });
            }
            table.createRows(filteredData);
        } else {
            table.createRows(get(blankData, props.key) ?? "");
        } //? YOU NEED IT?
        table.getKey = () => props.key;
        blankTables[props.key] = table;
        return table;
    };

    blank.removeTable = (table) => {
        delete blankTables[table.getKey()];
    };

    blank.createRow = (props) => {
        const { class: className } = props ?? {};
        const rowItems = o([]);
        const blankRow = html`<div class="blank-row ${className ?? ""}">
            ${map(rowItems, (i) => i)}
        </div>`;

        blankRow.addItem = (item) => {
            const list = rowItems();
            list.push(item);
            rowItems(list);
            return blankRow;
        };

        blankRow.addItems = (items) => {
            /**@type {Array} */
            const list = rowItems();
            rowItems(list.concat(items));
            return blankRow;
        };

        blankRow.getItem = (index) => rowItems()[index];
        blankRow.getItemList = () => rowItems();

        return blankRow;
    };

    blank.cancelButtonAction = cancelButtonAction;
    blank.applyButtonAction = applyButtonAction;

    blank.setGroupDoc = (groupDocId) => {
        set(blankData, "groupDoc", { docid: groupDocId });
    };
    blank.setIsGroup = (isGroup) => {
        set(blankData, "isGroup", isGroup);
    };

    blank.setDocid = (docid) => set(blankData, "docid", docid);

    blank.getData = () => {
        const data = { ...(blankData() ?? {}) };

        Object.keys(blankFields).forEach(
            (key) => (data[key] = blankFields[key].getValue())
        );

        Object.keys(blankTables).forEach((k) => {
            data[k] = blankTables[k].getData();
        });

        return data;
    };

    blank.isValid = () => {
        errors(validate(blank.getData()));
        return !errors();
    };

    blank.setValue = (key, value) => {
        const field = blankFields[key];
        if (field) {
            field.setValue(value);
        } else {
            handleChange({ key, value });
        }
    };

    blank.getValue = (key) => {
        const result = get(blankData, key) ?? get(initialData, key);
        return result;
    };

    blank.getObservableValue = (key) => computed(() => blank.getValue(key));

    return blank;
};

var routes$5 = [];
const call = () => {
    var hash = location.hash;
    var path = hash.substr(1);
    for (const id in routes$5) {
        const result = path.match(routes$5[id][0]);
        if (result && routes$5[id][1](result.groups || {}) == true) break;
    }
};

// TODO TEST +
const parts = () => {
    var schema = location.hash;
    if (schema === "" || schema === "#") return "";
    schema = schema.slice(1, schema.length);

    const seperator = schema.indexOf("?");
    const hash = seperator === -1 ? schema : schema.slice(0, seperator);
    const query = seperator === -1 ? "" : schema.slice(seperator + 1);

    return {
        hash: hash,
        query: query,
    };
};

const set_query = (kv, force = false) => {
    const url_parts = parts();

    const url_arguments = new URLSearchParams(force ? "" : url_parts.query);

    for (const key in kv) {
        const value = kv[key];

        url_arguments.delete(key);
        if (value) {
            url_arguments.append(key, value);
        }
    }
    const args = url_arguments.toString();
    if (args.length > 0) {
        location.href = "#" + url_parts.hash + "?" + url_arguments.toString();
    } else {
        location.href = "#" + (url_parts.hash ?? "");
    }
};
// TODO TEST -

window.addEventListener("hashchange", call);
window.addEventListener("load", call);

// import api from "Core/api/index";

const transferObjects = [];

const setTransferObject = (object) => {
    let id = transferObjects.length;
    transferObjects[id] = object;
    return id;
};

const getTransferObject = (id) => {
    let object = transferObjects[id];
    delete transferObjects[id];
    return object;
};

class HierarchicalCardFileNodeData extends NodeData {
    constructor(props, parent) {
        super(props, parent);

        const self = this;

        this.id = props?.id;
        this.targetClass = props?.targetClass;
        this.nodes = props?.nodes;
        this.draggable = o(props?.draggable);
        this.droppable = props?.droppable;
        this.onSelect = props?.onSelect;
        this.onExpand = props?.onExpand;
        this.onCollapse = props?.onCollapse;
        this.hierarchicalNodeName = props?.hierarchicalNodeName
            ? props.hierarchicalNodeName
            : "Name";
        this.onMouseOver = props?.onMouseOver;
        this.onRecordMoved = props?.onRecordMoved;
        this.highlighted = "tree-item--highlight";
        this.menu = Menu();
        this.createMenu();
        this.order = props?.order;
        this.userRights = props.userRights;
        this.rightsLoading = props.rightsLoading;
        this.getFilter = props?.getFilter;
        // const { getCardFileRequest: getCardFileTree = api.getHierarchyLevel } = props;

        let draggable;
        let event_OnDragStart;
        let event_OnDragOver;
        let event_OnDragEnd;

        const unsubscribe_draggable = on(this.draggable, () => {
            if (!self) {
                unsubscribe_draggable();
                return;
            }

            if (draggable) {
                let header = self.getHeader();
                if (!header) return;

                header.removeEventListener("dragstart", event_OnDragStart);
                header.removeEventListener("dragover", event_OnDragOver);
                header.removeEventListener("drop", event_OnDragEnd);
            }

            draggable = self.draggable();

            let header = self.getHeader();
            if (!header) return;

            header.setAttribute("draggable", draggable);

            if (!draggable) return;

            event_OnDragStart = (event) =>
                event.dataTransfer.setData(
                    "text/plain",
                    setTransferObject(self).toString()
                );
            event_OnDragOver = (event) => {
                if (self.droppable) event.preventDefault();
            };
            event_OnDragEnd = async (event) => {
                event.preventDefault();

                if (!event.dataTransfer) return;

                let id = parseInt(event.dataTransfer.getData("text/plain"));
                if (id === null || id === undefined || id < 0) return;

                let object = getTransferObject(id);
                if (!object || object.id == self.id) return;

                let parent = self;
                while (1) {
                    let p = parent.getParent && parent.getParent();
                    if (!p) break; // top parent

                    if (p == object) return; // prevent recursion dropping

                    parent = p;
                }

                try {
                    const result = await moveHierarchyObject(
                        self.targetClass,
                        [object.id],
                        self.id
                    );
                    if (result.ok) {
                        object.getParent()?.itemRemoveByValue(object);
                        object.parent = self;

                        if (self.getExpanded()) self.itemPush(object);

                        self.onRecordMoved?.();
                    }
                } catch (error) {
                    console.error(error);
                }
            };

            header.addEventListener("dragstart", event_OnDragStart, {
                capture: true,
            });
            header.addEventListener("dragover", event_OnDragOver, {
                capture: true,
            });
            header.addEventListener("drop", event_OnDragEnd, { capture: true });
        });

        this.getElement().addEventListener("onCollapse", () => {
            self.clearItems();
            let arrow = self.element().querySelector(".arrow");
            if (arrow) arrow.classList.remove("is-active");

            if (self.onCollapse) self.onCollapse();
        });

        let hierarchicalNodeName = self.hierarchicalNodeName;

        this.getElement().addEventListener("onExpand", async (e) => {
            if (!this.userRights()) {
                await this.rightsLoading;
            }
            if (!this.userRights().canVisible) {
                return;
            }

            let arrow = self.getElement().querySelector(".arrow");
            if (arrow) arrow.classList.add("is-active");
            if (self.getItems().length !== 0) return;

            getCardFileTree({
                targetClass: self.targetClass,
                id: self.id,
                order: self.order,
                filter: this.getFilter(),
            }).then((records) => {
                if (self.getItems().length !== 0) return;
                for (let key in records) {
                    let record = records[key];
                    self.createNode(
                        record.docid,
                        record[hierarchicalNodeName],
                        record.IsGroup
                    );
                }
            });

            if (self.onExpand) self.onExpand();

            if (self.getHeader().nodeName == "H4") self.onSelect(props);
        });

        this.getElement()
            .getHeader()
            .addEventListener("mouseover", (event) => {
                event.stopPropagation();
                self.onMouseOver(props, self);
            });
    }

    /// Create node assigned to current node
    nodeCreate(props) {
        return new HierarchicalCardFileNodeData(props, this);
    }

    removeHighlightTreeItem(treeItem) {
        const tree = treeItem.parentElement;
        tree.querySelector(`.${this.highlighted}`)?.classList?.remove(
            this.highlighted
        );
    }

    addHighlightToTreeItem(treeItem) {
        treeItem.classList.add(this.highlighted);
    }

    createMenu() {
        this.menu.classList.add("table-menu");
        this.menu.style.zIndex = 1;

        const hideMenu = () => {
            this.menu.hide();
        };
        const onClickAway = hideMenu;

        this.menu.addEventListener("onHide", (event) => {
            event.stopPropagation();
            this.menu.remove();
            this.removeHighlightTreeItem(
                this.menu.currentRow.nodeData.getElement()
            );
        });

        this.menu.addEventListener("onShow", (event) => {
            // if (!api.deleteRecordsInGroup) hideMenu();
            if (!(this.userRights()?.canDelete && this.userRights()?.canEdit)) {
                return;
            }

            event.stopPropagation();

            this.addHighlightToTreeItem(
                this.menu.currentRow.nodeData.getElement()
            );

            document.body.append(this.menu);

            this.menu.clearItems();

            document.addEventListener("click", onClickAway, { once: true });

            let clearGroup = this.menu.itemCreateAndPush({
                value: html`<span
                    style="display: flex; align-items: center; gap: 4px"
                    ><div class="icon-delete-sweep" style="color: #ccc;"></div>
                    Удалить группу</span
                >`,
            });
            clearGroup.getElement().addEventListener("click", () => {
                const { targetClass, docid } = this.menu.currentRow.nodeData;
                deleteRecordsInGroup(targetClass, docid).then((res) => {
                    this.menu.hide();
                });
                this.menu.hide();
            });
        });
    }

    createNode(id, name, is_group) {
        if (!is_group) return;

        const self = this;
        let arrow = html`<div class="arrow"></div>`; // element.toggle = _ => element.setExpanded(!element.getExpanded());
        let nameEl = html`<div>${name}</div>`;
        let node = self.nodeCreate({
            id: id,
            targetClass: self.targetClass,
            draggable: self.draggable(),
            droppable: self.droppable,
            onSelect: self.onSelect,
            nodes: self.nodes,
            onMouseOver: self.onMouseOver,
            order: self.order,
            onExpand: self.onExpand,
            onCollapse: self.onCollapse,
            hierarchicalNodeName: self.hierarchicalNodeName,
            onRecordMoved: self.onRecordMoved,
            rightsLoading: this.rightsLoading,
            userRights: this.userRights,
            header: is_group
                ? html`<div title=${name}>${arrow}${nameEl}</div>`
                : html`<div title=${name}>${nameEl}</div>`,
            getFilter: this.getFilter,
        });

        node.name = name;
        node.is_group = is_group;

        self.nodes[node.id] = node;

        nameEl.addEventListener("click", (event) => {
            event.stopPropagation();
            if (node.onSelect) node.onSelect(node);
        });

        nameEl.addEventListener("mouseover", (event) => {
            event.stopPropagation();
            if (node.onMouseOver) node.onMouseOver(node, self);
        });

        // if (
        //     api.deleteRecordsInGroup &&
        //     typeof api.deleteRecordsInGroup === "function"
        // )
        nameEl.addEventListener("contextmenu", (event) => {
            event.preventDefault();
            this.removeHighlightTreeItem(node.getElement());
            self.menu.currentRow = { row: { docid: id }, nodeData: node };
            self.menu.setPos(event.pageX, event.pageY);
            self.menu.show();
        });

        self.itemPush(node);

        return node;
    }

    get ancestors() {
        let ancestors = [];
        let parent = this.parent;
        while (parent && parent.id) {
            ancestors.unshift(parent);
            parent = parent.parent;
        }

        return ancestors;
    }
}

const HierarchicalCardFile = (props) => {
    props = props || {};
    props.root = props?.root || new HierarchicalCardFileNodeData(props);

    let tree = Tree$1(props);

    let root = tree.getRoot();

    root.nodes = {};
    root.targetClass = props?.targetClass;
    root.draggable = o(props?.draggable);
    root.droppable = props?.droppable;
    root.onExpand = props?.onExpand;
    root.onCollapse = props?.onCollapse;
    root.onSelect = props?.onSelect;
    root.hierarchicalNodeName = props?.hierarchicalNodeName;
    root.onMouseOver = props?.onMouseOver;

    return tree;
};

/**
 * @typedef {object} SignOption
 *
 * Знак сравнения
 *
 * @prop { string }   text      - текст, отображаемый в списка опций
 * @prop { string }   value     - знак сравнения
 * @prop { string }   inputText - отображаемое значение в поле Select
 * @prop { Function } template  - Преобразование фильтра в строку
 */

/**
 * @param {{value: string}}
 */
function defaultTemplate({ key, value, type }) {
    switch (type) {
        case "text":
        case "string": {
            value = value.includes('"') ? `'${value}'` : `"${value}"`;
        }
    }
    return `${key} ${this.value} ${value}`;
}

function referenceTemplate({ key, value, targetClass, ...rest }) {
    if (targetClass == null) {
        return defaultTemplate.call(this, { key, value, ...rest });
    }
    if (value?.docid == null) return "";
    return `${key} ${this.value} {${targetClass}:${value.docid}}`;
}

/**@type {SignOption[]} */
const allSings = [
    {
        text: "is Входит в группу",
        value: "is",
        inputText: "is",
        template: referenceTemplate,
    },
    {
        text: "\u2248 Содержит",
        value: "Match",
        inputText: "\u2248",
        template({ key, value }) {
            return `Match(${key}, '*${value}*')`;
        },
    },
    {
        text: "= Равно",
        value: "=",
        inputText: "=",
        template: referenceTemplate,
    },
    {
        text: "\u2260 Не равно",
        value: "<>",
        inputText: "\u2260",
        template: referenceTemplate,
    },
    {
        text: "> Больше",
        value: ">",
        inputText: ">",
        template: defaultTemplate,
    },
    {
        text: "< Меньше",
        value: "<",
        inputText: "<",
        template: defaultTemplate,
    },
    {
        text: "\u2265 Больше или равно",
        value: ">=",
        inputText: "\u2265",
        template: defaultTemplate,
    },
    {
        text: "\u2264 Меньше или равно",
        value: "<=",
        inputText: "\u2264",
        template: defaultTemplate,
    },
];

const defaultSigns = allSings.filter((v) => !/Match|is/.test(v.value));
const stringSigns = allSings.filter((v) => v.value != "is");
const booleanSigns = allSings.filter((v) => /^=$|<>/.test(v.value));
const referenceSigns = allSings.filter(
    (v) => !/^>$|^<$|<=|>=|Match/.test(v.value)
);

/**
 *
 * @param {FieldShortProperties} props
 * @returns {SignOption[]}
 */
const getSignsByProps = (props) => {
    switch (props.type) {
        case "string":
        case "text": {
            return stringSigns;
        }
        case "boolean":
        case "checkbox":
        case "logical": {
            return booleanSigns;
        }
        default: {
            if (props.cardFile != null) {
                return referenceSigns;
            } else {
                return defaultSigns;
            }
        }
    }
};

const getSignTemplate = (sign) => {
    const signObject = allSings.find((so) => so.value === sign);
    const template = signObject?.template?.bind?.(signObject);
    return template;
};

/**
 * @typedef {import("./cardFileFilter").FilterItem} FilterItem
 */

/**
 * @typedef {import("./cardFileFilter").FieldShortProperties} FieldShortProperties
 */

/**
 * Считает позицию выпадающего меню
 *
 * @param {DOMRect} parentRect
 * @param {DOMRect} elementRect
 *
 * @returns {object} объект, который sinuous может конвертировать в style
 */
const calcSelectListPosition = (parentRect, elementRect) => {
    const style = defaultCalcStyle(parentRect, elementRect);

    style.width = "fit-content";
    style.height = "fit-content";
    style["min-width"] = parentRect.width + "px";

    return style;
};

/**
 *
 * @param {FilterRow.Properties} param0
 * @returns {HTMLUListElement}
 */
const FilterRow = ({
    filter,
    fieldsProps,
    onChange,
    showDeleteFilterBtn: showBtn,
    onDelete,
}) => {
    const options = computed(() =>
        fieldsProps().map((fp, i) => ({ text: fp.title, value: i })),
    );

    // начальные параметры для поля ввода
    const initialProps = createInputProperties(filter.filter);

    const signOptions = o(getSignsByProps(initialProps));

    const fieldSelect = new SelectField({
        options,
        onChange: handleFieldSelectChange,
        key: "filter",
        title: "Поле:",
        // начальное значение
        value: filter.filter,
        // стиль выпадающего списка
        optionsListStyle: { "max-height": "20em" },
        // расчет позиции и стиля выпадающего меню
        calcListPosition: calcSelectListPosition,
    });

    const signSelect = new SelectField({
        key: "sign",
        options: signOptions,
        searchable: false,
        value: filter.sign ?? signOptions()[0].value,
        optionsListStyle: { "max-height": "none" },
        onChange: handleChange,
        calcListPosition: calcSelectListPosition,
        disabled: () => fieldSelect.isEmpty(),
    });

    const deleteBtn = html`<${Button}
        icon=${{ name: "close", size: "1.5em" }}
        onClick=${handleDelete}
        className="--circle --transparent filter__delete-button"
        type="button"
    />`;

    const dynamicField = o(FieldController(initialProps).render());

    const element = html`<${ListItem} classNames="filter-row">
        ${fieldSelect.render()} ${signSelect.render()} ${dynamicField}
        ${() => (showBtn() ? deleteBtn : null)}
    <//>`;

    // обрабатывает изменения полей ввода (field, value, sign)
    function handleChange({ key, value }) {
        filter[key] = value;
        onChange({ filter });
    }

    // создает параметры для поля ввода значения фильтра
    function createInputProperties(propsIndex) {
        const props = {
            ...(fieldsProps()[propsIndex] ?? {}),
            onChange: handleChange,
            key: "value",
            value: filter.value ?? undefined,
        };
        return props;
    }

    // обрабатывает изменение значения выбора поля фильтра
    function handleFieldSelectChange({ key, value }) {
        // обнуляем текущее значение
        filter.value = undefined;
        handleChange({ key, value });

        const props = createInputProperties(value);

        const newSignOptions = getSignsByProps(props);
        signOptions(newSignOptions);
        signSelect.setValue(signOptions()[0].value);

        // создаем новое поле ввода
        const fc = FieldController(props);
        dynamicField(fc.render());
    }

    function handleDelete() {
        onDelete({ filter });
    }

    return element;
};

const FiltersList = ({
    filters,
    fieldsProps,
    onChange,
    onSelectChange,
    showDeleteFilterBtn,
    onDelete,
    onAddFilter,
}) => {
    const addFilterBtn = Button({
        title: "Добавить фильтр",
        type: "button",
        onClick: onAddFilter,
        classNames: ["--circle", "--green", "filter__tools"],
        icon: {
            name: "plus",
        },
    });
    return html`<div class="filter-list-container">
        <${List} classNames="filter-list">
            ${map(filters, (filter) => {
                const row = FilterRow({
                    filter,
                    fieldsProps,
                    onChange,
                    onSelectChange: onSelectChange ?? onChange,
                    showDeleteFilterBtn,
                    onDelete,
                });
                return row;
            })}
        <//>
        ${addFilterBtn}
    </div>`;
};

/**
 * @typedef {object} FieldShortProperties
 *
 * Параметры полей ввода для фильтра
 *
 * @prop {string}   key         - ключ поля ввода (value)
 * @prop {string}   type        - тип ввода
 * @prop {string}   title       - заголовок поля ввода
 * @prop {Function} [cardFile]  - картотека
 * @prop {number}   filterOrder - номер для сортировки
 */

/**
 * @typedef {object} FilterItem
 *
 * Объект фильтра
 *
 * @prop {number}   filter  - индекс поля в списке структуры
 * @prop {any}      value   - значение фильтра
 * @prop {string}   sign    - знак сравнения
 * @prop {number}   index   - индекс строки фильтра
 */

/**
 * Преобразует строку фильтра в текстовое значение
 * @param {{
 *  filter: FilterItem,
 *  props: FieldShortProperties
 * }} param0
 * @returns {string}
 */
const transformFilterToString = ({ filter, props }) => {
    if (filter.value == null) {
        return "";
    }
    const result = getSignTemplate(filter.sign)({
        key: props.key,
        value: filter.value,
        targetClass: props.cardFile?.settings?.targetClass,
        type: props.type,
    });
    return result;
};

/**
 *  Преобразует все строки фильтра в текстовое значение
 *
 * @param {{
 *  filters: FilterItem[],
 *  props: ()=>FieldShortProperties[]
 * }} param0
 * @returns {string}
 */
const transformFiltersListToString = ({ filters, props }) => {
    const result = filters
        .map((f) => {
            if (f.filter == null) return;
            return transformFilterToString({
                filter: f,
                props: props()[f.filter],
            });
        })
        .filter((fs) => !!fs)
        .join(" and ");
    return result;
};

/**
 * Преобразует элементы структуры в параметры полей ввода
 *
 * @param {{field: string, type: string}} param0
 * @param {Array} cardFiles
 * @param {Array} columnsProps
 * @returns {FieldShortProperties}
 */
const toFieldProps = ({ field, type }, cardFiles, columnsProps) => {
    //todo: multiple cardFileSelection
    const index = columnsProps.findIndex((cp) => cp.id === field);
    const { text: title } = index >= 0 ? columnsProps[index] : {};
    // если нашли columnProps
    const filterOrder = index < 0 ? 1 : -index;

    // если поле ввода - ссылочное
    if (type.indexOf(".") >= 0) {
        const cardFileItem = cardFiles.find(
            (cf) => cf.element?.settings?.targetClass === type,
        );

        if (cardFileItem == null) {
            return {
                key: field,
                title: title ? title : field,
                filterOrder,
            };
        }

        return {
            key: field,
            cardFile: cardFileItem.element,
            title: title ? title : field,
            filterOrder,
        };
    }

    type = type.toLowerCase();

    return {
        type,
        key: field,
        title: title ? title : field,
        filterOrder,
    };
};

const CardFileFilter = ({
    onSubmit,
    onCancel,
    recordStructure,
    cardFilesList,
    columnsProps,
}) => {
    // начальное значение строки фильтра
    /**@type {FilterItem} */
    const initialValue = { filter: null, value: null, sign: "=", index: 0 };

    /**@type {(filters: FilterItem[]) => FilterItem[]} */
    const filters = o([{ ...initialValue }]);

    const isEditing = o(false);
    const canReturn = o(true);
    const filterString = o("");
    const showDeleteFilterBtn = o(false);

    const cardFiles = Object.values(cardFilesList);

    /**@type {() => FieldShortProperties[]} */
    const fieldsProps = computed(() =>
        recordStructure()
            .map((rsi) => toFieldProps(rsi, cardFiles, columnsProps))
            .sort((p1, p2) =>
                p1.filterOrder === 1
                    ? p2.filterOrder
                    : p2.filterOrder === 1
                    ? p1.filterOrder
                    : -p1.filterOrder + p2.filterOrder,
            ),
    );

    // при изменении списка фильтров показывать или нет кнопку удаления строки фильтра
    on(filters, () => {
        if (filters().length > 1) {
            if (!showDeleteFilterBtn()) {
                showDeleteFilterBtn(true);
            }
        } else if (showDeleteFilterBtn()) {
            showDeleteFilterBtn(false);
        }
    });

    const cancelBtn = html`<${Button}
        text="Отмена"
        className="--outline"
        type="button"
        onClick=${() => {
            if (filterString().length === 0) {
                isEditing(false);
            }
            onCancel?.();
        }}
        disableTabFocus=${false}
    />`;

    const clearAllBtn = html`<${Button}
        title="Очистить всё"
        type="submit"
        className="--red"
        onClick=${handleClearAll}
        disableTabFocus=${false}
        icon=${{ name: "trash" }}
    />`;

    const applyBtn = html`<${Button}
        text="Применить"
        type="submit"
        disableTabFocus=${false}
    />`;

    const editFilterBtn = html`<${Button}
        className="--circle filter__tools ${() =>
            isEditing() ? "" : "--outline"}"
        title="Редактировать фильтр"
        type="button"
        onClick=${handleEditBtnClick}
        icon=${{ name: "edit" }}
    />`;

    const textArea = new TextAreaField({
        value: () => filterString(),
        key: "filter",
        title: "Фильтр",
        onChange: ({ value }) => {
            filterString(value);
            canReturn(false);
        },
        classNames: ["filter__textarea-field"],
    });

    const renderFilterInput = () =>
        isEditing()
            ? textArea.render()
            : html`<${FiltersList}
                  filters=${filters}
                  fieldsProps=${fieldsProps}
                  onChange=${handleFilterChange}
                  showDeleteFilterBtn=${showDeleteFilterBtn}
                  onDelete=${handleDeleteFilter}
                  onAddFilter=${handleAddFilterLine}
              />`;

    const filterElement = html`<form class="filter">
        <div class="filter-body">
            ${renderFilterInput} ${() => (canReturn() ? editFilterBtn : null)}
        </div>
        <div class="filter-footer">
            ${cancelBtn}
            <div class="filter-actions">${clearAllBtn}${applyBtn}</div>
        </div>
    </form>`;

    function handleSubmit(ev) {
        ev.preventDefault();
        if (isEditing() === false) {
            filterString(
                transformFiltersListToString({
                    filters: filters(),
                    props: fieldsProps,
                }),
            );
        }

        onSubmit?.(filterString());
    }

    function handleClearAll() {
        filters([{ ...initialValue }]);
        isEditing(false);
        filterString("");
    }

    function handleAddFilterLine() {
        const filtersList = filters();
        filtersList.push({ ...initialValue, index: filtersList.length });
        filters(filtersList);
    }

    function handleFilterChange({ filter }) {
        const filtersList = filters();
        filtersList[filter.index] = filter;
        filters(filtersList);
    }

    function handleDeleteFilter({ filter }) {
        const filtersList = filters();
        filtersList.splice(filter.index, 1);
        for (let i = filter.index; i < filtersList.length; i++) {
            filtersList[i].index = i;
        }
        filters(filtersList);
    }

    function handleEditBtnClick() {
        if (isEditing() && !canReturn()) return;

        isEditing(!isEditing());
        if (isEditing()) {
            filterString(
                transformFiltersListToString({
                    filters: filters(),
                    props: fieldsProps,
                }),
            );
        }
    }

    filterElement.addEventListener("submit", handleSubmit);
    filterElement.addEventListener("keydown", (ev) => {
        if (ev.key !== "Enter") return;
        ev.preventDefault();
    });

    filterElement.setFilterByColumn = (columnKey, cellValue) => {
        const filtersArr = filters();
        const propsArr = fieldsProps();
        const filter = propsArr.findIndex((props) => props.key === columnKey);
        if (filter === -1) return;
        const index = filtersArr.findIndex(
            (data) => data.filter === filter || data.filter == null
        );
        if (index != -1) {
            filtersArr.splice(index, 1);
        }
        filtersArr.push({
            ...initialValue,
            filter,
            value: propsArr[filter]?.cardFile ? {} : cellValue,
            index: filtersArr.length,
        });

        filters(filtersArr);
    };

    return filterElement;
};

/* eslint-disable no-unused-vars */

const defaultColumns = [
    {
        id: "IsGroup",
        text: "",
        style: "text-align: center; width: 100%; justify-content: center;",
        styleCell:
            "display: flex; height: 100%; justify-content: center; align-items: center;",
        order: "IsGroup",
        fixWidth: 25,
        callback: TableHelper().fileOrFolder,
    },
    {
        id: "docid",
        text: "DOCID",
        style: "text-align: center; width: 100%; justify-content: center;",
        styleCell: "text-align: center;",
        order: "docid",
        width: 5,
        isHidden: true,
    },
    // {
    //     id: "CreateDate",
    //     text: "Дата создания",
    //     style: "text-align: center; width: 100%; justify-content: center;",
    //     styleCell: "text-align: center;",
    //     order: "CreateDate",
    //     width: 12,
    //     isHidden: true,
    // },
    // {
    //     id: "CreateUser",
    //     text: "Кто создал",
    //     style: "text-align: center; width: 100%; justify-content: center;",
    //     styleCell: "text-align: center;",
    //     order: "CreateUser",
    //     width: 15,
    //     isHidden: true,
    // },
    // {
    //     id: "UpdateDate",
    //     text: "Дата изменения",
    //     style: "text-align: center; width: 100%; justify-content: center;",
    //     styleCell: "text-align: center;",
    //     order: "UpdateDate",
    //     width: 12,
    //     isHidden: true,
    // },
    // {
    //     id: "UpdateUser",
    //     text: "Кто изменил",
    //     style: "text-align: center; width: 100%; justify-content: center;",
    //     styleCell: "text-align: center;",
    //     order: "UpdateUser",
    //     width: 15,
    //     isHidden: true,
    // },
];

const CardFile = (props) => {
    const {
        canSaveCardFileSettings = props?.targetClass != null,
        getCardFileRequest = api.getHierarchyLevel,
        className = props.class,
        canApplyBlank,
        initTree = true,
        cardFilesList = window.cardFilesList ?? {},
        displayAddButton: dab = true,
        customTools,
        constFilter: initialConstFilter,
        contextMenu,
        tree: treeProps,
        multiselect,
        request = api.createOrUpdateRecord,
        useQueryToOpenBlank: useQuery = true,
        filter: initialFilter,
        isHierarchycal: initialIsHierarchycal = true,
        closeModalOnBgClick = false,
    } = props ?? {};

    const cardFileProps = props;
    const userRights = o(null);
    const rightsLoading = api
        .getRightsForRole({
            targetClass: cardFileProps.targetClass,
        })
        .then((result) =>
            // result.isOk &&
            userRights(roleRightsService.set(props.targetClass, result.data))
        );
    const fetchData = async (...props) => {
        if (!userRights()) {
            await rightsLoading;
        }
        if (userRights().canVisible) {
            return getCardFileRequest(...props);
        }
        return {};
    };

    let abortController = new AbortController();
    const modal = Modal({
        onHide: () => {
            modal.setContent(null);
            cardFile.hideBlank?.();
        },
        showCloseButton: false,
        closeOnBackground: closeModalOnBgClick,
    });
    const loader = Loader();

    const order = o(cardFileProps.order || "");
    const filter = o(initialFilter || "");
    const constFilter = o(initialConstFilter || "");
    const isHierarchycal = o(initialIsHierarchycal ?? true);
    const cardFileBlank = o();
    const cardFileGroupBlank = o();
    const recordStructure = o([]);

    let blank = undefined;
    let treeRoot;

    let segmentLength = 50;
    let segmentLengthDownloaded = 0;

    const restoreDefault = html`<span onclick=${restoreDefaultSize}>
        Восстановить по умолчанию
    </span>`;

    const draggingElement = o(undefined);
    document.body.append(html`${draggingElement}`);

    let currentTreeNode = undefined;
    let selectedTableRow = {};

    let onSelect = (node, updateTree = true) => {
        cardFile.currentNode(node);

        let header;
        if (!node.header) {
            header = node.getHeader();
        } else {
            header = node.header;
        }
        if (header) header.classList.add("is-selected");

        if (currentTreeNode) {
            if (currentTreeNode !== header)
                currentTreeNode.classList.remove("is-selected");
        }
        currentTreeNode = header;

        if (
            node.id &&
            node.id != treeProps?.root?.id &&
            updateTree &&
            node.getItems().length === 0
        ) {
            api.getCardFileTree(
                {
                    targetClass: node.targetClass,
                    id: node.id,
                    order: tree?.order,
                    filter: getFilter(),
                },
                abortController.signal
            ).then((records) => {
                node.clearItems();
                for (let key in records) {
                    let record = records[key];
                    node.createNode(
                        record.docid,
                        record[node.hierarchicalNodeName],
                        record.IsGroup
                    );
                }
            });
        }

        // loader.show();

        startTop = 1;
        startBottom = 200;

        cardFile.updateTable(
            {
                targetClass: node.targetClass,
                id: node.id,
                order: order(),
                filter: getFilter(),
                isHierarchycal: isHierarchycal(),
                length: 200,
            },
            abortController.signal
        );
    };

    let currentMouseOverNode = {};

    let onTreeNodeMouseOver = (node, props) => {
        if (isDraggingMove) {
            currentMouseOverNode.element = node?.getHeader
                ? node.getHeader()
                : node.header;
            if (currentMouseOverNode.element) {
                currentMouseOverNode.id = node.id || -1;
                currentMouseOverNode.element.classList.add("is-drag-enter");
                currentMouseOverNode.element.addEventListener(
                    "mouseout",
                    () => {
                        currentMouseOverNode.element.classList.remove(
                            "is-drag-enter"
                        );
                        currentMouseOverNode.id = 0;
                    }
                );
            }
        }
    };

    const tree = initTree
        ? HierarchicalCardFile({
              targetClass: props.targetClass,
              draggable: true,
              droppable: true,
              hierarchicalNodeName: cardFileProps?.hierarchicalNodeName,
              id: treeProps?.root?.id,
              order: treeProps?.order,
              onRecordMoved: () => cardFile.updateTable(),
              rightsLoading: rightsLoading,
              userRights,
              getFilter,

              header: html`<h4>
                  ${treeProps?.root?.name
                      ? treeProps.root.name
                      : props.rootName
                      ? props.rootName
                      : "Корень"}
              </h4>`,

              onSelect: onSelect,
              onMouseOver: onTreeNodeMouseOver,
              getCardFileRequest: fetchData,
          })
        : null;

    let backButtonAction = () => {
        let curNode = cardFile.currentNode();
        if (curNode.id && treeProps?.root?.id != curNode.id) {
            curNode?.parent?.onSelect(curNode?.parent, false);
        } else if (curNode && curNode?.expand) {
            curNode?.expand();
        }
    };

    let setTableOrder = (order_query) => {
        order(order_query);
        cardFile.updateTable({ start: startTop, order: cardFileProps.order });
    };

    cardFileProps.backButtonAction = backButtonAction;
    cardFileProps.setOrder = setTableOrder;

    cardFileProps.headerMenuItems = [restoreDefault];
    if (canSaveCardFileSettings) {
        cardFileProps.savedSettingsKey = `cardFile/${props?.targetClass}`;
    }
    const columnsToAdd = defaultColumns.filter(
        (col) => !cardFileProps.column_props.some((cp) => col.id === cp.id)
    );
    if (columnsToAdd.length > 0) {
        cardFileProps.column_props.unshift(...columnsToAdd);
    }

    const table = Table$1(cardFileProps);

    let resizeTable = () => {
        let windowWidth =
            (window.innerWidth / 100) * cardFileProps.cardWidth - 20;

        let columnWidth = {};
        for (let i = 0; i < cardFileProps.column_props.length; i++) {
            cardFileProps.column_props[i].width
                ? (columnWidth[cardFileProps.column_props[i].id] =
                      (windowWidth / 100) * cardFileProps.column_props[i].width)
                : (columnWidth[cardFileProps.column_props[i].id] =
                      cardFileProps.column_props[i].fixWidth);
        }

        let columns = table.getColumns();

        let columns_hash = {};
        for (let i = 0; i < columns.length; i++)
            columns_hash[columns[i].index] = columns[i];

        for (let key in columnWidth)
            columns_hash[key].setWidth(columnWidth[key]);
    };

    window.addEventListener("resize", resizeTable, false);
    resizeTable();

    const handleBlankApply = async () => {
        if (
            typeof canApplyBlank === "function" &&
            !canApplyBlank(cardFile.targetClass, blank.getData())
        )
            return;
        props?.beforeApplyBlank &&
            props?.beforeApplyBlank(cardFile.targetClass, blank.getData());
        loader.show();
        try {
            const result = await request(cardFile.targetClass, blank.getData());
            let data;
            if (result?.isOk != null) {
                data = result.data;
                if (result.isOk) {
                    cardFile.hideBlank();
                    cardFile.updateTable();
                }
            } else {
                data = result;
                cardFile.hideBlank();
                cardFile.updateTable();
            }
            props?.afterApplyBlank && props?.afterApplyBlank();

            return data;
        } finally {
            loader.hide();
        }
    };

    let applyBlank = props?.ApplyBlank ? props.ApplyBlank : handleBlankApply;

    let createNewRecord = (isGroup, data) => {
        if (!cardFileBlank()) return;

        const groupDocId = cardFile.currentNode()?.id;
        const createBlank = isGroup
            ? cardFileGroupBlank() ?? cardFileBlank()
            : cardFileBlank();

        data = {
            ...(data ?? {}),
            docid: "",
            groupDoc: { docid: groupDocId ? groupDocId : "" },
            IsGroup: isGroup,
            cardFile,
            cancelButtonAction: () => cardFile.hideBlank(),
            applyButtonAction: applyBlank,
            userRights: userRights,
        };

        blank = createBlank(data);

        // if (!blank.applyButtonAction) blank.applyButtonAction = applyBlank;
        // blank.cancelButtonAction = cardFile.hideBlank;
        blank.hide = () => cardFile.hideBlank();
        blank.refreshData = async (docid) =>
            await cardFile.viewRecord({ docid });
        modal.setContent(blank);
        modal.show();

        // let modal = Modal({ contents: blank });
        // modal.addEventListener("onClose", cardFile.hideBlank);
        // modal_visible(modal);
    };

    let createRecordButton = html`<button
        style="margin-left: 0"
        class="add-button"
    ></button>`;
    createRecordButton.addEventListener("click", () => {
        cardFile.createNewRecord(false);
    });

    const filterElement = html`<${CardFileFilter}
        onCancel=${() => modal.hide()}
        onSubmit=${(f) => {
            modal.hide();
            if (filter() === f) return;

            filter(f);
            cardFile.updateTable({
                isHierarchycal: f === "" ? undefined : false,
            });
        }}
        recordStructure=${recordStructure}
        cardFilesList=${cardFilesList}
        columnsProps=${cardFileProps.column_props}
    />`;

    let filterButton = html`<button class="filter-button"></button>`;
    filterButton.addEventListener("click", () => {
        modal.setContent(filterElement);
        modal.show();
    });

    // Кнопка для дополнительных действий
    let addActions = DropDownList({
        header: html`<button class="options-button"></button>`,
        isHoverable: true,
    });
    addActions.style.display = "none";
    // Кнопка для дополнительных действий

    let selectRecordButton = html`<button
        class="card-file-select-record button-tool"
    >
        Выбрать
    </button>`;
    selectRecordButton.addEventListener("click", () => {
        let selectedData = selectedTableRow.nodeData;
        if (multiselect) {
            if (selectedRows.length > 0) {
                selectedData = selectedRows.map(({ data }) => data);
            } else if (selectedTableRow.nodeData) {
                selectedData = [selectedTableRow.nodeData];
            } else {
                selectedData = null;
            }
        }
        cardFileProps.inModal(selectedData, cardFileProps.callBackElement);
    });

    if (cardFileProps.inModal) {
        createRecordButton.style.display = "none";
        selectRecordButton.style.display = "block";
    } else {
        selectRecordButton.style.display = "none";
        createRecordButton.style.display = "block";
    }

    let cardTable = html`<div class="card-table">${table}</div>`;

    cardTable.addEventListener("contextmenu", (event) => {
        event.preventDefault();
        if (event.target == cardTable) {
            table.menu_table.setPos(event.pageX, event.pageY);
            table.menu_table.show();
        }
    });
    if (currentBrowser.isSafari) {
        cardTable.addLongTouchListener((event) => {
            if (event.target == cardTable) {
                const touch = event.touches[0];
                table.menu_table.setPos(touch.pageX, touch.pageY);
                table.menu_table.show();
            }
        });
    }

    const clearSelectText = () => {
        if (window.getSelection) {
            window.getSelection().removeAllRanges();
        } else {
            document.selection.empty();
        }
    };

    let resizeTool = html`<span class="resize-tool"></span>`;

    let resizeStarted = false;
    let startResizePos;
    let startResizeWidth;

    let resizeMouseDownHandler = (event) => {
        if (!initTree) return;
        if (!resizeStarted) {
            resizeStarted = true;
            startResizePos = event.clientX;
            startResizeWidth = parseInt(
                document.defaultView.getComputedStyle(cardTree).width,
                10
            );
            document.body.addEventListener(
                "mousemove",
                resizeMouseMoveHandler,
                false
            );
            document.body.addEventListener(
                "mouseup",
                resizeMouseUpHandler,
                false
            );
        }
    };

    let resizeMouseMoveHandler = (event) => {
        if (!initTree) return;
        if (resizeStarted) {
            clearSelectText();
            let value = event.clientX - startResizePos;
            cardTree.style.width =
                startResizeWidth + value >= 20
                    ? startResizeWidth + value + "px"
                    : "20px";
        }
    };

    let resizeMouseUpHandler = (event) => {
        if (!initTree) return;
        resizeStarted = false;
        document.body.removeEventListener(
            "mousemove",
            resizeMouseMoveHandler,
            false
        );
        document.body.removeEventListener(
            "mouseup",
            resizeMouseUpHandler,
            false
        );
    };

    resizeTool.addEventListener("mousedown", resizeMouseDownHandler, false);

    let cardTree = html`<div class="card-tree">${tree}</div>`;

    const cardFileTreeElement = html`${cardTree}${resizeTool}`;

    const cardFile = html`
        <div class="card-file-container${className ? ` ${className}` : ""}">
            <div style="display: flex; justify-content: space-between">
                <div
                    class="card-file__title-container"
                    style="display: flex; gap: 10px"
                >
                    <h2 class="card-file__title">
                        ${cardFileProps.rootName ?? cardFileProps.title ?? ""}
                    </h2>
                </div>
                <div class="card-file-tools">
                    ${customTools}
                    ${cardFileProps?.[HELP_KEYS.PROJECT]
                        ? html`<${HelpLink}
                              projectId=${cardFileProps[HELP_KEYS.PROJECT]}
                          />`
                        : null}
                    ${addActions} ${filterButton}
                    ${() =>
                        (userRights()?.canAdd && userRights().canEdit) ?? dab
                            ? createRecordButton
                            : null}
                    ${selectRecordButton}
                </div>
            </div>

            <div class="card-file">
                ${initTree ? cardFileTreeElement : null}${cardTable}
            </div>
        </div>
    `;

    cardFile.currentNode = o(undefined);

    // const refreshBlankData = async (docid) => {
    //     const result = await api.getRecord(props.targetClass, docid);
    //     if (result != null && !(result instanceof Error)) {
    //         blank.updateData(result);
    //         return true;
    //     }
    //     return false;
    // };

    cardFile.viewRecord = async (props) => {
        if (!cardFileBlank() && !cardFileGroupBlank()) return;
        if (!userRights()) {
            await rightsLoading;
        }
        if (!userRights().canVisible) {
            return;
        }

        const record = await api.getRecord(cardFile.targetClass, props.docid);

        if (record instanceof Error) {
            console.error(record);
            return;
        }

        const createBlank = record.IsGroup
            ? cardFileGroupBlank() ?? cardFileBlank()
            : cardFileBlank();

        blank = createBlank(
            {
                ...record,
                cardFile,
                cancelButtonAction: () => cardFile.hideBlank(),
                applyButtonAction: applyBlank,
                userRights: userRights,
            },
            props.docid
        );

        // if (!blank.applyButtonAction) blank.applyButtonAction = applyBlank;
        // blank.cancelButtonAction = cardFile.hideBlank;

        blank.refreshData = async (docid) =>
            await cardFile.viewRecord({ docid } ?? props);
        blank.hide = () => cardFile.hideBlank();
        modal.setContent(blank);
        modal.show();
    };

    // cell click
    let currentClicketRow = undefined;
    let currentClicketCell = undefined;

    let cellClick = (event) => {
        // event.stopPropagation();
        hideMenus();
        if (!event.ctrlKey) {
            let cell =
                event.target.nodeName == "TD"
                    ? event.target
                    : event.target.parentNode;
            let row = cell.parentNode;

            if (selectedRows.length > 0) {
                selectedRows.forEach((el) => {
                    el.element.classList.remove("is-active");
                });
                selectedRows = [];
            }

            if (currentClicketCell !== cell) {
                if (currentClicketCell)
                    currentClicketCell.classList.remove("clicket-cell");
                if (currentClicketRow)
                    currentClicketRow.classList.remove("clicket-row");

                cell.classList.add("clicket-cell");
                row.classList.add("clicket-row");

                currentClicketRow = row;
                currentClicketCell = cell;

                currentClicketCell.classList.add("clicket-cell");
                currentClicketRow.classList.add("clicket-row");
            } else {
                currentClicketCell?.classList.remove("clicket-cell");
                currentClicketRow?.classList.remove("clicket-row");
                currentClicketRow = undefined;
                currentClicketCell = undefined;
            }
        }
    };

    const updateRow = (row, data) => {
        row.clearCells();

        let cells = [];

        let columns = table.getColumns();
        let columns_hash = {};
        for (let i = 0; i < columns.length; i++)
            columns_hash[columns[i].index] = i;

        for (let i = 0; i < cardFileProps.column_props.length; i++) {
            const columnProps = cardFileProps.column_props[i];
            const key = columnProps.id;
            let cellElement;
            const changeValue = columnProps.callback ?? columnProps.changeValue;
            if (changeValue) {
                cellElement = html`<div style=${columnProps.styleCell}>
                    ${changeValue(data[key], data, key)}
                </div>`;
            } else {
                cellElement = html`<div
                    style=${columnProps.styleCell}
                    title=${data[key]}
                >
                    ${data[key]}
                </div>`;
            }
            if (!cardFileProps.inModal)
                cellElement.addEventListener("click", cellClick, false);
            cells[columns_hash[key]] = {
                value: cellElement,
                columnKey: key,
            };
        }

        row.cellsCreateAndPush(cells);

        let row_cells = row.getCells();
        for (let i = 0; i < row_cells.length; i++) {
            let column = columns[i];
            let cell = row_cells[i];

            if (!cardFileProps.inModal)
                cell?.getElement().parentNode.addEventListener(
                    "click",
                    cellClick,
                    false
                );

            if (!table.getHiddenColumn(column)) continue;

            cell?.getElement()?.classList.add("is-hidden");
        }
    };

    cardFile.clearRows = table.clearRows;

    cardFile.hideBlank = () => {
        modal.hide();
        // modal_visible(null);
        if (useQuery && !cardFileProps.inModal) set_query({ id: "" });
    };

    // MENU ON TABLE ROW +
    table.menu_row = Menu();
    table.menu_row.classList.add("table-menu");
    table.menu_row.style.zIndex = 999;

    let hideMenus = () => {
        table.menu_row.hide();
        table.menu_table.hide();
    };

    let onClickAway = hideMenus;

    table.menu_row.addEventListener("onHide", (event) => {
        event.stopPropagation();

        table.menu_row.remove();
    });

    table.menu_row.addEventListener("onShow", (event) => {
        table.menu_table.hide();

        event.stopPropagation();

        document.body.append(table.menu_row);

        table.menu_row.clearItems();

        document.addEventListener("click", onClickAway, { once: true });
        const { columnKey } = table.menu_row.currentRow;

        if (columnKey) {
            const cellValue = table.menu_row.currentRow.nodeData[columnKey];
            const searchByColumn = table.menu_row.itemCreateAndPush({
                value: html`<span
                    style="display: flex; align-items: center; gap: 6px"
                >
                    <${Icon}
                        name="filter"
                        style="font-size: 12px; color: #ccc"
                    />
                    Фильтр
                </span>`,
            });
            searchByColumn.getElement().addEventListener("click", () => {
                filterElement.setFilterByColumn(columnKey, cellValue);
                modal.setContent(filterElement);
                modal.show();
            });
        }

        const editText = () =>
            userRights().canEdit ? "Редактировать" : "Просмотреть";
        let viewRecord = table.menu_row.itemCreateAndPush({
            value: html`
                <span style="display: flex; align-items: center;">
                    <div class="edit-icon"></div>
                    ${editText}
                </span>
            `,
        });

        viewRecord.getElement().addEventListener("click", () => {
            if (cardFileProps.inModal) {
                window.open(
                    `${location.origin}/#cardfile/${cardFile.urlPath}?id=${table.menu_row.currentRow.nodeData.docid}`
                );
            } else {
                if (useQuery) {
                    set_query({ id: table.menu_row.currentRow.nodeData.docid });
                } else {
                    cardFile.viewRecord({
                        docid: table.menu_row.currentRow.nodeData.docid,
                    });
                }
                table.menu_row.hide();
            }
        });

        if (userRights().canAdd && userRights().canEdit) {
            let addNewRecord = table.menu_row.itemCreateAndPush({
                value: html`<span style="display: flex; align-items: center;"
                    ><div class="file-icon-menu"></div>
                    Добавить</span
                >`,
            });

            addNewRecord.getElement().addEventListener("click", () => {
                cardFile.createNewRecord(false);
                table.menu_row.hide();
            });

            let addNewGroupRecord = table.menu_row.itemCreateAndPush({
                value: html`<span style="display: flex; align-items: center;"
                    ><div class="folder-icon-menu"></div>
                    Добавить группу</span
                >`,
            });

            addNewGroupRecord.getElement().addEventListener("click", () => {
                cardFile.createNewRecord(true);
                table.menu_row.hide();
            });
            let duplicateRecordEl = table.menu_row.itemCreateAndPush({
                value: html`<span style="display: flex; align-items: center;"
                    ><div class="duplicate-icon"></div>
                    Дублировать</span
                >`,
            });

            duplicateRecordEl.getElement().addEventListener("click", () => {
                api.duplicateRecord(
                    table.menu_row.currentRow.nodeData.targetClass,
                    table.menu_row.currentRow.nodeData.docid
                ).then((res) => {
                    // cardFile.updateTable();
                    if (res.docid) {
                        if (useQuery) {
                            set_query({ id: res.docid });
                        } else {
                            cardFile.viewRecord({ docid: res.docid });
                        }
                    } else {
                        Message$1("Произошла ошибка", "error");
                    }
                    table.menu_row.hide();
                });
            });
        }

        let hierarchicalView = table.menu_row.itemCreateAndPush({
            value: html`<span style="display: flex; align-items: center;"
                >${isHierarchycal()
                    ? html`<div class="check-mark"></div>`
                    : html`<div class="empty-mark"></div>`}Иерархический
                вид</span
            >`,
        });

        hierarchicalView.getElement().addEventListener("click", () => {
            cardFile.updateTable({
                isHierarchycal: isHierarchycal()
                    ? isHierarchycal(false)
                    : isHierarchycal(true),
            });
            table.menu_row.hide();
        });

        if (userRights().canDelete && userRights().canEdit) {
            if (table.menu_row?.currentRow?.nodeData?.IsGroup) {
                let clearGroup = table.menu_row.itemCreateAndPush({
                    value: html`<span
                        style="display: flex; align-items: center; gap: 4px"
                    >
                        <div
                            class="icon-delete-sweep"
                            style="color: #ccc;"
                        ></div>
                        Удалить группу
                    </span>`,
                });
                clearGroup.getElement().addEventListener("click", () => {
                    const { targetClass, docid } =
                        table.menu_row.currentRow.nodeData;
                    api.deleteRecordsInGroup?.(targetClass, docid).then(
                        (res) => {
                            cardFile.updateTable();
                            table.menu_row.hide();
                        }
                    );
                });
            } else {
                let removeRow = table.menu_row.itemCreateAndPush({
                    value: html`<span
                        style="display: flex; align-items: center;"
                        ><div class="trash-icon"></div>
                        Удалить</span
                    >`,
                });

                const onRemoveRowClick = () => {
                    if (selectedRows.length > 0) {
                        return confirmDeletion();
                    }
                    if (contextMenu?.removeRow?.onClick) {
                        return contextMenu.removeRow.onClick(
                            table.menu_row.currentRow.nodeData.targetClass,
                            table.menu_row.currentRow.nodeData.docid
                        );
                    }
                    api.deleteRecord(
                        table.menu_row.currentRow.nodeData.targetClass,
                        table.menu_row.currentRow.nodeData.docid
                    ).then((res) => {
                        cardFile.updateTable();
                        table.menu_row.hide();
                        treeRoot?.nodes[
                            table.menu_row.currentRow.nodeData.docid
                        ]
                            ?.getElement()
                            ?.remove();
                    });
                };
                removeRow
                    .getElement()
                    .addEventListener("click", onRemoveRowClick);
            }
        }

        // recalculate position
        const rect = table.menu_row.getBoundingClientRect();

        const y =
            rect.height + rect.top <= document.body.clientHeight
                ? rect.top
                : rect.top - rect.height;
        const x =
            rect.width + rect.left <= document.body.clientWidth
                ? rect.left
                : rect.left - rect.width;

        if (rect.left != x || rect.right != y) {
            table.menu_row.setPos(x, y);
        }
    });

    table.menu_table = Menu();
    table.menu_table.classList.add("table-menu");
    table.menu_table.style.zIndex = 999;

    table.menu_table.addEventListener("onHide", (event) => {
        event.stopPropagation();

        table.menu_table.remove();
    });

    table.menu_table.addEventListener("onShow", (event) => {
        table.menu_row.hide();

        event.stopPropagation();

        document.body.append(table.menu_table);

        table.menu_table.clearItems();

        document.addEventListener("click", onClickAway, { once: true });

        if (userRights().canAdd && userRights().canEdit) {
            let addNewRecord = table.menu_table.itemCreateAndPush({
                value: html`<span style="display: flex; align-items: center;"
                    ><div class="file-icon-menu"></div>
                    Добавить</span
                >`,
            });

            addNewRecord.getElement().addEventListener("click", () => {
                cardFile.createNewRecord(false);
                table.menu_table.hide();
            });

            let addNewGroupRecord = table.menu_table.itemCreateAndPush({
                value: html`<span style="display: flex; align-items: center;"
                    ><div class="folder-icon-menu"></div>
                    Добавить группу</span
                >`,
            });

            addNewGroupRecord.getElement().addEventListener("click", () => {
                cardFile.createNewRecord(true);
                table.menu_table.hide();
            });
        }

        let hierarchicalView = table.menu_table.itemCreateAndPush({
            value: html`<span style="display: flex; align-items: center;"
                >${isHierarchycal()
                    ? html`<div class="check-mark"></div>`
                    : html`<div class="empty-mark"></div>`}Иерархический
                вид</span
            >`,
        });

        hierarchicalView.getElement().addEventListener("click", () => {
            cardFile.updateTable({
                isHierarchycal: isHierarchycal()
                    ? isHierarchycal(false)
                    : isHierarchycal(true),
            });
            table.menu_table.hide();
        });
    });
    // MENU ON TABLE ROW -

    const onTableFolderMouseOver = ({ data, element }, ev) => {
        if (!isDraggingMove) return;
        ev.stopPropagation();
        currentMouseOverNode.id = data.docid;
        // current
    };

    cardFile.createRows = (props, is_unshift, scroll) => {
        let count = 0;
        for (let _ in props) count++;
        let hack = new Array(count);

        const columns_hidden = [];
        const columns = table.getColumns();

        for (let i = 0; i < columns.length; i++)
            columns_hidden[i] = !!table.getHiddenColumn(columns[i]);

        const datas = is_unshift
            ? table.rowsCreateAndUnshift(hack)
            : table.rowsCreateAndPush(hack);
        for (var i = 0; i < datas.length; i++) {
            const row = datas[i];

            updateRow(row, props[i]);

            let nodeData = props[i];
            if (!nodeData.targetClass) {
                nodeData.targetClass = cardFile.targetClass;
            }
            const row_element = row.getElement();
            row_element.nodeData = nodeData;

            row_element.addEventListener("contextmenu", (event) => {
                event.preventDefault();
                const cell = event.target.closest(".table-cell");
                const columnKey = cell?.dataset.columnKey;

                table.menu_row.currentRow = { row, nodeData, columnKey };
                table.menu_row.setPos(event.pageX, event.pageY);
                table.menu_row.show();
            });
            if (currentBrowser.isSafari) {
                row_element.addLongTouchListener((event) => {
                    const cell = event.target.closest(".table-cell");
                    const columnKey = cell?.dataset.columnKey;
                    const touch = event.touches[0];

                    table.menu_row.currentRow = {
                        row,
                        nodeData,
                        columnKey,
                    };
                    table.menu_row.setPos(touch.pageX, touch.pageY);
                    table.menu_row.show();
                });
            }

            let selectedRow = selectedRows.find(
                (el) => el.data.docid == nodeData.docid
            );
            if (selectedRow) {
                row_element.classList.add("is-active");
                selectedRow.element = row_element;
            }

            if (!cardFileProps.inModal) {
                if (props[i].IsGroup) {
                    row_element.addEventListener("dblclick", () => {
                        let treeNode = treeRoot.nodes[nodeData.docid];
                        if (treeNode) {
                            // expand all ancestors if not expanded
                            startBottom = 200;
                            startTop = 1;
                            lastScrollTop = 0;

                            let ancestors = treeNode.ancestors;
                            if (!ancestors) ancestors = [];
                            ancestors.forEach((ancestor) => ancestor.expand());

                            treeNode.onSelect(treeNode, false);
                            treeNode.expand();
                        } else {
                            onSelect({
                                targetClass: nodeData.targetClass,
                                id: nodeData.docid,
                                header: nodeData.header,
                            });
                        }
                    });
                } else {
                    row_element.addEventListener("dblclick", () => {
                        if (useQuery) {
                            set_query({ id: nodeData.docid });
                        } else {
                            cardFile.viewRecord({ docid: nodeData.docid });
                        }
                    });
                }
                // ! d&d
                row_element.addEventListener("mousedown", (event) => {
                    if (event.ctrlKey) {
                        if (row_element.classList.contains("is-active")) {
                            row_element.classList.remove("is-active");
                            selectedRows.splice(
                                selectedRows.indexOf(
                                    selectedRows.find(
                                        (el) => el.element == row_element
                                    )
                                ),
                                1
                            );
                        } else {
                            if (row_element.classList.contains("clicket-row")) {
                                currentClicketRow.classList.remove(
                                    "clicket-row"
                                );
                                currentClicketCell.classList.remove(
                                    "clicket-cell"
                                );
                                selectedRows.push({
                                    element: row_element,
                                    data: nodeData,
                                });
                                row_element.classList.add("is-active");
                                currentClicketRow = undefined;
                                currentClicketCell = undefined;
                            } else {
                                selectedRows.push({
                                    element: row_element,
                                    data: nodeData,
                                });
                                row_element.classList.add("is-active");
                            }
                            if (currentClicketRow) {
                                currentClicketRow.classList.remove(
                                    "clicket-row"
                                );
                                currentClicketCell.classList.remove(
                                    "clicket-cell"
                                );
                                selectedRows.push({
                                    element: currentClicketRow,
                                    data: currentClicketRow.nodeData,
                                });
                                currentClicketRow.classList.add("is-active");
                                currentClicketRow = undefined;
                                currentClicketCell = undefined;
                            }
                        }
                    } else {
                        mouseDownHandler(
                            {
                                element: row_element,
                                data: nodeData,
                            },
                            event
                        );
                    }
                });
                if (nodeData.IsGroup) {
                    row_element.addEventListener("mouseover", (event) => {
                        onTableFolderMouseOver(
                            { data: nodeData, element: row_element },
                            event
                        );
                    });
                    row_element.addEventListener("mouseout", (ev) => {
                        ev.stopPropagation();
                        currentMouseOverNode.id = null;
                    });
                }
            } else {
                const rowElementClick = (ev) => {
                    if (ev.ctrlKey && multiselect) {
                        if (row_element.classList.contains("is-active")) {
                            row_element.classList.remove("is-active");
                            if (selectedTableRow.element === row_element) {
                                selectedTableRow.nodeData = null;
                                selectedTableRow.element = null;
                            }
                            selectedRows.splice(
                                selectedRows.indexOf(
                                    selectedRows.find(
                                        (el) => el.element == row_element
                                    )
                                ),
                                1
                            );
                        } else {
                            selectedRows.push({
                                element: row_element,
                                data: nodeData,
                            });
                            row_element.classList.add("is-active");
                            if (selectedTableRow.element) {
                                // selectedTableRow.element.classList.remove(
                                //     "is-active"
                                // );
                                const index = selectedRows.findIndex(
                                    ({ element }) =>
                                        selectedTableRow.element === element
                                );
                                if (index < 0) {
                                    selectedRows.push({
                                        element: selectedTableRow.element,
                                        data: selectedTableRow.nodeData,
                                    });
                                }
                                selectedTableRow.nodeData = null;
                                selectedTableRow.element = null;
                            }
                        }
                        return;
                    } else if (multiselect) {
                        selectedRows.forEach(({ element }) =>
                            element.classList.remove("is-active")
                        );
                        selectedRows = [];
                    }
                    if (selectedTableRow.element)
                        selectedTableRow.element.classList.remove("is-active");
                    selectedTableRow.nodeData = nodeData;
                    selectedTableRow.element = row_element;
                    selectedTableRow.element.classList.add("is-active");
                };
                row_element.addEventListener("click", rowElementClick);
                if (props[i].IsGroup && isHierarchycal()) {
                    row_element.addEventListener("dblclick", () => {
                        let treeNode = treeRoot.nodes[nodeData.docid];
                        if (multiselect) {
                            if (selectedTableRow.element)
                                selectedTableRow.element.classList.remove(
                                    "is-active"
                                );
                            selectedTableRow.nodeData = null;
                            selectedTableRow.element = null;
                        }
                        if (treeNode) {
                            treeNode.onSelect(treeNode);
                            treeNode.expand();
                        } else {
                            onSelect({
                                targetClass: nodeData.targetClass,
                                id: nodeData.docid,
                                header: nodeData.header,
                            });
                        }
                    });
                } else {
                    row_element.addEventListener("dblclick", () => {
                        cardFileProps.inModal(
                            multiselect ? [nodeData] : nodeData,
                            cardFileProps.callBackElement
                        );
                    });
                }
            }

            let row_cells = row.getCells();
            for (let i = 0; i < row_cells.length; i++) {
                if (columns_hidden[i])
                    row_cells[i]?.getElement()?.classList.add("is-hidden");
            }
        }

        if (scroll) {
            if (is_unshift) {
                cardFile.deleteRows(segmentLengthDownloaded, false);
            } else {
                cardFile.deleteRows(segmentLengthDownloaded, true);
            } // delete after creations
        }

        return datas;
    };

    cardFile.setBlank = cardFileBlank;
    cardFile.setGroupBlank = (groupBlank) => cardFileGroupBlank(groupBlank);

    // drag&drop +
    let isDraggingStarted = false;
    let isDraggingMove = false;
    let curDragElement = undefined;
    let selectedRows = [];
    let dragElementInfo = html`<p></p>`;
    let dragElement = html`<div class="drag-element">${dragElementInfo}</div>`;

    /**
     *
     * @param {*} target
     * @param {MouseEvent} ev
     */
    let mouseDownHandler = (target, ev) => {
        if (ev.button !== 0) {
            return;
        }
        isDraggingStarted = true;
        if (target.element.classList.contains("is-active")) {
            dragElementInfo.innerText = `Выделенных записей: ${selectedRows.length}`;
        } else {
            dragElementInfo.innerText =
                target.data.Name || target.data.Code || target.data.docid;
            selectedRows.forEach((el) => {
                el.element.classList.remove("is-active");
            });
            selectedRows = [];
            curDragElement = target;
        }
        document.body.addEventListener("mouseup", mouseUpHandler);
        document.body.addEventListener("mousemove", mouseMoveHandler);
    };

    let mouseMoveHandler = (event) => {
        if (isDraggingStarted && !event.ctrlKey) {
            if (!isDraggingMove) {
                isDraggingMove = true;
                clearSelectText();
                draggingElement(dragElement);
                document.body.style.cursor = "grabbing";
            }
            dragElement.style.top = event.clientY + "px";
            dragElement.style.left = event.clientX + "px";
        }
    };

    let mouseUpHandler = (event) => {
        isDraggingStarted = false;
        if (!isDraggingMove) {
            return;
        }

        isDraggingMove = false;
        draggingElement(null);
        document.body.style.cursor = "";
        document.body.removeEventListener("mousemove", mouseMoveHandler);
        document.body.removeEventListener("mouseup", mouseUpHandler);

        if (!currentMouseOverNode?.id) {
            return;
        }
        const destinationId = currentMouseOverNode.id;

        const recordsIds =
            selectedRows.length === 0
                ? [curDragElement.data.docid]
                : selectedRows.map((el) => el.data.docid);

        if (recordsIds.includes(destinationId)) {
            return;
        }

        const confirmModal = ConfirmationModal({
            onConfirm: async () => {
                try {
                    const res = await api.moveHierarchyObject(
                        cardFileProps.targetClass,
                        recordsIds,
                        destinationId
                    );
                    if (res.ok) {
                        cardFile.updateTable();
                        if (
                            currentMouseOverNode.id == -1 ||
                            tree?.root?.id === currentMouseOverNode.id
                        ) {
                            treeRoot.collapse();
                            treeRoot.expand();
                        } else {
                            recordsIds.forEach((id) => {
                                treeRoot.nodes[id]?.getElement()?.remove();
                            });
                            treeRoot.nodes[currentMouseOverNode.id]?.collapse();
                            treeRoot.nodes[currentMouseOverNode.id]?.expand();
                        }
                    }
                } catch (error) {
                    console.error(error);
                } finally {
                    confirmModal.hide();
                }
            },
            onReject: () => confirmModal.hide(),
            confirmButtonText: "Да",
            rejectButtonText: "Нет",
            content: getMoveRecordsMessage(recordsIds),
        });
        confirmModal.show();
    };

    let copyToClipboard = (textToCopy) => {
        // navigator clipboard api needs a secure context (https)
        if (navigator.clipboard && window.isSecureContext) {
            // navigator clipboard api method'
            return navigator.clipboard.writeText(textToCopy);
        } else {
            navigator.clipboard
                .writeText(textToCopy)
                .then(() => {
                    console.log("Succes!");
                })
                .catch((err) => {
                    console.log("Something went wrong", err);
                });
        }
    };

    document.onkeydown = function (evt) {
        evt = evt || window.event;
        let isEscape = false;
        let isCtrlC = false;
        let isEnter = false;
        if ("key" in evt) {
            isEscape = evt.key === "Escape" || evt.key === "Esc";
            isCtrlC =
                (evt.key === "c" && evt.ctrlKey) ||
                (evt.key === "C" && evt.ctrlKey);
            isEnter = evt.key === "Enter" || evt.key == "Ent";
        } else {
            isEscape = evt.keyCode === 27;
            isCtrlC = evt.keyCode === 67 && evt.ctrlKey;
            isEnter = evt.keyCode === 13;
        }
        if (isEscape) {
            deselectRows();
            draggingElement(null);
            document.body.style.cursor = "";
            document.body.removeEventListener("mousemove", mouseMoveHandler);
            document.body.removeEventListener("mouseup", mouseUpHandler);
            isDraggingStarted = false;
            isDraggingMove = false;
        }
        if (isCtrlC) {
            let text = "";
            if (typeof window.getSelection != "undefined") {
                text = window.getSelection().toString();
            } else if (
                typeof document.selection != "undefined" &&
                document.selection.type == "Text"
            ) {
                text = document.selection.createRange().text;
            }
            if (currentClicketCell && text.length == 0) {
                copyToClipboard(currentClicketCell.innerText);
            }
            if (selectedRows.length > 0 && text.length == 0) {
                let allText = "";
                selectedRows.forEach(
                    (row) => (allText += row.element.innerText)
                );
                copyToClipboard(allText);
            }
        }
        if (isEnter && currentClicketRow) {
            if (useQuery) {
                set_query({ id: currentClicketRow.nodeData.docid });
            } else {
                cardFile.viewRecord({
                    docid: currentClicketRow.nodeData.docid,
                });
            }
        }
    };
    // drag&drop -

    // SCROLL EVENT +
    var startBottom = 200;
    var startTop = 1;
    var lastScrollTop = 0;

    const scrollDownValueForDownloadAndPush = 75;
    const scrollUpValueForDownloadAndUnshift = 25;

    const setScrollAfterRollUp = 35;

    var addedToEnd = true;
    var addedToStart = true;

    cardTable.addEventListener("scroll", function (e) {
        let scrollValue = cardTable.scrollTop / (table.offsetHeight / 100);

        if (cardTable.scrollTop > lastScrollTop) {
            // SCROLL DOWN
            if (scrollValue > scrollDownValueForDownloadAndPush) {
                if (addedToEnd) {
                    addedToEnd = false;
                    cardFile.addRowsScroll(startBottom, segmentLength, false);
                }
            }
        } else {
            // SCROLL UP
            if (scrollValue < scrollUpValueForDownloadAndUnshift) {
                if (startTop > 1) {
                    if (addedToStart) {
                        addedToStart = false;
                        cardFile.addRowsScroll(
                            startTop - segmentLength,
                            segmentLength,
                            true
                        );
                    }
                }
            }
        }
        lastScrollTop = cardTable.scrollTop;
    });

    cardFile.addRowsScroll = (start, length, way) =>
        fetchData(
            {
                targetClass: cardFileProps.targetClass,
                id: cardFile.currentNode()?.id,
                order: order() || props.order,
                filter: getFilter(),
                isHierarchycal: isHierarchycal(),
                start: start,
                length: length,
            },
            abortController.signal
        ).then((records) => {
            let rows = [];
            for (let row in records) {
                records[row].targetClass = cardFile.currentNode()?.targetClass;
                records[row].header = cardFile.currentNode()?.header;
                if (!cardFile.currentNode()?.header) {
                    records[row].header = cardFile.currentNode()?.getHeader();
                } else {
                    records[row].header = cardFile.currentNode()?.header;
                }
                rows.push(records[row]);
            }

            segmentLengthDownloaded = rows.length;

            if (way) {
                cardFile.createRows(rows, true, true);
            } else {
                cardFile.createRows(rows, false, true);
            }
        });
    // CROLL EVENT -

    cardFile.deleteRows = (count, direction) => {
        if (direction) {
            for (let i = 0; i < count; i++) table.rowRemoveByKey(0);
            startBottom += count;
            startTop += count;
            addedToEnd = true; // loaded & added segmenets to end
        } else {
            if (count === 0) return;

            let lastItemIndex = table.getRows().length - 1;
            for (let i = lastItemIndex; i >= lastItemIndex - count; i--)
                table.rowRemoveByKey(i);
            startBottom -= count;
            startTop -= count;
            addedToStart = true; // loaded & added segmenets to start
            cardTable.scrollTop =
                (table.offsetHeight / 100) * setScrollAfterRollUp; // scroll to setScrollAfterRollUp (35%)
        }
    };

    cardFile.updateTable = async (props) => {
        loader.show();
        try {
            const records = await fetchData(
                {
                    targetClass: cardFileProps.targetClass,
                    id: cardFile.currentNode()?.id,
                    order: order() || props?.order,
                    filter: getFilter(props?.filter),
                    isHierarchycal: props?.isHierarchycal ?? isHierarchycal(),
                    start: props?.start ?? startTop,
                    length: props?.length || 200,
                    fastFilter: props?.fastFilter,
                },
                abortController.signal
            );
            if (records instanceof Error) throw records;
            let rows = [];
            for (let row in records) {
                records[row].targetClass = cardFile.currentNode()?.targetClass;
                records[row].header = cardFile.currentNode()?.header;
                if (!cardFile.currentNode()?.header) {
                    records[row].header = cardFile.currentNode()?.getHeader();
                } else {
                    records[row].header = cardFile.currentNode()?.header;
                }
                rows.push(records[row]);
            }
            cardFile.clearRows();
            cardFile.createRows(rows);
        } catch (error) {
            console.error(error);
        } finally {
            loader.hide();
        }
    };

    cardFile.setConstOrder = (constOrder) => order(constOrder);
    cardFile.setConstFilter = (filter) => constFilter(filter);

    cardFile.table = table;
    cardFile.tree = tree;
    cardFile.addActions = addActions;
    cardFile.targetClass = props.targetClass;
    cardFile.getBlank = () => blank;
    cardFile.createNewRecord = createNewRecord;
    cardFile.fetchData = fetchData;
    cardFile.setIsHierarchycal = (value) => isHierarchycal(value ?? true);
    // cardFile.addEventListener("contextmenu", (ev) => {
    //     ev.preventDefault();
    //     table.menu_table.menuShow();
    // });

    observe(cardFile);

    cardFile.addEventListener("connected", async () => {
        try {
            const result = await api.getFiltersList({
                targetClass: cardFileProps.targetClass,
            });
            if (result.isOk) {
                recordStructure(Array.isArray(result.data) ? result.data : []);
            }

            if (initTree) {
                treeRoot = tree.getRoot();
                treeRoot.expand();
            } else {
                cardFile.updateTable();
            }
            document.addEventListener("keyup", onKeyUp);
        } catch (error) {
            console.error(error);
        }
    });

    cardFile.addEventListener("disconnected", (ev) => {
        ev?.stopPropagation?.();
        abortController.abort();
        abortController = new AbortController();
        cardFile.hideBlank();
        document.removeEventListener("keyup", onKeyUp);
    });

    /**
     *
     * @param {KeyboardEvent} ev
     */
    function onKeyUp(ev) {
        if (
            (ev.key === "Delete" || ev.code === "Delete") &&
            !cardFileProps.inModal
        ) {
            confirmDeletion();
        }
        filterOnShortCut(ev);
    }

    /**
     *
     * @param {KeyboardEvent} ev
     */
    function filterOnShortCut(ev) {
        if (
            !ev.ctrlKey ||
            !ev.shiftKey ||
            (ev.key !== "F" && ev.code !== "KeyF")
        ) {
            return;
        }
        if (modal.shown) {
            return;
        }
        ev.preventDefault();
        modal.setContent(filterElement);
        modal.show();
    }

    /**
     *
     * @param {KeyboardEvent} ev
     */
    function confirmDeletion() {
        if (!selectedRows || selectedRows.length === 0) return;
        const correctMessage = (amount) => {
            if (amount % 100 > 10 && amount % 100 < 20) {
                return `${amount} записей`;
            }
            switch (amount % 10) {
                case 1:
                    return `${amount} запись`;
                case 2:
                case 3:
                case 4:
                    return `${amount} записи`;
                default:
                    return `${amount} записей`;
            }
        };
        const text = `Удалить ${correctMessage(selectedRows.length)}?`;
        const confirmationModal = ConfirmationModal({
            content: text,
            confirmButtonText: "Да",
            rejectButtonText: "Нет",
            onConfirm,
            onReject,
        });

        async function onConfirm() {
            loader.show();
            try {
                await deleteSelectedRows();
            } catch (error) {
                console.error(error);
            } finally {
                loader.hide();
                confirmationModal.hide();
                cardFile.updateTable();
            }
        }
        async function onReject() {
            deselectRows();
            confirmationModal.hide();
        }

        confirmationModal.show();
    }
    function deselectRows() {
        if (selectedRows.length === 0) return;
        selectedRows.forEach((el) => {
            el.element.classList.remove("is-active");
        });
        selectedRows = [];
    }
    async function deleteSelectedRows() {
        const results = await Promise.all(
            selectedRows
                .map((r) => r.data)
                .map((d) => api.deleteRecord(d.targetClass, d.docid))
        );
        for (let i = 0; i < results.length; i++) {
            const row = selectedRows[i];
            treeRoot?.nodes[row.data.docid]?.getElement()?.remove();
        }
    }

    function getFilter(...filters) {
        filters.push(
            filter(),
            constFilter(),
            initialFilter,
            initialConstFilter
        );
        return filters
            .filter((f) => !!f)
            .filter((f, i, arr) => arr.indexOf(f) === i)
            .join(" and ");
    }

    function restoreDefaultSize(ev) {
        ev.stopPropagation();
        cardFileSettingsManager.removeByKey(props?.targetClass);
        location.reload();
    }

    return cardFile;
};

const getMoveRecordsMessage = (records = []) => {
    const rCount = records.length;
    let recordsMessage = "";
    if (rCount % 100 >= 10 && rCount % 100 <= 20) {
        recordsMessage = "записей";
    } else {
        switch (rCount % 10) {
            case 1: {
                recordsMessage = "запись";
                break;
            }
            case 2:
            case 3:
            case 4: {
                recordsMessage = "записи";
                break;
            }
            default: {
                recordsMessage = "записей";
            }
        }
    }
    return `Переместить ${rCount} ${recordsMessage}?`;
};

// import { map } from "@sinuous/map.js";

const Badge = (
    { count: c, classNames, class: className, theme, ...rest },
    ...children
) => {
    const count = getObservable(c);
    const displayCount = computed(() =>
        count() != null && !isNaN(count())
            ? count() >= 100
                ? "99+"
                : count()
            : null
    );
    const element = html`<span
        ...${rest}
        class="badge${classNames?.join?.(" ") ?? ""} ${className ?? ""}${theme
            ? ` badge--${theme}`
            : ""}"
        >${displayCount}${children}</span
    >`;
    element.setCount = (c) => count(c);
    element.getCount = () => count();
    return element;
};

const Comment = (props) => {
    const { comment, currentUser } = props;
    const commentElement = html`<${ListItem}
        className="comment${comment.Sys
            ? " system"
            : comment.Persona.docid === currentUser.docid
            ? " is-self"
            : ""}"
    >
        <div class="comment-inner">
            <p class="comment-text">
                ${comment.Comment?.split(/\n/).map((c, i, arr) =>
                    arr.length - 1 > i ? html`${c}<br />` : c
                )}
            </p>
            <div class="comment-info">
                <p class="comment-author">${comment.Persona.Name}</p>
                <p class="comment-date">${comment.DateComment}</p>
            </div>
        </div>
    <//>`;
    return commentElement;
};

const CommentsList = (props) => {
    const { comments, currentUser } = props;
    const commentsList = html`<${List} className="comments"
        >${map(comments, (comment) => Comment({ comment, currentUser }))}
    <//>`;

    commentsList.scrollToBottom = () =>
        commentsList.scroll({ top: commentsList.scrollHeight });

    observe(commentsList);

    commentsList.addEventListener("connected", () =>
        commentsList.scrollToBottom()
    );
    return commentsList;
};

class Model$2 {
    constructor(params) {
        const { comments, docid, targetClass } = params;
        this.comments = getObservable(comments ?? []);
        this.record = {
            docid,
            targetClass,
        };
        this.currentUser = {
            docid: getUserId(),
            Name: getUserName(),
        };
        this.newComment = o("");
    }

    addNewComment(newComment) {
        const comments = this.comments();
        comments.push({
            Comment: newComment,
            Persona: this.currentUser,
            DateComment: DateTime.now().toFormat(defaultFormats.DATE_FULL_TIME),
        });
        this.comments(comments);
    }
}

/**
 *
 *
 * @param {{ model: Model }} { model }
 * @return {*}
 */
const View$5 = ({ model, onChange, onSendMessage }) => {
    const input = Field({
        type: "textarea",
        value: model.newComment,
        rowsCount: 1,
        placeholder: "Введите комментарий...",
        onChange,
        key: "newComment",
        classNames: ["comment-input"],
    });
    const sendBtn = Button({
        text: Icon({ name: "send" }),
        className: "--circle",
        disabled: !model.record.docid,
        onClick: onSendMessage,
    });
    const commentsList = CommentsList({
        comments: model.comments,
        currentUser: model.currentUser,
    });

    const commentsActivity = html`<div class="comments-activity">
        <h3>Комментарии</h3>
        ${commentsList}
        <div class="comments-activity-control">${input}${sendBtn}</div>
    </div>`;
    return { commentsActivity, commentsList };
};

const CommentsActivity = ({ model: m, Model: M, view: V, onCommentSent, ...params }) => {
    /**@type {Model} */
    const model = m ?? new (M ?? Model$2)(params);
    const { commentsActivity, commentsList } = (V ?? View$5)({
        ...params,
        model,
        onChange: handleInputChange,
        onSendMessage: handleSendComment,
    });

    function handleInputChange({ value }) {
        model.newComment(value);
    }
    async function handleSendComment() {
        await addNewComment(model.newComment());
        await onCommentSent?.({comment: model.newComment()});
        model.newComment("");
    }

    async function addNewComment (comment) {
        if (!comment) return;
        const { targetClass, docid } = model.record;

        await newComment(targetClass, docid, comment);

        model.addNewComment(comment);
        commentsList.scrollToBottom();

        if (params?.onCreate) {
            params?.onCreate();
        }
    }
    commentsActivity.getValue = () => params?.comments || [];
    commentsActivity.setValue = async (comments) => {
        model.comments(comments);
    };

    commentsActivity.addNewComment = addNewComment;

    return commentsActivity;
};

CommentsActivity.Model = Model$2;
CommentsActivity.View = View$5;

observe(".textarea-auto-grow");

/**@typedef {"saml"|"oauth2"} SupportedSSO*/

/**
 * @typedef WindowSize
 * @prop {number} width
 * @prop {number} height
 */

/**
 * @typedef UserAuthorized
 * @prop name
 * @prop docid
 * @prop roles
 * @prop [token]
 */

/**
 * @callback onAuthCallback
 * @param {UserAuthorized} user
 * @returns {void}
 */

/**
 * @typedef Params
 * @prop {onAuthCallback} onAuth
 * @prop {string} [url] - default api url
 * @prop {SupportedSSO} [type] - default saml
 * @prop {WindowSize} [size] - default w:400/h:800
 * @prop {string[]} [additionalDetailsToSave]
 * @prop {string | () => string} [class]
 */

/**
 *
 * @param {Params} props
 * @param  {...any} content
 * @returns {HTMLButtonElement}
 */

const SSOButton = (props, ...content) => {
    const {
        url: fullUrl = getUrl(),
        type = "saml",
        size = { width: 400, height: 800 },
        additionalDetailsToSave,
        onAuth,
        class: classes,
        ssoPath = "/api/sso",
        ...rest
    } = props;

    const url = new URL(fullUrl);
    const className = mergeClasses("sso-button", classes);

    const fetchUserInfo = async () => {
        const result = await fetch(url.origin + `${ssoPath}/auth`, {
            method: "GET",
            credentials: "include",
        });
        if (result.ok) {
            const user = await result.json();

            const { docid, name, roles, token, ...other } = user;

            saveUserId(docid);
            saveUserName(name);
            saveRoles(roles);
            saveToken(isUsingHeaders() ? token : "Success");

            Object.keys(other).forEach((key) => {
                if (additionalDetailsToSave.includes(key))
                    localStorage.setItem(key, other[key]);
            });

            onAuth?.(user);
        } else {
            if (!result.bodyUsed) {
                const text = await result.text();
                if (text) {
                    Message$1(text, "error");
                }
            }
            onAuth?.(null);
        }
    };
    const handleClick = () => {
        const newWindow = window.open(
            url.origin + `${ssoPath}/${type}/login`,
            "_blank",
            Object.entries(size)
                .map(([key, value]) => `${key}=${value}`)
                .join(",")
        );
        const interval = setInterval(() => {
            if (!newWindow.closed) return;
            fetchUserInfo();
            clearInterval(interval);
        }, 250);
    };

    const element = html`
        <${Button} ...${rest} onClick=${handleClick} class=${className}>
            ${content}
        <//>
    `;

    return element;
};

const HelpTooltip = (props) => {
    /**@type {HTMLDivElement} */
    const modalContent = html`<div
        class="help-tooltip"
        onconnected=${onConnected}
        ondisconnected=${onDisconnected}
        onmousedown=${onMouseDown}
        style="top: ${props.rect.top}px; left: ${props.rect.right}px"
    >
        <div class="help__content">
            <span class="help__label">Выбрано: </span>
            <span class="help__value">
                ${FORMATTERS.default.format(props.count)}
            </span>
            <span class="help__label">Среднее: </span>
            <span class="help__value">
                ${FORMATTERS.default.format(props.average)}
            </span>
            <span class="help__label">Сумма: </span>
            <span class="help__value">
                ${FORMATTERS.default.format(props.sum)}
            </span>
        </div>
    </div>`;

    observe(modalContent);

    function onConnected() {
        document.addEventListener("mousedown", hideTooltip, {
            once: true,
        });
        document.addEventListener("scroll", hideTooltip, {
            once: true,
            capture: true,
        });
        modalContent.style.top = `${
            props.rect.top +
            props.rect.height / 2 -
            modalContent.clientHeight / 2
        }px`;
    }

    function hideTooltip() {
        modalContent.remove();
    }
    function onDisconnected(ev) {
        // console.log("disconnected", ev, ev.target);
    }

    function onMouseDown(ev) {
        ev.stopPropagation();
    }
    return modalContent;
};

class ShortCut {
    constructor(arrKeys) {
        this.keys = new Set(arrKeys ?? []);
    }

    /**
     *
     * @param {ShortCut} shortcut
     */
    contains(shortcut) {
        if (shortcut.keys.size > this.keys.size) return false;
        for (const key of shortcut.keys.values()) {
            if (!this.keys.has(key)) {
                return false;
            }
        }

        return true;
    }

    /**
     *
     * @param {ShortCut} shortcut
     */
    isEqualtTo(shortcut) {
        if (shortcut.keys.size !== this.keys.size) return false;
        for (const key of shortcut.keys.values()) {
            if (!this.keys.has(key)) {
                return false;
            }
        }
        return true;
    }
}

const SHORTCUTS = {
    CTRL_K_Z: new ShortCut(["controlleft", "keyk", "keyz"]),
};

const globalShortcut = new ShortCut();

function onCtrlKZShortCut() {
    const selection = window.getSelection();
    if (!selection) return;
    const selectedValues = selection
        .toString()
        .split("\n")
        .map((str) => str.replaceAll(",", "."))
        .map((str) => {
            return str.replaceAll(/([^\d.-])/g, "");
        })
        .filter(str => !!str)
        .map(Number)
        .filter(value => !isNaN(value))
        .filter(value => isFinite(value));
    if (selectedValues.length === 0) return false;

    const selectionRect = selection.getRangeAt(0).getBoundingClientRect();
    const sum = selectedValues.reduce((acc, value) => acc + value, 0);
    const average = sum / selectedValues.length;
    const count = selectedValues.length;

    const prevTooltip = qs(".help-tooltip", document.body);
    prevTooltip?.remove();

    document.body.appendChild(
        HelpTooltip({ sum, count, average, rect: selectionRect })
    );
}

/**
 *
 * @param {KeyboardEvent} ev
 */
function onKeyDown(ev) {
    const containsKey = Object.values(SHORTCUTS).findIndex((sc) =>
        sc.keys.has(ev.code?.toLowerCase())
    );
    if (containsKey >= 0) {
        globalShortcut.keys.add(ev.code.toLowerCase());
    } else {
        globalShortcut.keys.clear();
        return;
    }

    if (SHORTCUTS.CTRL_K_Z.contains(globalShortcut) && ev.ctrlKey ) {
        if (!globalShortcut.keys.has("controlleft")) {
            globalShortcut.keys.add("controlleft");
        }
        ev.preventDefault();
    }
}

function onKeyUp(ev) {
    if (globalShortcut.isEqualtTo(SHORTCUTS.CTRL_K_Z)) {
        ev.preventDefault();
        onCtrlKZShortCut();
        globalShortcut.keys.clear();
    }

    globalShortcut.keys.delete(ev.key?.toLowerCase());
}

window.addEventListener("keydown", onKeyDown);
window.addEventListener("keyup", onKeyUp);

HTMLElement.prototype.addLongTouchListener = function (callback, options) {
    const { delay = 250 } = options ?? {};
    let timer;
    function onTouchStart(ev) {
        if (!timer) {
            const longPressEvent = new TouchEvent("long-touch", ev);
            timer = setTimeout(() => this.dispatchEvent(longPressEvent), delay);
        }
    }
    function onTouchEnd(ev) {
        if (timer) {
            clearTimeout(timer);
            timer = null;
        }
    }

    function onLongTouch(ev) {
        clearTimeout(timer);
        timer = null;
        callback(ev);
    }

    this.addEventListener("touchstart", onTouchStart);
    this.addEventListener("touchend", onTouchEnd);
    this.addEventListener("touchcancel", onTouchEnd);
    this.addEventListener("long-touch", onLongTouch);
};

const PROJECT_KEY$1 = "PROJECT_KEY";
const DEFAULT_MESSAGES$1 = {
    201: "Успешно выполнено",
    500: "Ошибка на сервере. Повторите попытку позднее",
    400: "Неправильный запрос",
    404: "Ничего не найдено",
    401: "Пользователь не прошел авторизацию",
};
const DEFAULT_ERROR_MESSAGES = {
    UNKNOWN_ERROR: "Неизвестная ошибка",
};

/**
 * @typedef Result
 * @prop { object? } data
 * @prop { string? } message
 * @prop { Error? } error
 * @prop { boolean } isOk
 * @prop { () => object? } json
 * @prop { () => string? } text
 */

/**
 *
 * @param {Result} result
 */
const showError = (result) => {
    const params = ["error"];
    const errorName = result.error.name;

    if (errorName === "AbortError") return;

    if (errorName in DEFAULT_ERROR_MESSAGES) {
        params.unshift(DEFAULT_ERROR_MESSAGES[errorName]);
    } else {
        params.unshift(DEFAULT_ERROR_MESSAGES.UNKNOWN_ERROR);
    }

    Message$1(...params);
};

class Api {
    constructor(url) {
        this.baseUrl = url;
        this.useAuthToken = true;
        this.project = null;
    }
    isUsingAuthToken() {
        return this.useAuthToken;
    }
    disableUseAuthToken() {
        this.useAuthToken = false;
    }
    setUrl(url) {
        this.baseUrl = url;
    }
    createRequestParams(params) {
        const { signal, method = "POST" } = params ?? {};

        let { body: payload } = params ?? {};

        const webUser = getUserId();
        const role = getCurrentRole();
        const headers = new Headers();

        if (payload == null) payload = {};

        if (webUser) {
            payload = { ...payload, webUser, role };
        }

        if (this.useAuthToken) {
            headers.append("authorization", getToken());
            headers.append("Content-Type", "application/json");
        }

        if (this.project) {
            headers.append(PROJECT_KEY$1, this.project);
            payload[PROJECT_KEY$1] = this.project;
        }

        const requestParams = {
            method,
            body: JSON.stringify(payload),
            signal,
            headers,
        };

        return requestParams;
    }
    async executeQuery(query, params) {
        const { showErrors, showMessage, messageType } = params;
        const requestParams = this.createRequestParams(params);

        try {
            const response = await fetch(
                `${this.baseUrl}${query}`,
                requestParams
            );
            // if (response.ok) {
            if (response.status === 200) {
                return this.createResult({
                    isOk: response.ok,
                    data: await response.json(),
                    status: response.status,
                });
            }
            const result = this.createResult({
                isOk: response.ok,
                message: await response.text(),
                status: response.status,
            });

            this.showQueryMessage({
                response: result,
                showErrors,
                showMessage,
                type: result.status >= 400 ? "error" : messageType,
            });

            return result;
            // }
        } catch (error) {
            console.log(error);
            const result = this.createResult({ isOk: false, error });
            this.handleError({ result, showErrors });
            return result;
        }
    }

    handleError({ result, showErrors }) {
        if (showErrors) {
            showError(result);
        }
    }

    showQueryMessage(params) {
        const {
            showErrors,
            showMessage,
            response,
            defaultMessage,
            type = "info",
        } = params;
        if (response.isOk && !showMessage) return;
        if (!response.isOk && !showErrors) return;

        let message =
            response.message ??
            defaultMessage ??
            DEFAULT_MESSAGES$1[response.status];

        if (message == null && !response.isOk) {
            message = DEFAULT_ERROR_MESSAGES.UNKNOWN_ERROR;
        }

        if (message == null) return;

        Message$1(message, type);
    }

    setProject(project) {
        this.project = project;
    }

    createResult({
        error = null,
        data = null,
        isOk,
        message = null,
        status = null,
    }) {
        return {
            error,
            isOk,
            data,
            message,
            status,
            json() {
                return this.data;
            },
            text() {
                return this.message;
            },
        };
    }
}

const api$2 = new Api();
api$2.executeQuery.bind(api$2);
api$2.showQueryMessage.bind(api$2);
api$2.setUrl.bind(api$2);
api$2.disableUseAuthToken.bind(api$2);
api$2.setProject.bind(api$2);

// import { getUserId } from "Core/utils/index.js";

const DEFAULT_MESSAGES = {
    401: "Пользователь не авторизован",
    404: "Ничего не найдено",
    400: "Неправильный запрос",
    500: "Ошибка на сервере. Повторите попытку",
    201: "Успешно выполнено",
};

const getMessageType = (response, type = "info") =>
    response.status >= 400 ? "error" : type;
class API {
    constructor() {
        this.url = "https://localhost:8080/PortalTB/";
        this.useHeaders = true;
        this.projectKey = null;
        this.passportJs = false;
    }

    async executeQuery(
        query,
        {
            body = undefined,
            signal = undefined,
            method = "POST",
            showErrors = true,
            showMessage = false,
            messageType = "info",
        } = {}
    ) {
        body = {
            ...(body ?? {}),
            webUser: Number(getUserId()),
            role: Number(getCurrentRole()),
        };
        if (this.projectKey) {
            body.PROJECT_KEY = this.projectKey;
        }

        const headers = new Headers();
        if (localStorage.token) {
            headers.append("authorization", localStorage.token ?? "");
        }
        headers.append("Content-Type", "application/json");

        const requestProperties = {
            method,
            body: JSON.stringify(body),
            signal,
            credentials: this.isUsingPassportJs() ? "include" : undefined,
            headers: this.useHeaders ? headers : undefined,
        };

        /**@type {Response} */
        let response;
        try {
            response = await fetch(this.url + query, requestProperties);

            const newToken = response.headers.get("Up-To");
            let timestamp = Number(response.headers.get("To-Time"));

            timestamp = isNaN(timestamp) ? 0 : timestamp;

            if (isLoggedIn() && newToken && timestamp > getTokenTimestamp()) {
                saveToken(newToken, timestamp);
            }
        } catch (error) {
            // console.error(error);
            if (error.name === "AbortError") return;
            showQueryMessage({
                showErrors,
                showMessage,
                defaultMessage: "Нет соединения с сервером",
                type: "error",
            });
            return;
        }

        if (response.status === 401) {
            const type = getMessageType(response, messageType);
            const defaultMessage = DEFAULT_MESSAGES[response.status];

            if (isLoggedIn()) {
                location.href = "#logout";
                showQueryMessage({
                    type,
                    defaultMessage,
                    response,
                    showErrors,
                    showMessage,
                });
            } else if (["user/auth", "auth"].includes(query)) {
                showQueryMessage({
                    type,
                    defaultMessage,
                    response,
                    showErrors,
                    showMessage,
                });
            }

            return response;
        }

        if (response.status >= 400 || response.status === 201) {
            const defaultMessage =
                DEFAULT_MESSAGES[response.status] ?? "Неизвестная ошибка";
            const type = getMessageType(response, messageType);

            if (response.status === 201) {
                showMessage = true;
            }

            showQueryMessage({
                type,
                defaultMessage,
                response,
                showErrors,
                showMessage,
            });
        }

        return response;
    }

    /**
     * @param {{response: Response}} props*/
    async showQueryMessage(props) {
        const {
            showMessage = false,
            showErrors = true,
            response,
            defaultMessage,
            type = "info",
        } = props;
        if (!showErrors) return;

        let responseTxt;
        try {
            responseTxt = await response?.text?.();
        } catch (error) {
            console.error(error);
        }

        const message = responseTxt ?? defaultMessage;
        if (message == null) return;

        (type === "error" ? showErrors : showMessage) && Message$1(message, type);
    }

    setUrl(newUrl) {
        this.url = newUrl;
        api$2.setUrl(newUrl);
    }

    getUrl() {
        return this.url;
    }

    setProjectKey(key) {
        this.projectKey = key;
        api$2.setProject(key);
    }

    disableUsingHeaders() {
        this.useHeaders = false;
        api$2.disableUseAuthToken();
    }

    usePassportJs(value = true) {
        this.passportJs = value;
    }

    isUsingPassportJs() {
        return this.passportJs;
    }
}
const api$1 = new API();

const executeQuery = api$1.executeQuery.bind(api$1);
const showQueryMessage = api$1.showQueryMessage.bind(api$1);
const setUrl = api$1.setUrl.bind(api$1);
const disableUsingHeaders = api$1.disableUsingHeaders.bind(api$1);
api$1.setProjectKey.bind(api$1);
const isUsingHeaders = () => api$1.useHeaders;
const usePassportJs = api$1.usePassportJs.bind(api$1);
const isUsingPassportJs = api$1.isUsingPassportJs.bind(api$1);
const getUrl = api$1.getUrl.bind(api$1);
const setup$1 = ({ url, domain, passportjs }) => {
    setUrl(url);
    if (passportjs) {
        usePassportJs(true);
        return;
    }
    if (domain) {
        return;
    }
    disableUsingHeaders();
};

const getHierarchyLevel = (props, signal, options = {}) => {
    //(targetClass, id, order, filter, isHierarchycal)
    const body = {
        targetClass: props.targetClass,
        id: props?.id,
        order: props?.order,
        filter: props?.filter,
        isHierarchycal: props?.isHierarchycal,
        start: props?.start,
        length: props?.length,
        fastFilter: props?.fastFilter,
    };
    return executeQuery("getHierarchyLevel", { ...options, body, signal })
        .then((res) => {
            if (res?.status == 204) return {};
            return res.json();
        })
        .catch((error) => error);
};

const getCardFileTree = (
    {
        targetClass,
        id,
        order,
        filter,
        isHierarchycal,
        start,
        length,
        fastFilter,
    } = {},
    signal,
    options = {}
) => {
    //(targetClass, id, order, filter, isHierarchycal)
    const body = {
        targetClass,
        id,
        order,
        filter,
        isHierarchycal,
        start,
        length,
        fastFilter,
    };
    return executeQuery("getTree", { ...options, body, signal })
        .then((res) => res.json())
        .catch((error) => error);
};

function deleteRecord(targetClass, docid, signal, options = {}) {
    let body = {
        targetClass,
        docid,
    };
    return executeQuery("deleteRecord", {
        body,
        showMessage: true,
        signal,
        ...options,
    })
        .then((res) => !res.bodyUsed && res.json())
        .catch((error) => {
            return error;
        });
}

function duplicateRecord(targetClass, docid, signal, options = {}) {
    let body = {
        targetClass,
        docid,
    };
    return executeQuery("duplicateRecord", { body, signal, ...options })
        .then((res) => res.json())
        .catch((error) => {
            return error;
        });
}

function moveHierarchyObject(
    targetClass,
    id_objects,
    id_to,
    signal,
    options = {}
) {
    const body = {
        targetClass,
        id_objects,
        id_to,
    };
    return executeQuery("moveHierarchyObject", { body, signal, ...options });
}

async function getRecord$1(targetClass, docid, signal, options = {}) {
    let body = {
        targetClass,
        docid,
    };
    return executeQuery("GetRecord", { body, signal, ...options })
        .then((res) => res.json())
        .catch((error) => {
            return error;
        });
}

async function getRecordByCurFilter({
    targetClass,
    filter,
    showErrors = true,
}) {
    let body = {
        targetClass,
        filter,
    };

    return executeQuery("GetRecordByCurFilter", { body, showErrors })
        .then((res) => res.json())
        .catch((error) => {
            error.reqParams = body;
            return error;
        });
}

async function getRecordsByCurFilter({
    targetClass,
    filter,
    showErrors = true,
}) {
    let body = {
        targetClass,
        filter,
    };

    return executeQuery("GetRecordsByCurFilter", { body, showErrors })
        .then((res) => res.json())
        .catch((error) => {
            error.reqParams = body;
            return error;
        });
}

function deleteRecordsInGroup(targetClass, docid, signal, options = {}) {
    let body = {
        targetClass,
        docid,
    };

    return executeQuery("deleteRecordsInGroup", { body, signal, ...options })
        .then((res) => res.json())
        .catch((error) => {
            return error;
        });
}

async function createOrUpdateRecord(
    targetClass,
    recordBody,
    signal,
    options = {}
) {
    let body = {
        targetClass,
        body: recordBody,
    };

    return executeQuery("createOrUpdateRecord", { body, signal, ...options })
        .then(async (res) => {
            if (!res) return { isOk: false, data: {} };
            return { isOk: res.ok, data: await res.json() };
        })
        .catch((error) => {
            return { isOk: false, data: error };
        });
}

function newComment(targetClass, docid, comment, signal, options = {}) {
    const body = {
        targetClass,
        docid,
        userId: +getUserId(),
        comment,
    };
    return executeQuery("newComment", { body, signal, ...options })
        .then((res) => res?.json())
        .catch((error) => error);
}

async function authorization(
    login,
    password,
    additionalDetailsToSave = [],
    signal,
    options = {}
) {
    let user = {
        login,
        password,
    };

    const query = isUsingHeaders() ? "user/auth" : "auth";

    const response = await executeQuery(query, {
        body: user,
        signal,
        ...options,
    });
    if (response?.ok) {
        let result = await response.json();

        const { docid, name, roles, token, ...other } = result;

        saveUserId(docid);
        saveUserName(name);
        saveRoles(roles);
        saveToken(isUsingHeaders() ? token : "Success");

        Object.keys(other).forEach((key) => {
            if (additionalDetailsToSave.includes(key))
                localStorage.setItem(key, other[key]);
        });

        //;

        return result;
    }
}

function getInterface(roleId, signal, options = {}) {
    let body = {
        docid: roleId,
    };
    return executeQuery("getInterface", {
        body,
        signal,
        ...options,
    })
        .then((res) => res.json())
        .catch((error) => {
            console.error(error);
            return error;
        });
}

async function rejectDocument(targetClass, data, signal, options = {}) {
    let body = {
        webUser: +getUserId(),
        targetClass,
        body: data,
    };

    const response = await executeQuery("rejectDocument", {
        body,
        signal,
        ...options,
    });

    let json;
    let error;
    if (!response.ok) {
        response.text().then((it) => (error = it));
    }

    return { response, json, error };
}

async function confirmDocument(targetClass, data, signal, options = {}) {
    const body = {
        webUser: +getUserId(),
        targetClass,
    };

    if (typeof data === "object") {
        body.body = data;
        body.docid = data.docid;
    } else if (!isNaN(Number(data)) && Number(data) > 0) {
        body.docid = data;
    }

    const response = await executeQuery("confirmDocument", {
        body,
        signal,
        ...options,
    });

    let json;
    let error;
    if (!response.ok) {
        response.text().then((it) => (error = it));
    }

    return { response, json, error };
}

function excelUpload(
    filename,
    data,
    objectForImport,
    bu,
    signal,
    options = {}
) {
    let body = {
        bu,
        filename,
        data,
        webUser: +getUserId(),
        objectForImport,
    };
    return executeQuery("newDataForImport", { body, signal, options })
        .then((res) => res.json())
        .catch((error) => {
            return error;
        });
}

// Работа с файлами.
function getFilesList({ docid, targetClass }, signal, options = {}) {
    // Возвращает список прикрепленных файлов к докуенту/справочнику
    const body = {
        docid,
        targetClass,
    };

    return executeQuery("getFileList", { ...options, signal, body })
        .then(async (res) => ({ isOk: res.ok, data: await res.json() }))
        .catch((error) => ({ isOk: false, error }));
}

function getFile(docid, signal, options) {
    return executeQuery("getFile", { ...options, body: { docid }, signal })
        .then((res) => res.json())
        .catch((error) => error);
}

function uploadFile(
    { name, data, additional = {} },
    signal,
    options = {}
) {
    const body = {
        name,
        data,
        ...additional,
    };

    return executeQuery("uploadFile", { ...options, body, signal })
        .then(async (res) => {
            if (res.bodyUsed) return { isOk: false };
            return {
                isOk: res.ok,
                data: await res.json(),
            };
        })
        .catch((error) => {
            error.requestParams = body;
            return { isOk: false, error };
        });
}

function deleteFile({ docid, ...rest }, signal, options = {}) {
    const body = {
        ...rest,
        docid,
    };
    return executeQuery("deleteFile", { ...options, body, signal })
        .then(async (res) => {
            if (res.bodyUsed) return { isOk: false };
            return { isOk: res.ok, data: await res.json() };
        })
        .catch((error) => {
            error.requestParams = body;
            return { isOk: false, error };
        });
}

async function getRecordStructure({ targetClass }, signal, options) {
    const body = { targetClass };
    try {
        const response = await executeQuery("getRecordStructure", {
            body,
            signal,
            ...options,
        });
        if (response.bodyUsed) return { isOk: false };
        const { data } = (await response.json()) ?? {};
        return { isOk: response.ok, data: data };
    } catch (error) {
        error.requestParams = body;
        return { isOk: false, error };
    }
}

async function getRightsForRole({ targetClass }, signal, options) {
    const body = { targetClass };
    try {
        const response = await executeQuery("getRightsForRole", {
            body,
            showErrors: false,
            signal,
            ...options,
        });
        if (response.bodyUsed) throw EvalError("body required");
        return { isOk: response.ok, data: await response.json() };
    } catch (error) {
        error.requestParams = body;
        return { isOk: false, error, params: body };
    }
}
// express session
async function logoutSession() {
    try {
        const response = await executeQuery("logout", {
            showErrors: false,
            showMessage: false,
        });
        return { isOk: response.ok };
    } catch (error) {
        return { isOk: false, error };
    }
}

var api = {
    newComment,
    getHierarchyLevel,
    deleteRecord,
    duplicateRecord,
    moveHierarchyObject,
    getRecord: getRecord$1,
    getRecordByCurFilter,
    getRecordsByCurFilter,
    createOrUpdateRecord,
    deleteRecordsInGroup,
    authorization,
    getInterface,
    getFile,
    excelUpload,
    confirmDocument,
    rejectDocument,
    uploadFile,
    getCardFileTree,
    getFiltersList: getRecordStructure,
    getRightsForRole,
    logoutSession,
};

const TOKEN_KEY = "token";
const TOKEN_TIMESTAMP_KEY = "ttime";
const USER_ID_KEY = "userId";
const USER_NAME_KEY = "userName";
const CURRENT_ROLE_KEY = "role";
const ROLES_KEY = "roles";

const saveToken = (token, timestamp) => {
    localStorageService.set(TOKEN_KEY, token);
    localStorageService.set(TOKEN_TIMESTAMP_KEY, timestamp);
};
const getToken = () => localStorageService.get(TOKEN_KEY);
const getTokenTimestamp = () => {
    const ms = Number(localStorageService.get(TOKEN_TIMESTAMP_KEY));
    if (!ms || isNaN(ms)) return null;
    return ms;
};

const isLoggedIn = () => getToken() != null;

const saveUserId = (id) => localStorageService.set(USER_ID_KEY, id);
const getUserId = () => {
    const userId = Number(localStorageService.get(USER_ID_KEY));
    return isNaN(userId) ? null : userId;
};
// const getUserId = () => localStorageService.get(USER_ID_KEY);

const saveUserName = (name) => localStorageService.set(USER_NAME_KEY, name);
const getUserName = () => localStorageService.get(USER_NAME_KEY);

const getCurrentRole = () => {
    const role = Number(localStorageService.get(CURRENT_ROLE_KEY));
    return isNaN(role) ? null : role;
};

const saveRoles = (roles = []) =>
    localStorageService.set(ROLES_KEY, JSON.stringify(roles));

const logIn = (/* _user, _password, _role */) => saveToken("Success");

const logOut = () => {
    [
        USER_ID_KEY,
        USER_NAME_KEY,
        CURRENT_ROLE_KEY,
        ROLES_KEY,
        TOKEN_KEY,
    ].forEach((key) => localStorageService.remove(key));
    if (isUsingPassportJs()) {
        return logoutSession();
    }
};

const HELP = {
    3: /^(?<g>[\da-fA-F]{1})(?<r>[\da-fA-F]{2})$/,
    4: /^(?<g>[\da-fA-F]{2})(?<r>[\da-fA-F]{2})$/,
    5: /^(?<b>[\da-fA-F]{1})(?<g>[\da-fA-F]{2})(?<r>[\da-fA-F]{2})$/,
    6: /^(?<b>[\da-fA-F]{2})(?<g>[\da-fA-F]{2})(?<r>[\da-fA-F]{2})$/,
    hex: /^#(?<r>[\da-fA-F]{2})(?<g>[\da-fA-F]{2})(?<b>[\da-fA-F]{2})$/,
    hexShort: /^#(?<r>[\da-fA-F]{1})(?<g>[\da-fA-F]{1})(?<b>[\da-fA-F]{1})$/,
};

const turboColorToHtml = (tc) => {
    if (typeof tc === "string") {
        const asNumber = Number(tc);
        if (isNaN(asNumber)) return null;
        tc = asNumber;
    }
    /**@type {string} */
    const hex = tc.toString(16);
    switch (hex.length) {
        case 1:
            return `#${hex}00000`;
        case 2:
            return `#${hex}0000`;
        case 3:
            return `#${hex.replace(HELP[hex.length], "$2$1")}000`;
        case 4:
            return `#${hex.replace(HELP[hex.length], "$2$1")}00`;
        case 5:
            return `#${hex.replace(HELP[hex.length], "$3$2$1")}0`;
        case 6:
            return `#${hex.replace(HELP[hex.length], "$3$2$1")}`;
    }
};

function rgbColorIsLight(r, g, b) {
    // Counting the perceptive luminance
    // human eye favors green color...
    const a = 1 - (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    return a < 0.5;
}

/**
 *
 * @param {String} hexColor
 */
function hexColorIsLight(hexColor) {
    const isHex = HELP.hex.test(hexColor);
    const isShorHex = HELP.hexShort.test(hexColor);
    if (!(isHex || isShorHex)) {
        throw new Error("Not correct colour");
    }
    let { r, g, b } = isHex
        ? HELP.hex.exec(hexColor).groups
        : HELP.hexShort.exec(hexColor).groups;
    if (isShorHex) {
        r += r;
        g += g;
        b += b;
    }
    return rgbColorIsLight(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16));
}

const DATE = "dd.MM.yyyy";
const FULL_TIME = "HH:mm:ss";
const SHORT_TIME = "HH:mm";
const DATE_FULL_TIME = `${DATE} ${FULL_TIME}`;
const DATE_TIME = `${DATE} ${SHORT_TIME}`;
const JS_DATE = "yyyy-MM-dd";
const JS_MONTH = "yyyy-MM";
const JS_DATE_TIME = `${JS_DATE}'T'${SHORT_TIME}`;
const JS_DATE_FULL_TIME = `${JS_DATE}'T'${FULL_TIME}`;

const defaultFormats = {
    DATE,
    SHORT_TIME,
    FULL_TIME,
    DATE_TIME,
    DATE_FULL_TIME,
    JS_DATE,
    JS_DATE_TIME,
    JS_DATE_FULL_TIME,
    JS_MONTH,
};

//* date setup end

/**
 * Default types and formats for Date Field
 */
const types = {
    /** date */
    date: { format: DATE, inputType: "date", jsFormat: JS_DATE },
    /** date and time*/
    dateTime: {
        format: DATE_TIME,
        inputType: "datetime-local",
        jsFormat: JS_DATE_TIME,
    },
    /** date and time with seconds*/
    dateTimeFull: {
        format: DATE_FULL_TIME,
        inputType: "datetime-local",
        jsFormat: JS_DATE_FULL_TIME,
    },
    /** time */
    time: {
        format: SHORT_TIME,
        inputType: "time",
        jsFormat: SHORT_TIME,
    },
    /** time with seconds */
    timeFull: {
        format: FULL_TIME,
        inputType: "time",
        jsFormat: FULL_TIME,
    },
    month: {
        format: DATE,
        inputType: "month",
        jsFormat: JS_MONTH,
    },
};

const dateMeasure = ["Day", "Week", "Month", "Year"];

const date = dateMeasure.reduce((acc, measure) => {
    switch (measure) {
        case dateMeasure[0]:
            acc[`add${measure}s`] = (date, count) => {
                const result = new Date(date);
                result.setDate(date.getDate() + count);
                return result;
            };
            break;
        case dateMeasure[1]:
            acc[`add${measure}s`] = (date, count) => {
                return acc.addDays(date, 7 * count);
            };
            break;
        default:
            acc[`add${measure}s`] = (date, count) => {
                const result = new Date(date);
                result[`set${measure}`](date[`get${measure}`]() + count);
                return result;
            };
    }
    return acc;
}, {});

date.defaultFormats = defaultFormats;
date.inputTypes = types;

const URI = "data:application/vnd.ms-excel;base64,";

const HTML_TEMPLATE =
    '<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40">' +
    "<head>" +
    "<!--[if gte mso 9]>" +
    "<xml>" +
    "<x:ExcelWorkbook>" +
    "<x:ExcelWorksheets>" +
    "<x:ExcelWorksheet>" +
    "<x:Name>{worksheet}</x:Name>" +
    "<x:WorksheetOptions><x:DisplayGridlines/></x:WorksheetOptions>" +
    "</x:ExcelWorksheet>" +
    "</x:ExcelWorksheets>" +
    "</x:ExcelWorkbook>" +
    "</xml>" +
    "<![endif]-->" +
    '<meta http-equiv="content-type" content="text/plain; charset=UTF-8"/>' +
    "</head>" +
    "<body>{table}</body>" +
    "</html>";

const base64 = (s) => window.btoa(unescape(encodeURIComponent(s)));
const format = (s, c) =>
    s.replace(/{(\w+)}/g, (m, p) => {
        return c[p];
    });
const downloadExcel = ({ template, fileName }) => {
    const link = document.createElement("a");
    link.href = URI + base64(template);
    link.download = fileName || "Workbook.xls";
    link.target = "_blank";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
};

const WorkbookHtml = ({ table, name: worksheet }) => {
    const tableStr =
        table instanceof HTMLTableElement
            ? table.outerHTML.trim()
            : table.trim();
    const ctx = {
        worksheet: worksheet || "Worksheet",
        table: tableStr,
    };
    const excelTemplate = format(HTML_TEMPLATE, ctx);
    return excelTemplate;
};

const exportHtmlToExcel = ({ table, fileName, name: worksheetName }) => {
    const template = WorkbookHtml({ table, name: worksheetName });
    downloadExcel({ template, fileName });
};

const getFileData = (file) => {
    const reader = new FileReader();
    reader.readAsBinaryString(file);
    return new Promise((resolve) => {
        reader.addEventListener("load", () => resolve(reader.result));
    });
};

function dateToJs(date) {
    if (date.indexOf(" ") < 0)
        return date.replace(/(\d{2}).(\d{2}).(\d{4})/, "$3-$2-$1");
    return date.split(" ")[0].replace(/(\d{2}).(\d{2}).(\d{4})/, "$3-$2-$1");
}

const getCurrentDateJS = (date = new Date()) => {
    let dd =
        String(date.getDate()).length == 2
            ? date.getDate()
            : "0" + date.getDate();
    let mm =
        String(date.getMonth() + 1).length == 2
            ? date.getMonth() + 1
            : "0" + (date.getMonth() + 1);
    let yyyy = date.getFullYear();
    return dd + "." + mm + "." + yyyy;
};

const getCurrentDateTurbo = (date = new Date()) => {
    let dd =
        String(date.getDate()).length == 2
            ? date.getDate()
            : "0" + date.getDate();
    let mm =
        String(date.getMonth() + 1).length == 2
            ? date.getMonth() + 1
            : "0" + (date.getMonth() + 1);
    let yyyy = date.getFullYear();
    return yyyy + "-" + mm + "-" + dd;
};

const SORT_DIRECTIONS = {
    1: {
        multiplier: 1,
    },
    2: {
        multiplier: -1,
    },
    0: {
        multiplier: 0,
    },
};

const sortTableWith = (config) => (table) => {
    let initialData;
    return (column) => {
        const order = column.getOrder();
        const multiplier = SORT_DIRECTIONS[order].multiplier;
        const sortFunc = config[column.index];

        if (!sortFunc) return;

        if (!initialData && order) {
            initialData = table.getData({ full: true });
        }
        let data = initialData;

        if (order) {
            data = [...initialData].sort((r1, r2) =>
                sortFunc(r1, r2, multiplier, { key: column.index })
            );
        } else {
            initialData = null;
        }

        table.clearRows();
        table.createRows(data);
    };
};

function TableHelper() {
    let fileOrFolder = (props) => {
        if (props) {
            return html`<div class="table-folder"></div>`;
        } else {
            return html`<div class="table-file"></div>`;
        }
    };

    // let sexGender = (props) => {
    //     if (props == 0) {
    //         return "Не указан";
    //     } else if (props == 1) {
    //         return "Мужской";
    //     } else if (props == 2) {
    //         return "Женский";
    //     } else {
    //         return "Не корректное значение";
    //     }
    // };

    let sexGender = (props) => {
        if (props == 1) {
            return "Мужской";
        } else if (props == 2) {
            return "Женский";
        } else {
            return "";
        }
    };

    let checkBox = (props) => {
        let item = html`<input type="checkbox" disabled />`;
        if (props) {
            item.checked = true;
        } else {
            item.checked = false;
        }
        return item;
    };

    let date = (props) => {
        let item = html`<input
            type="date"
            value=${dateToJs(props)}
            disabled
        />`;
        return item;
    };

    let number = (num) => {
        return customNumber(num);
    };

    const customNumber = (num, decimalAmount = 2, divider = " ") => {
        if (num == null) return num;
        if (num === "") return num;

        const _decimal = typeof decimalAmount === "number" ? decimalAmount : 2;
        const _divider = typeof divider === "string" ? divider : " ";
        let regex = /(\d)(?=(\d\d\d)+([^\d]|$))/g; // выражение сопоставления
        let rep = `$1${_divider}`; // вставляемое значение
        let numberText = (num || 0).toFixed(_decimal);
        let [intPart, decimalPart] = numberText.split(".");
        intPart = intPart.replace(regex, rep);
        return `${intPart}${_decimal > 0 ? `,${decimalPart}` : ""}`;
    };

    const formatNumber = ({ decimalAmount, divider } = {}) => {
        return (num) => customNumber(num, decimalAmount, divider);
    };

    let numberСomma = (props) => {
        let numberText = String(props);
        let result = numberText; // = numberText.replace(/(\d)(?=(\d\d\d)+([^\d]|$))/g, "$1'");  //Из-за разделителей Excel не воспринимает значение как число
        let Целая = result.split(".")[0];
        let Дробная = result.split(".")[1];
        if (Дробная == undefined) {
            result = Целая + ",00";
        } else {
            result = Целая + "," + Дробная;
        }
        return result;
    };

    let templateType = (props) => {
        switch (props) {
            case 0:
                return "Email";
            case 1:
                return "СМС";
            default:
                return "Не корректное значение";
        }
    };

    let rewardType = (props) => {
        switch (props) {
            case 0:
                return "Премия";
            case 1:
                return "Услуги";
            case 2:
                return "В скидку";
            default:
                return "Не корректное значение";
        }
    };

    let cellChanger = {
        rewardType,
        templateType,
        fileOrFolder,
        sexGender,
        checkBox,
        date,
        number,
        numberСomma,
        formatNumber,
        customNumber,
    };

    return cellChanger;
}

function uuidv4() {
    if (crypto.randomUUID) return crypto.randomUUID();
    return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (c) =>
        (
            c ^
            (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))
        ).toString(16)
    );
}

function uid() {
    return uuidv4();
}

/**
 * get value from object by path
 * @param {object} object
 * @param {string} path
 */
const getFromObject = (object, path) => {
    if (object == null) return undefined;
    if (path == null) return undefined;
    const pathFragments = path.split(".");
    let result = object;

    for (const pathFragment of pathFragments) {
        result = result[pathFragment];
        if (result == null) return result;
    }

    if (JSON.stringify(object) === JSON.stringify(result)) return undefined;

    return result;
};

const setToObject = (object, path = "", value) => {
    if (object == null) return false;
    if (!(path?.length > 0)) return false;

    const pathArr = path.split(".");
    let startRef = object;
    pathArr.forEach((p, i, arr) => {
        if (i === arr.length - 1) {
            startRef[p] = value;
        } else {
            if (typeof startRef[p] !== "object") {
                startRef[p] = {};
            }
            startRef = startRef[p];
        }
    });

    return true;
};

const setToObservable = (observable, path, value) => {
    const data = sample(observable);
    const result = setToObject(data, path, value);
    if (!result) return false;
    observable(data);
    return true;
};

const set = (object, path, value) => {
    return typeof object === "function"
        ? setToObservable(object, path, value)
        : setToObject(object, path, value);
};

const getFromObservable = (observable, path) =>
    getFromObject(observable(), path);

const getFromO = getFromObservable;

/**
 *
 * @param {() => * | object} value
 * @param {string} path
 * @returns {* | undefined | null} value
 */
const get = (value, path) =>
    typeof value === "function"
        ? getFromO(value, path)
        : getFromObject(value, path);

const getObservable = (data) => {
    return typeof data === "function" ? data : o(data);
};

const createRef = (reference) =>
    function () {
        if (typeof reference === "function") {
            reference(this.el);
            cleanup(() => reference(null));
        } else {
            reference.current = this.el;
            cleanup(() => (reference.current = null));
        }
    };

class Ref {
    static subscribe = createRef;
    constructor() {
        this.current = null;
    }
}

const mergeClasses = (...classes) => {
    const classToArray = (className) => {
        switch (typeof className) {
            case "function":
                return classToArray(className());
            case "string":
                return className.split(" ");
        }
    };
    const merge = () => {
        const array = classes.map(classToArray).flat();
        const set = new Set(array);
        const newArr = Array.from(set)
            .map((cl) => cl?.trim?.())
            .filter((cl) => !!cl);
        const joined = newArr.join(" ");
        return joined;
    };
    const merged = computed(merge);
    return merged;
};

function debounce$1(cb, delay = 250) {
    let timeout;

    return (...args) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
            cb(...args);
        }, delay);
    };
}

const HELP_KEYS = Object.freeze({
    PROJECT: "__projectId__",
});

const BROWSERS = {
    Safari: "safari",
    Chrome: "chrome",
    Firefox: "firefox",
    IE: "ie",
    Opera: "opera",
    MSEdge: "msedge",
    unknown: "unknown",
};

class Browser {
    constructor(name, version) {
        this.name = name || BROWSERS.unknown;
        this.version = version;
    }
    get isSafari() {
        return this.name === BROWSERS.Safari;
    }
    get isChrome() {
        return this.name === BROWSERS.Chrome;
    }
    get isFirefox() {
        return this.name === BROWSERS.Firefox;
    }
    get isIE() {
        return this.name === BROWSERS.IE;
    }
    get isOpera() {
        return this.name === BROWSERS.Opera;
    }
    get isMSEdge() {
        return this.name === BROWSERS.MSEdge;
    }

    toString() {
        return [this.name, this.version].filter((str) => !!str).join(" ");
    }
}

function identifyBrowser() {
    const { userAgent } = navigator;
    let match =
        userAgent.match(
            /(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i
        ) || [];
    let temp;

    if (/trident/i.test(match[1])) {
        temp = /\brv[ :]+(\d+)/g.exec(userAgent) || [];
        return new Browser(BROWSERS.IE, temp[1]);
    }

    if (match[1] === "Chrome") {
        temp = userAgent.match(/\b(OPR|Edge)\/(\d+)/);

        if (temp !== null) {
            return new Browser(BROWSERS.Opera, temp.slice(1)[1]);
        }

        temp = userAgent.match(/\b(Edg)\/(\d+)/);

        if (temp !== null) {
            return new Browser(BROWSERS.MSEdge, temp.slice(1)[1]);
        }
    }

    match = match[2]
        ? [match[1], match[2]]
        : [navigator.appName, navigator.appVersion, "-?"];
    temp = userAgent.match(/version\/(\d+)/i);

    if (temp !== null) {
        match.splice(1, 1, temp[1]);
    }

    return new Browser(BROWSERS[match[0]], match[1]);
}

const currentBrowser = identifyBrowser();

const fixed = Intl.NumberFormat("ru", {
    maximumFractionDigits: 2,
    minimumFractionDigits: 2,
});
const defaultFormat = Intl.NumberFormat("ru");
const integer = Intl.NumberFormat("ru", { maximumFractionDigits: 0 });

const FORMATTERS = {
    fixed,
    integer,
    default: defaultFormat,
};

const HORIZONTAL_ALIGNMENT = {
    left: "left",
    center: "center",
    right: "right",
    fill: "fill",
    justify: "justify",
    centeracrossselection: "centerContinuous",
    distributed: "distributed",
};
const VERTICAL_ALIGNMENT = {
    top: "top",
    center: "middle",
    bottom: "bottom",
    distributed: "distributed",
    justify: "justify",
};
const READING_ORDER = {
    righttoleft: "rtl",
    lefttoright: "ltr",
};

const Alignment = ({
    horizontal,
    readingOrder,
    // not supported by exceljs
    // rotate,
    shrinkToFit,
    vertical,
    wrapText,
}) => {
    const alignment = {};

    horizontal = HORIZONTAL_ALIGNMENT[horizontal?.toLowerCase()];
    vertical = VERTICAL_ALIGNMENT[vertical?.toLowerCase()];
    readingOrder = READING_ORDER[readingOrder?.toLowerCase()];

    if (horizontal) {
        alignment.horizontal = horizontal;
    }
    if (vertical) {
        alignment.vertical = vertical;
    }
    if (readingOrder) {
        alignment.readingOrder = readingOrder;
    }
    if (wrapText) {
        alignment.wrapText = wrapText;
    }
    if (shrinkToFit) {
        alignment.shrinkToFit = shrinkToFit;
    }
    return alignment;
};

const Fill = ({ color, pattern = "solid" }) => {
    if (!color) return;
    if (color.includes("#")) {
        color = color.replaceAll("#", "");
    }
    return {
        type: "pattern",
        pattern: "solid",
        fgColor: { argb: color },
        bgColor: { argb: color },
    };
};

const UNDERLINE_TYPES = {
    none: "none",
    single: "single",
    double: "double",
    singleaccounting: "singleAccounting",
    doubleaccounting: "doubleAccounting",
};

const Font = ({
    bold,
    fontColor,
    fontName,
    italic,
    fontSize,
    underline,
}) => {
    const font = {};

    underline =
        typeof underline === "boolean"
            ? underline
            : UNDERLINE_TYPES[underline?.toLowerCase()];

    if (bold) {
        font.bold = bold;
    }
    if (italic) {
        font.italic = italic;
    }
    if (fontName) {
        font.name = fontName;
    }
    if (fontColor) {
        font.color = { argb: fontColor };
    }
    if (fontSize > 0) {
        font.size = fontSize;
    }
    if (underline) {
        font.underline = underline;
    }

    return font;
};

const NUMBER_FORMATS = {
    general: "General",
    "general number": "0.00",
    "general date": '[$-409]mm/dd/yy" "hh:mm;@',
    "long date": '[$-F800]dddd","" "mmmm" "d","" "yyyy',
    "medium date": "dd.mmm.yyyy",
    "short date": "m/d/yyyy",
    "long time": '[$-F400]hh:mm:ss" "AM/PM',
    "medium time": "hh:mm",
    "short time": "h:m",
    currency: "#,##0.00",
    "euro currency": "#,##0.00",
    fixed: "#,##0.00",
    standard: "General",
    percent: "0.00%",
    scientific: "0.00E+00",
    "yes/no": '"Yes";;"No";',
    "true/false": '"True";;"False";',
    "on/off": '"True";;"False";',
};

const Format = (format) => {
    if (!format) return;
    return NUMBER_FORMATS[format.toLowerCase()] ?? format;
};

const DEFAULT_STYLES = {
    Fixed: {
        numFmt: NUMBER_FORMATS.fixed,
    },
    Date: {
        numFmt: NUMBER_FORMATS["medium date"],
    },
    Currency: {
        numFmt: NUMBER_FORMATS.currency,
    },
};

const Style = (styleData) => {
    const style = {};
    const numFmt = Format(styleData.format);
    const fill = Fill(styleData);
    const alignment = Alignment(styleData);
    const font = Font(styleData);
    if (numFmt) {
        style.numFmt = numFmt;
    }
    if (fill) {
        style.fill = fill;
    }
    if (Object.keys(alignment).length > 0) {
        style.alignment = alignment;
    }
    if (Object.keys(font).length > 0) {
        style.font = font;
    }
    if (styleData.protected) {
        style.protected = styleData.protected;
    }

    return style;
};

const Column =
    ({
        // wb,
        ws,
        styles,
    }) =>
    (columnData, columnIndex) => {
        const {
            width,
            // autowidth not support exceljs 21.07.2023
            // autoWidth,
            hidden,
            span = 0,
            protected: isProtected,
        } = columnData;
        const columnStyle = styles[columnData.style];
        const startIndex = columnData.index ?? columnIndex + 1;

        for (let i = 0; i <= span; i++) {
            const column = ws.getColumn(startIndex + i);
            if (columnStyle) {
                Object.keys(columnStyle).forEach(
                    (key) => (column[key] = columnStyle[key])
                );
            }
            if (width) {
                column.width = width > 9 ? (width / 0.75 - 5) / 7 : width / 9;
            }
            if (hidden) {
                column.hidden = hidden;
            }
            if (isProtected) {
                column.eachCell({ includeEmpty: true }, (cell) => {
                    cell.protection = { locked: true };
                });
            }
        }
    };

class CFVO {
    static TYPES = {
        NUM: "num",
        PERCENT: "percent",
        MAX: "max",
        MIN: "min",
        FORMULA: "formula",
        PERCENTILE: "percentile",
        AUTO_MIN: "autoMin",
        AUTO_MAX: "autoMax",
    };

    constructor({ type, value }) {
        this.type = Object.values(CFVO.TYPES).find(
            (t) => t.toLowerCase() === type.toLowerCase()
        );
        this.value = value;
    }

    get isCorrect() {
        return !!this.type;
    }
}

const CELL_IS_OPERATORS = {
    EQUAL: "equal",
    GREATER_THAN: "greaterThan",
    LESS_THAN: "lessThan",
    BETWEEN: "between",
};

const CONTAINS_TEXT_OPERATORS = {
    CONTAINS_TEXT: "containsText",
    CONTAINS_BLANKS: "containsBlanks",
    NOT_CONTAINS_BLANKS: "notContainsBlanks",
    CONTAINS_ERRORS: "containsErrors",
    NOT_CONTAINS_ERRORS: "notContainsErrors",
};

const TIME_PERIODS = {
    LAST_WEEK: "lastWeek",
    THIS_WEEK: "thisWeek",
    NEXT_WEEK: "nextWeek",
    YESTERDAY: "yesterday",
    TODAY: "today",
    TOMORROW: "tomorrow",
    LAST_7_DAYS: "last7Days",
    LAST_MONTH: "lastMonth",
    THIS_MONTH: "thisMonth",
    NEXT_MONTH: "nextMonth",
};

const RULE_TYPES = {
    EXPRESSION: "expression",
    CELL_IS: "cellIs",
    TOP_10: "top10",
    ABOVE_AVERAGE: "aboveAverage",
    COLOR_SCALE: "colorScale",
    CONTAINS_TEXT: "containsText",
    TIME_PERIOD: "timePeriod",
};

class Rule {
    constructor({ type, priority, style }) {
        this.type = type;
        this.priority = priority;
        this.style = style;
    }
    get isCorrect() {
        return !!this.type;
    }
}

class ExpressionRule extends Rule {
    constructor({ formula, ...rest }) {
        super(rest);
        this.formulae = [formula];
        this.type = RULE_TYPES.EXPRESSION;
    }
    get isCorrect() {
        return super.isCorrect && this.formula != null && this.formula !== "";
    }
    get formula() {
        return this.formulae[0];
    }
}

class CellIsRule extends ExpressionRule {
    constructor({ operator, ...rest }) {
        super(rest);
        this.type = RULE_TYPES.CELL_IS;
        this.operator = Object.values(CELL_IS_OPERATORS).find(
            (op) => op.toLowerCase() === operator?.toLowerCase?.()
        );
    }
    get isCorrect() {
        return super.isCorrect && !!this.operator;
    }
}

class Top10Rule extends Rule {
    constructor({ rank, percent, bottom, ...rest }) {
        super(rest);
        this.type = RULE_TYPES.TOP_10;
        this.rank = rank;
        this.bottom = bottom;
        this.percent = percent;
    }
}

class AboveAverageRule extends Rule {
    constructor({ aboveAverage, ...rest }) {
        super(rest);
        this.type = RULE_TYPES.ABOVE_AVERAGE;
        this.aboveAverage = aboveAverage;
    }
}

class RuleWithCFVO extends Rule {
    /**
     *
     * @param {{cfvos: Array}} param0
     */
    constructor({ cfvos, ...rest }) {
        super(rest);
        this.cfvo = cfvos
            ?.map((v) => new CFVO(v))
            .filter((cfvo) => cfvo.isCorrect);
    }
    get isCorrect() {
        return (
            super.isCorrect && this.cfvo.length >= 2 && this.cfvo.length <= 5
        );
    }
}

class ColorScaleRule extends RuleWithCFVO {
    /**
     *
     * @param {{colors: Array<string>}} param0
     */
    constructor({ colors, ...rest }) {
        super(rest);
        this.color = colors
            .filter((c) => !!c)
            .map((color) => ({ argb: color }));
    }

    get isCorrect() {
        return super.isCorrect && this.color.length === this.cfvo.length;
    }
}

class ContainsTextRule extends Rule {
    constructor({ operator, text, ...rest }) {
        super(rest);
        this.type = RULE_TYPES.CONTAINS_TEXT;
        this.operator = Object.values(CONTAINS_TEXT_OPERATORS).find(
            (op) => op.toLowerCase() === operator.toLowerCase()
        );
        this.text = text;
    }
    get isCorrect() {
        return super.isCorrect && !!this.operator;
    }
}

class TimePeriod extends Rule {
    constructor({ timePeriod, ...rest }) {
        super(rest);
        this.type = RULE_TYPES.TIME_PERIOD;
        this.timePeriod = Object.values(TIME_PERIODS).find(
            (tp) => tp.toLowerCase() === timePeriod.toLowerCase()
        );
    }
    get isCorrect() {
        return super.isCorrect && !!this.timePeriod;
    }
}

const Rules = {
    [RULE_TYPES.EXPRESSION.toLowerCase()]: ExpressionRule,
    [RULE_TYPES.CELL_IS.toLowerCase()]: CellIsRule,
    [RULE_TYPES.TOP_10.toLowerCase()]: Top10Rule,
    [RULE_TYPES.ABOVE_AVERAGE.toLowerCase()]: AboveAverageRule,
    [RULE_TYPES.COLOR_SCALE.toLowerCase()]: ColorScaleRule,
    [RULE_TYPES.CONTAINS_TEXT.toLowerCase()]: ContainsTextRule,
    [RULE_TYPES.TIME_PERIOD.toLowerCase()]: TimePeriod,
};

const addConditionalFormatting = ({ data, ws, styles }) => {
    if (!data.conditionalFormatting) return;
    const conditionalFormatting = Object.values(data.conditionalFormatting);

    conditionalFormatting.forEach(addRangeRules({ ws, styles }));
};

const addRangeRules =
    ({ ws, styles }) =>
    ({ range, rules }) => {
        if (!range) return;
        if (!rules) return;
        rules = Object.values(rules);
        if (rules.length === 0) return;

        const cf = {
            ref: range,
            rules: rules.map(createRule({ styles })).filter((r) => !!r),
        };

        ws.addConditionalFormatting(cf);
    };

const createRule =
    ({ styles }) =>
    /**
     *
     * @param {{type: CFType}} params
     * @returns
     */
    (params) => {
        if (!params.type) return;

        params.style = { ...styles[params.style] };
        const RuleBuilder = Rules[params.type.toLowerCase()];
        if (!RuleBuilder) return;

        /**
         * @type {import("./rules").Rule}
         */
        const cfRule = new RuleBuilder(params);
        if (!cfRule?.isCorrect) return;

        return cfRule;
    };

function mergeCells({ cellData, row, column, ws }) {
    if (!cellData.mergeAcross && !cellData.mergeDown) {
        return;
    }
    const mergeRange = [
        row,
        column,
        row + (cellData.mergeDown || 0),
        column + (cellData.mergeAcross || 0),
    ];
    ws.mergeCells(...mergeRange);
}

const getCellProtection = ({ cellData, styleProtected }) => {
    const protection = {
        locked: false,
    };
    if (styleProtected) {
        protection.locked = true;
    }
    if (cellData.protected != null) {
        protection.locked = cellData.protected;
    }
    return protection;
};

const getColumnIndex = ({ row, cellIndex }) => {
    const emptyCellIndex = row.values.findIndex(
        (value, index) => value == null && index !== 0
    );
    return row.values.length === 0
        ? cellIndex + 1
        : emptyCellIndex >= 0
        ? emptyCellIndex
        : row.values.length;
};

const Cell =
    ({ ws, row, rowIndex, styles }) =>
    (cellData, cellIndex) => {
        const columnIndex = getColumnIndex({ row, cellIndex });

        let cell = row.getCell(columnIndex);

        if (cellData.formula) {
            const formula = cellData.formula.includes("=")
                ? cellData.formula.replace("=", "")
                : cellData.formula;
            cell.value = { formula, result: cellData.data || 0 };
        } else {
            cell.value = cellData.data ?? "";
        }

        mergeCells({ cellData, row: rowIndex, column: columnIndex, ws });

        const { protected: styleProtected, ...cellStyle } =
            styles[cellData.style] ?? {};

        Object.keys(cellStyle).forEach((key) => (cell[key] = cellStyle[key]));

        cell.protection = getCellProtection({ cellData, styleProtected });
    };

const Row =
    ({ wb, ws, styles }) =>
    (rowData, rowIndex) => {
        rowIndex += 1;
        const row = ws.getRow(rowIndex);
        const cells = Object.values(rowData);
        for (let i = 0; i < cells.length; i++) {
            const cellData = cells[i];
            Cell({ wb, ws, row, rowIndex, styles })(cellData, i);

            const nextCell = cells[i + 1];
            if (!nextCell) continue;

            if (cellData.mergeAcross && nextCell.data === cellData.data) {
                i += cellData.mergeAcross;
                continue;
            }
        }
        row.commit();
    };

const HIDDEN_STATE = {
    visible: "visible",
    hidden: "hidden",
    veryhidden: "veryHidden",
};

const Worksheet = (wb, styles) => async (wsData, index) => {
    const ws = wb.addWorksheet(wsData.name ?? `Worksheet${index}`);
    Object.values(wsData.data).forEach(Row({ wb, ws, styles }));
    addAdditionalUnlockedCells({ data: wsData, ws });
    Object.values(wsData.columns ?? []).forEach(Column({ wb, ws, styles }));
    addConditionalFormatting({ data: wsData, ws, styles });
    hideWorksheet({ data: wsData, ws });
    if (wsData.autoFilter) {
        ws.autoFilter = wsData.autoFilter;
    }
    if (wsData.protected) {
        const protectionParams = {
            selectLockedCells: true,
            selectUnlockedCells: true,
            formatCells: true,
            formatColumns: true,
            formatRows: true,
            insertRows: false,
            insertColumns: false,
            insertHyperlinks: false,
            deleteRows: false,
            deleteColumns: false,
            sort: true,
            autoFilter: true,
            pivotTables: true,
            ...(wsData.protectionParams ?? {}),
        };

        await ws.protect(
            wsData.protected?.password ? wsData.protected.password : "",
            protectionParams
        );
    }
};

const addAdditionalUnlockedCells = ({ data, ws }) => {
    if (!data.additionalUnlocked) return;
    const { additionalUnlocked } = data;
    const currentColumnsCount = ws.columnCount;
    const currentRowsCount = ws.rowCount;
    const additionalRowSize =
        currentColumnsCount + additionalUnlocked.columns || 0;
    const additionalColumnSize =
        currentRowsCount + additionalUnlocked.rows || 0;
    addUnlockedItems({
        currentSize: currentColumnsCount,
        count: additionalUnlocked.columns,
        size: additionalRowSize,
        ws,
    });
    addUnlockedItems({
        currentSize: currentRowsCount,
        count: additionalUnlocked.rows,
        size: additionalColumnSize,
        row: true,
        ws,
    });
};

const addUnlockedItems = ({ currentSize, size, count, row = false, ws }) => {
    if (!count) return;
    for (let i = 0; i < count; i++) {
        const item = row
            ? ws.getRow(currentSize + i + 1)
            : ws.getColumn(currentSize + i + 1);

        const emptyArray = Array.from({ length: size }, () => "");
        item.values = emptyArray;

        item.eachCell({ includeEmpty: true }, (cell) => {
            cell.protection = { locked: false };
        });

        if (row) {
            item.commit();
        }
    }
};

const hideWorksheet = ({ data, ws }) => {
    /**@type {string|boolean|null} */
    const hidden = data.hidden;
    if (!hidden) return;

    if (hidden === true) {
        ws.state = HIDDEN_STATE.hidden;
        return;
    }

    if (typeof hidden !== "string") return;

    const state = HIDDEN_STATE[hidden.toLowerCase()];
    if (state) {
        ws.state = state;
    }
};

const Workbook = (jsonData) => {
    const workbook = new ExcelJS.Workbook();

    // creating style for whole document
    const styles = {
        ...DEFAULT_STYLES,
        ...Object.values(jsonData.styles ?? []).reduce((acc, style) => {
            acc[style.id] = Style(style);
            return acc;
        }, {}),
    };

    // creating multiple worksheets
    Object.values(jsonData.data).forEach(Worksheet(workbook, styles));

    const user = getUserName() ?? "unknown";

    // set workbook parameters
    workbook.creator = user;
    workbook.lastModifiedBy = user;
    workbook.created = new Date();
    workbook.modified = new Date();

    workbook.calcProperties.fullCalcOnLoad = true;

    return workbook;
};

const dowloadWorkBook = async ({ workbook, filename = "Workbook.xlsx" }) => {
    const buffer = await workbook.xlsx.writeBuffer();
    const blob = new Blob([buffer], {
        type: "vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=utf-8",
    });
    const url = URL.createObjectURL(blob);
    const link = html`<a
        href=${url}
        style="display: none"
        download=${filename}
    ></a>`;
    link.click();
    URL.revokeObjectURL(url);
    return true;
};

const exportJSONToXlsx = async (json, filename = "workbook.xlsx") => {
    const workbook = Workbook(json);
    const result = await dowloadWorkBook({ workbook, filename });
    return result;
};

/**
 *
 * @param {string} selector
 * @param {HTMLElement} [src]
 * @returns {HTMLElement?}
 */
const qs = (selector, src = document.body) => {
    return src.querySelector(selector);
};

/**
 *
 * @param {MouseEvent} ev
 */
function isLeftMouseBtnEvent(ev) {
    return ev.button === 0 && (ev.buttons === 1 || ev.buttons === 0);
}

/**
 *
 * @param {MouseEvent|KeyboardEvent} ev
 */
function isOnlyCtrlPressed(ev) {
    return ev.ctrlKey && !ev.altKey && !ev.metaKey && !ev.shiftKey;
}

const currentDevice = {
    isMobile: () => /mobile/i.test(navigator.userAgent),
    isTablet: () => /tablet/i.test(navigator.userAgent),
    isAndroid: () => /android/i.test(navigator.userAgent),
    isiPhone: () => /iphone/i.test(navigator.userAgent),
    isiPad: () => /ipad/i.test(navigator.userAgent),
};

const getCurrentPath = () => {
    return location.href.slice(location.origin.length);
};

const REG_EXPS = {
    NUMBER: /^(\+|-)?\d+$/,
    BOOLEAN: /^(true|false)$/i,
    NULL: /^null$/i,
    UNDEFINED: /^undefined$/i,
};

/**
 * 
 * @param {string} path 
 * @param {{ignoreRouter?: boolean, searchParams?: object, replaceHistory?: boolean, newTab?: boolean = false}} options 
 * @returns 
 */
const navigate = (path, options) => {
    const {
        ignoreRouter,
        searchParams,
        replaceHistory,
        newTab = false,
    } = options ?? {};

    const oldSearchParams = getSearchParams(location.search);
    const newSearchParams = Object.entries({
        ...oldSearchParams,
        ...(searchParams ?? {}),
    }).reduce(
        (acc, [key, value]) => (value == null ? acc : { ...acc, [key]: value }),
        {}
    );

    const searchParamsString = new URLSearchParams(newSearchParams).toString();
    const [mainPath] = path.split("?");

    path = [mainPath, searchParamsString].filter((s) => !!s).join("?");

    const anchor = html`
        <a
            href=${path}
            style="display: none"
            data-ignore-router=${ignoreRouter}
            data-replace-history=${replaceHistory}
            target=${newTab ? "_blank" : undefined}
            rel=${newTab ? "noopener noreferrer" : undefined}
        />
    `;
    const router = document.body.querySelector(".router");
    if (!router) return;

    router.appendChild(anchor);
    anchor.click();
    anchor.remove();
};

const getSearchParams = (urlString = location.search) => {
    const urlSearchParams = new URLSearchParams(urlString ?? "");

    const params = Array.from(urlSearchParams.entries()).reduce(
        (acc, [key, value]) => {
            const initialValue = value;
            if (REG_EXPS.NUMBER.test(value)) {
                value = Number(value);
            } else if (REG_EXPS.BOOLEAN.test(value)) {
                value = value.toLowerCase() === "true";
            } else if (REG_EXPS.NULL.test(value)) {
                value = null;
            } else if (REG_EXPS.UNDEFINED.test(value)) {
                value = undefined;
            }
            return {
                ...acc,
                [key]: value,
                __src: { ...(acc.__src ?? {}), [key]: initialValue },
            };
        },
        {}
    );

    return params;
};

let lastPath = "";

class Queue {
    constructor() {
        this._items = [];
    }
    enqueue(item) {
        this._items.push(item);
    }
    dequeue() {
        return this._items.shift();
    }
    get lenght() {
        return this._items.length;
    }
}

class AutoQueue extends Queue {
    constructor() {
        super();
        this._pendingPromise = false;
    }

    enqueue(action) {
        return new Promise((resolve, reject) => {
            super.enqueue({ action, resolve, reject });
            this.dequeue();
        });
    }

    async dequeue() {
        if (this._pendingPromise) return false;

        let item = super.dequeue();

        if (!item) return false;

        try {
            this._pendingPromise = true;

            let payload = await item.action(this);

            this._pendingPromise = false;
            item.resolve(payload);
        } catch (e) {
            this._pendingPromise = false;
            item.reject(e);
        } finally {
            this.dequeue();
        }

        return true;
    }
}

const Router = (props, ...children) => {
    /**@type {HTMLElement} */
    const { routes = [], onChange, id, ...rest } = props ?? {};

    const queue = new AutoQueue();

    const router = html`<div
        ...${rest}
        class="router"
        style="display: contents"
        id=${id ? `router-${id}` : null}
    >
        ${children}
    </div>`;

    async function changeRoute([path, key, match]) {
        const route = routes[key];

        if (route) {
            await onChange?.({
                path,
                match,
                component: route.element ?? route[1],
                key,
            });
        }
    }

    function onLinkClick(event) {
        /**@type {HTMLAnchorElement} */
        const link = event.target.closest("a");
        if (
            link != null &&
            link.href.indexOf(location.origin) === 0 &&
            link.target !== "_blank" &&
            link.dataset.ignoreRouter == null &&
            event.button === 0 &&
            !event.metaKey &&
            !event.ctrlKey &&
            !event.shiftKey &&
            !event.altKey
        ) {
            const path = link.href.slice(location.origin.length);
            const result = parse(path, routes);
            if (!event.defaultPrevented) {
                event.preventDefault();
            }
            if (lastPath !== path) {
                if (link.dataset.replaceHistory === "true") {
                    history.replaceState(null, null, path);
                } else {
                    history.pushState(null, null, path);
                }
                lastPath = path;
            }
            queue.enqueue(() => changeRoute(result));
            // changeRoute(result);
        }
    }

    function onPopState() {
        const path = getCurrentPath();
        const result = parse(path, routes);
        if (lastPath !== path) {
            lastPath = path;
        }
        queue.enqueue(() => changeRoute(result));
        // changeRoute(result);
    }

    observe(router);

    document.documentElement.addEventListener("click", onLinkClick);
    window.addEventListener("popstate", onPopState);

    lastPath = getCurrentPath();
    // changeRoute(parse(lastPath, routes));
    queue.enqueue(() => changeRoute(parse(lastPath, routes)));
    router.addEventListener("connected", () => {
        queue.enqueue(() => changeRoute(parse(lastPath, routes)));
        // changeRoute(parse(lastPath, routes));
    });

    router.addEventListener("disconnected", () => {
        document.documentElement.removeEventListener("click", onLinkClick);
        window.removeEventListener("popstate", onPopState);
    });

    return router;
};

/**
 * @private
 * @param {string} path
 * @param {Route[]} routes
 * @return {[string, number, string[]]}
 */
function parse(path, routes) {
    let normalized = path.replace(/(^\/|\/$)/g, "");

    for (let [index, route] of Object.entries(routes)) {
        const regexp = route.regexp ?? route[0];
        let matchRE = normalized.match(regexp);
        if (matchRE) {
            return [path, index, matchRE];
        }
    }

    return [path];
}

class Route {
    constructor(regexp, element, title) {
        this.regexp = regexp;
        this.element = element;
        this.title = title;
    }
}

class CardFileRoute extends Route {
    static createRegExp(cardfile) {
        return new RegExp(`^#cardfile\\/${cardfile}(?<params>\\?.*)?$`, "i");
    }
    constructor({ cardfile, element, targetClass, header, urlPath }) {
        const { settings } = element;
        urlPath ??= cardfile || settings?.urlPath;
        const title = header || settings?.rootName || settings?.root?.name;
        super(CardFileRoute.createRegExp(urlPath), element, title);

        this.targetClass = settings?.targetClass || targetClass;
        this.header = title;
    }
}

class ReportRoute extends Route {
    static createRegExp(service) {
        return new RegExp(`^#report\\/${service}(?<params>\\?.*)?$`, "i");
    }
    constructor({ report, element, header }) {
        super(ReportRoute.createRegExp(report), element, header);
        this.header = header;
    }
}

class View$4 {
    constructor(path, params) {
        /**@type {string} */
        this.path = `${path}` ?? "";
        /**@type {string} */
        this.params = params ?? "";
    }
    /**
     *
     * @param {View} view
     * @returns {boolean}
     */
    isEqual(view) {
        return this.pathIsEqual(view) && this.paramsIsEqual(view);
    }
    /**
     *
     * @param {View} view
     * @returns {boolean}
     */
    pathIsEqual(view) {
        return view.path?.toLowerCase() === this.path.toLowerCase();
    }
    /**
     *
     * @param {View} view
     * @returns {boolean}
     */
    paramsIsEqual(view) {
        return view.params?.toLowerCase() === this.params.toLowerCase();
    }
}

const SSOResult = ({ success, timeout = 500 }) => {
    const element = html`<div>
        ${success ? "Успешно авторизованы" : "Не прошли авторизацию"}
    </div>`;
    observe(element);

    element.addEventListener("connected", () => {
        setTimeout(() => {
            window.close();
        }, timeout);
    });
    return element;
};

const appRoutes = {
    ssoSuccess: new Route(/^#sso\/loggedIn$/i, () =>
        SSOResult({ success: true })
    ),
    ssoFailed: new Route(/^#sso\/failure$/i, () =>
        SSOResult({ success: false })
    ),
};

const deactivationUser = async (Employee) => {
    // деактивация пользователя
    const body = {
        Employee,
    };

    const response = await executeQuery("DeactivationUser", { body });

    if (!response) return { isOk: false, error: new Error("cant send invite") };

    if (!response.bodyUsed) {
        return { isOk: response.ok, data: await response.json() };
    }

    return { isOk: response.ok };
};

const registerInvite = async (
    Email,
    RoleNewUser,
    newUser,
    id,
    customer,
    project
) => {
    // приглашение для регистрации
    const body = {
        Email,
        RoleNewUser,
        newUser,
        id,
        customer,
        project,
    };

    try {
        const response = await executeQuery("RegisterInvite", { body });

        if (!response)
            return { isOk: false, error: new Error("cant send invite") };

        if (!response.bodyUsed) {
            return { isOk: response.ok, data: await response.json() };
        }
        return { isOk: response.ok };
    } catch (error) {
        return { isOk: false, error: error };
    }
};

const getBadge = async ({ comandScript }) => {
    const body = { comandScript };
    /**@type {Response} */
    const response = await executeQuery("getBadge", { body });

    if (!response)
        return { isOk: false, error: new Error("cant get badge data") };

    if (!response.bodyUsed) {
        return { isOk: response.ok, data: await response.json() };
    }

    return { isOk: response.ok };
};


const getInternalMessage = (searchText , onlyNew) => {
    const body = {searchText , onlyNew};
    return executeQuery("getInternalMessage", { body })
        .then((res) => res.json())
        .catch((error) => error);
};

const setInternalMessageRead = (messageId) => {
    // Устанавливает флаг прочитано, для внутреннего сообщения
    const body = {
        messageId 
    };
    return executeQuery("setInternalMessageRead", { body })
        .then((res) => res.json())
        .catch((error) => error);
};

const RefreshRightsForRole = (docid) => {
    let body = {
        docid,
    };

    return executeQuery("RefreshRightsForRole", {
        body,
    })
        .then((result) => result.json())
        .catch((err) => err);
};

const addAuthRec = async (body
    ) => {
        try {
            const response = await executeQuery("addAuthRec", {
                body,
            });
            if (!response) return { isOk: false };
    
            return { isOk: response.ok };
        } catch (error) {
            return { isOk: false, error };
        }
    };

const logout = async (body
    ) => {
        try {
            const response = await executeQuery("logout", {
                body,
            });
            if (!response) return { isOk: false };
    
            return { isOk: response.ok };
        } catch (error) {
            return { isOk: false, error };
        }
    };

const getEnabledActionsForLead = async (docid) => {
    const body = {
        docid,
    };
    const response = await executeQuery("getEnabledActionsForLead", { body });  
    if (!response) 
        return { isOk: false, error: new Error("Lead Actions Error") };

    if (!response.bodyUsed) 
        return { isOk: response.ok, data: await response.json() };

    return { isOk: response.ok };
};


const getEnabledActionsForVisit = async (docid) => {
    const body = {
        docid,
    };
    const response = await executeQuery("getEnabledActionsForVisit", { body });  
    if (!response) 
        return { isOk: false, error: new Error("Visit Actions Error") };

    if (!response.bodyUsed) 
        return { isOk: response.ok, data: await response.json() };

    return { isOk: response.ok };
};

const executeActionForVisit = async (
    docid,
    commandName,
    data
) => {
    const body = {
        docid,
        commandName,
        data: data,
    };
    const response = await executeQuery("executeActionForVisit", { body });

    if (!response) 
        return { isOk: false, error: new Error("cant exec visit") };

    if (!response.bodyUsed)
        return { isOk: response.ok };

    return { isOk: response.ok };
};



const executeActionForLead = async (
    docid,
    commandName,
    data

) => {
    const body = {
        docid,
        commandName,
        data: data,
    };
    const response = await executeQuery("executeActionForLead", { body });

    if (!response) 
        return { isOk: false, error: new Error("cant exec lead") };

    if (response.status!=200)
        return { isOk: response.ok, success: false };
    else
        return { isOk: response.ok, success: true };
};

const getVisitsForCalendar = async (
    props,
) => {
    const body = props;
    try {
        const response = await executeQuery("getVisitsForCalendar", { body });
        const data = await response.json();
        return { data, isOk: response.ok };
    } catch (error) {
        return { isOk: false, error };
    }
};


const getFastFilters = async (targetClass) => {
    // Автор Колпаков А.Г.
    // Получает список доступных фильтров для картотеки

    const body = {
        targetClass,
    };

    const response = await executeQuery("getFastFilters", { body });

    if (!response)
        return { isOk: false, error: new Error("cant create ticket") };

    if (!response.bodyUsed) {
        return { isOk: response.ok, data: await response.json() };
    }

    return { isOk: response.ok };
};

const getDependenceDocument = async ({ targetClass, docid }) => {
    const body = { targetClass, docid };
    try {
        const response = await executeQuery("getDependenceDocument", { body });
        if (response == null) throw new Error("can't connect to server");
        return {
            isOk: response.ok,
            data: response.bodyUsed ? null : await response.json(),
        };
    } catch (error) {
        return { isOk: false, error };
    }
};

const getEnabledActionsForSR = async (docid) => {
    const body = {
        docid,
    };
    const response = await executeQuery("getEnabledActionsForSR", { body });  
    if (!response) 
        return { isOk: false, error: new Error("SR Actions Error") };

    if (!response.bodyUsed) 
        return { isOk: response.ok, data: await response.json() };

    return { isOk: response.ok };
};

const executeActionForSR = async (
    docid,
    commandName,
    data

) => {
    const body = {
        docid,
        commandName,
        data: data,
    };
    const response = await executeQuery("executeActionForSR", { body });

    if (!response) 
        return { isOk: false, error: new Error("cant exec SR") };

    if (response.status!=200)
        return { isOk: response.ok, success: false };
    else
        return { isOk: response.ok, success: true };
};

const getEnabledActionsForOpportunity = async (docid) => {
    const body = {
        docid,
    };
    const response = await executeQuery("getEnabledActionsForOpportunity", { body });  
    if (!response) 
        return { isOk: false, error: new Error("Opportunity Actions Error") };

    if (!response.bodyUsed) 
        return { isOk: response.ok, data: await response.json() };

    return { isOk: response.ok };
};

const executeActionForOpportunity = async (
    docid,
    commandName,
    data

) => {
    const body = {
        docid,
        commandName,
        data: data,
    };
    const response = await executeQuery("executeActionForOpportunity", { body });

    if (!response) 
        return { isOk: false, error: new Error("cant exec Opportunity") };

    if (!response.bodyUsed)
        return { isOk: response.ok };

    return { isOk: response.ok };
};

const addToMembersForDocument = async ({
    targetClass,
    docid,
    persona,
}) => {
    const body = { targetClass, docid, persona };
    try {
        const response = await executeQuery("AddToMembersForDocument", {
            body,
        });
        if (!response) return { isOk: false };

        return { isOk: response.ok };
    } catch (error) {
        return { isOk: false, error };
    }
};
const deleteMemberFromDocument = async ({
    targetClass,
    docid,
    persona,
}) => {
    const body = { targetClass, docid, persona };
    try {
        const response = await executeQuery("DeleteMemberFromDocument", {
            body,
        });
        if (!response) return { isOk: false };

        return { isOk: response.ok };
    } catch (error) {
        return { isOk: false, error };
    }
};

const GetReport01 = ({doe, model, distrib, st, storagearea}) => {
    const body = {
        doe,
        model,    
        distrib,
        st,
        storagearea,  
    };

    return executeQuery("GetReport01", { body })
        .then((res) => res.json())
        .catch((error) => error);
};

const GetReport02 = ({doe, model, distrib, st, storagearea}) => {
    const body = {
        doe,
        model,    
        distrib,
        st,
        storagearea,  
    };

    return executeQuery("GetReport02", { body })
        .then((res) => res.json())
        .catch((error) => error);
};

const GetReport03 = ({doe, model, distrib, st, storagearea}) => {
    const body = {
        doe,
        model,    
        distrib,
        st,
        storagearea,   
    };

    return executeQuery("GetReport03", { body })
        .then((res) => res.json())
        .catch((error) => error);
};

const GetReport301 = ({doe, st, distrib}) => {
    const body = {
        doe,
        st,
        distrib,
    };

    return executeQuery("GetReport301", { body })
        .then((res) => res.json())
        .catch((error) => error);
};

const GetReport302 = ({doe, tradepoint, st}) => {
    const body = {
        doe,
        tradepoint,
        st,
    };

    return executeQuery("GetReport302", { body })
        .then((res) => res.json())
        .catch((error) => error);
};

const getEnabledActionsForWorkOrder = async (docid) => {
    const body = {
        docid,
    };
    const response = await executeQuery("getEnabledActionsForWorkOrder", { body });  
    if (!response) 
        return { isOk: false, error: new Error("WorkOrder Actions Error") };

    if (!response.bodyUsed) 
        return { isOk: response.ok, data: await response.json() };

    return { isOk: response.ok };
};

const executeActionForWorkOrder = async (
    docid,
    commandName,
    data

) => {
    const body = {
        docid,
        commandName,
        data: data,
    };
    const response = await executeQuery("executeActionForWorkOrder", { body });

    if (!response) 
        return { isOk: false, error: new Error("cant exec workorder") };

    if (!response.bodyUsed)
        return { isOk: response.ok };

    return { isOk: response.ok };
};

// Работа с файлами возможность.
function getFilesListOpportunity({ docid, targetClass }, signal, options = {}) {
    // Возвращает список прикрепленных файлов к докуенту/справочнику
    const body = {
        docid,
        targetClass,
    };

    return executeQuery("getFileListOpportunity", { ...options, signal, body })
        .then(async (res) => ({ isOk: res.ok, data: await res.json() }))
        .catch((error) => ({ isOk: false, error }));
}

function uploadFileToOpportunity(
    { name, data, additional = {} },
    signal,
    options = {}
) {
    const body = {
        name,
        data,
        ...additional,
    };

    return executeQuery("uploadFileToOpportunity", { ...options, body, signal })
        .then(async (res) => {
            if (res.bodyUsed) return { isOk: false };
            return {
                isOk: res.ok,
                data: await res.json(),
            };
        })
        .catch((error) => {
            error.requestParams = body;
            return { isOk: false, error };
        });
}

function deleteFileOpportunity({ docid, ...rest }, signal, options = {}) {
    const body = {
        ...rest,
        docid,
    };
    return executeQuery("deleteFileOpportunity", { ...options, body, signal })
        .then(async (res) => {
            if (res.bodyUsed) return { isOk: false };
            return { isOk: res.ok, data: await res.json() };
        })
        .catch((error) => {
            error.requestParams = body;
            return { isOk: false, error };
        });
}

function getActsList({ docid, targetClass }, signal, options = {}) {
    const body = {
        docid,
        targetClass,
    };

    return executeQuery("getActsList", { ...options, signal, body })
        .then(async (res) => ({ isOk: res.ok, data: await res.json() }))
        .catch((error) => ({ isOk: false, error }));
}

function getTradePointPhotos({ docid }, signal, options = {}) {
    const body = {
        docid,        
    };

    return executeQuery("getTradePointPhotos", { ...options, signal, body })
        .then(async (res) => ({ isOk: res.ok, data: await res.json() }))
        .catch((error) => ({ isOk: false, error }));
}

const getEnabledActionsForInternalMovement = async (docid) => {
    const body = {
        docid,
    };
    const response = await executeQuery("getEnabledActionsForInternalMovement", { body });  
    if (!response) 
        return { isOk: false, error: new Error("Internal Movement Actions Error") };

    if (!response.bodyUsed) 
        return { isOk: response.ok, data: await response.json() };

    return { isOk: response.ok };
};

const executeActionForInternalMovement = async (
    docid,
    commandName,
    data

) => {
    const body = {
        docid,
        commandName,
        data: data,
    };
    const response = await executeQuery("executeActionForInternalMovement", { body });

    if (!response) 
        return { isOk: false, error: new Error("cant exec internal movement") };

    if (!response.bodyUsed)
        return { isOk: response.ok };

    return { isOk: response.ok };
};

const findEquipmentByNumber = async (
    serviceType, 
    serviceTerritory,
    TradePoint,
    number

) => {
    const body = {
        serviceType,
        serviceTerritory,
        TradePoint,
        number
    };


    return executeQuery("findEquipmentByNumber", { body })
    .then((res) => res.json())
    .catch((error) => error);
    
};

const checkByManufectererNumberInInternalMovement = async (
    // Тоже самое что и findEquipmentByNumber. Но работает на других счетах
    // работает для документа внетрнее перемещение
    serviceTerritory,
    storagearea,
    number

) => {
    const body = {
        serviceTerritory,
        storagearea,
        number
    };


    return executeQuery("checkByManufectererNumberInInternalMovement", { body })
    .then((res) => res.json())
    .catch((error) => error);
    
};


const GetReport04 = ({doe, model, distrib, st, storagearea}) => {
    const body = {
        doe,
        model,    
        distrib,
        st,
        storagearea, 
    };

    return executeQuery("GetReport04", { body })
        .then((res) => res.json())
        .catch((error) => error);
};

const GetReport303 = ({doe,  st, distrib, storagearea}) => {
    const body = {
        doe,
        st,
        distrib,
        storagearea,
    };

    return executeQuery("GetReport303", { body })
        .then((res) => res.json())
        .catch((error) => error);
};

const GetReport06 = ({doe, model, st , manufacturerNumber}) => {
    const body = {
        doe,
        model,
        st,
        manufacturerNumber,
    };

    return executeQuery("GetReport06", { body })
        .then((res) => res.json())
        .catch((error) => error);
};

const getServiceTerritory = (props, signal) => {
    const body = {
        targetClass: props.targetClass,
        id: props?.id,
        order: props?.order,
        filter: props?.filter,
        isHierarchycal: props?.isHierarchycal,
        start: props?.start,
        length: props?.length,
        fastFilter: props?.fastFilter,
        closed: props.closed,
    };

    return executeQuery("getServiceTerritory", { body, signal })
        .then((res) => res.json())
        .catch((error) => error);
};

const getHolding = (props, signal) => {
    const body = {
        targetClass: props.targetClass,
        id: props?.id,
        order: props?.order,
        filter: props?.filter,
        isHierarchycal: props?.isHierarchycal,
        start: props?.start,
        length: props?.length,
        fastFilter: props?.fastFilter,
        closed: props.closed,
    };

    return executeQuery("getHolding", { body, signal })
        .then((res) => res.json())
        .catch((error) => error);
};

const GetReport304 = ({doe, distrib}) => {
    const body = {
        doe,  
        distrib,
    };

    return executeQuery("GetReport304", { body })
        .then((res) => res.json())
        .catch((error) => error);
};



const checkCanWin = async (
    docid

) => {
    const body = {
        docid
    };
    const response = await executeQuery("checkCanWin", { body });

    if (!response) 
        return { isOk: false, error: new Error("error") };

    if (!response.bodyUsed)
        return { isOk: response.ok };

    return { isOk: response.ok };
};


// Работа с файлами Аккаунт.
function getFilesListAccount({ docid, fileType }, signal, options = {}) {
    const body = {
        docid,
        fileType
    };

    return executeQuery("getFileListAccount", { ...options, signal, body })
        .then(async (res) => ({ isOk: res.ok, data: await res.json() }))
        .catch((error) => ({ isOk: false, error }));
}

const uploadFileToAccount = async (
    { name, data, additional = {} },
    signal,
    options = {}
) => {
    const body = {
        name,
        data,
        ...additional,
    };
    const response = await executeQuery("uploadFileToAccount", { ...options, body, signal });
    if (!response) return { isOk: false, error: new Error("error") };

    return { isOk: response.ok, data: await response.json() };
};

const deleteFileAccount = async ({ docid, ...rest }, signal, options = {}) => {
    const body = {
        ...rest,
        docid,
    };

    const response = await executeQuery("deleteFileAccount", { ...options, body, signal });

    if (!response) return { isOk: false, error: new Error("error") };

    return { isOk: response.ok, data: await response.json() };
};




const getRegion = async (
    data

) => {
    const body = {
        data
    };
    const response = await executeQuery("getRegion", { body });

    if (!response) return { isOk: false, error: new Error("error") };

    return { isOk: response.ok, data: await response.json() };

};



const getNewResponsibleForAction = async (
    typeDoc, 
    commandName,
    documentid

) => {
    const body = {
        typeDoc, 
        commandName,
        documentid
    };


    return executeQuery("getNewResponsibleForAction", { body })
    .then((res) => res.json())
    .catch((error) => error);
    
};


const planningVisits = async (
    docid, 

) => {
    const body = {
        docid, 
    };


    return executeQuery("planningVisits", { body })
    .then((res) => res.json())
    .catch((error) => error);
    
};


const createVisits = async (
    docid, 

) => {
    const body = {
        docid, 
    };


    return executeQuery("createVisits", { body })
    .then((res) => res.json())
    .catch((error) => error);
    
};

const createNewTradePoint = (body) => {
    return executeQuery("createNewTradePoint", { body })
        .then((res) => res.json())
        .catch((error) => error);
};


//Файлы активность
function getFilesListActivity({ docid, targetClass }, signal, options = {}) {    
    const body = {
        docid,
        targetClass,
    };

    return executeQuery("getFileListActivity", { ...options, signal, body })
        .then(async (res) => ({ isOk: res.ok, data: await res.json() }))
        .catch((error) => ({ isOk: false, error }));
}

function uploadFileToActivity(
    { name, data, additional = {} },
    signal,
    options = {}
) {
    const body = {
        name,
        data,
        ...additional,
    };

    return executeQuery("uploadFileToActivity", { ...options, body, signal })
        .then(async (res) => {
            if (res.bodyUsed) return { isOk: false };
            return {
                isOk: res.ok,
                data: await res.json(),
            };
        })
        .catch((error) => {
            error.requestParams = body;
            return { isOk: false, error };
        });
}

function deleteFileActivity({ docid, ...rest }, signal, options = {}) {
    const body = {
        ...rest,
        docid,
    };
    return executeQuery("deleteFileActivity", { ...options, body, signal })
        .then(async (res) => {
            if (res.bodyUsed) return { isOk: false };
            return { isOk: res.ok, data: await res.json() };
        })
        .catch((error) => {
            error.requestParams = body;
            return { isOk: false, error };
        });
}


function exportRep06(props) {
    const body = { ...props };

    return executeQuery("exportRep06", { body })
        .then((res) => res.json())
        .catch((err) => {
            err.reqParams = body;
            return err;
        });
}

const GetReport10 = ({doe, persona}) => {
    const body = {
        doe,
        persona
    };

    return executeQuery("GetReport10", { body })
        .then((res) => res.json())
        .catch((error) => error);
};


// export const addAuthRecord = async (body
// ) => {
//     try {
//         const response = await executeQuery("addAuthRecord", {
//             body,
//         });
//         if (!response) return { isOk: false };

//         return { isOk: response.ok };
//     } catch (error) {
//         return { isOk: false, error };
//     }
// };

// export const addLogoutTimeToAuthRecord = async (body
// ) => {
//     try {
//         const response = await executeQuery("addLogoutTimeToAuthRecord", {
//             body,
//         });
//         if (!response) return { isOk: false };

//         return { isOk: response.ok };
//     } catch (error) {
//         return { isOk: false, error };
//     }
// };


// export const getFastFiltersMyBrands = (docid) => {
//     const body = {
//         docid
//     };

//     return executeQuery("getFastFiltersMyBrands", { body })
//         .then(async (res) => ({isOk: res.ok, data: await res.json()}))
//         .catch((error) => ({isOk: false, error}));
// };


// export const GetConsuptionView301 = (targetPeriod) => {
//     const body = {
//         targetPeriod
//     };

//     return executeQuery("GetConsuptionView301", { body })
//         .then((res) => res.json())
//         .catch((error) => error);
// };

// export const startTargetPeriod = async ({
//     docid,
//     webUser,
// }) => {
//     const body = {docid, webUser };
//     try {
//         const response = await executeQuery("startTargetPeriod", {
//             body,
//         });
//         if (!response) return { isOk: false };

//         return { isOk: response.ok };
//     } catch (error) {
//         return { isOk: false, error };
//     }
// };
// export const getBrandNameForProduct = (product) => {
//     const body = {
//         product
//     };

//     return executeQuery("getBrandNameForProduct", { body })
//         .then((res) => res.json())
//         .catch((error) => error);
// };

const configs = {
    prod: {
        url: "https://np360.nestle.ru/api/v1/portaltb/"
    },
    prodAuth: {
        url: "https://np360.nestle.ru/api/v2/portaltb/",
        passportjs: true
    },
    alex: {
        url: "http://localhost:82/C4CWork/PortalTB/"
    }
};

setup$1(configs.alex);

const isEmpty = (value) => {
    return !(value?.length > 0);
};

// import libraries

const Login = (props) => {
    const data = o({ login: "", password: "" });
    const errors = o();

    const validateConfig = {
        login: { verify: isEmpty, message: "Заполните логин" },
        password: { verify: isEmpty, message: "Заполните пароль" },
    };
    const validate = validator(validateConfig);

    const login = Field({
        title: "Логин",
        required: true /* , width: "400" */,
        value: () => data().login,
        onChange: handleChange,
        error: () => errors()?.login,
        key: "login",
        type: "text",
    });
    const password = Field({
        title: "Пароль",
        required: true,
        type: "password" /* , width: "400" */,
        value: () => data().password,
        onChange: handleChange,
        error: () => errors()?.password,
        key: "password",
    });

    function handleChange({ key, value }) {
        const d = data();
        d[key] = value;
        data(d);
        // console.log(data(), d);

        const e = errors();
        if (!e || !Object.keys(e).includes(key)) return;

        delete e[key];
        errors(e);
    }
    // const submitButton = Button({text: "", type: ""});

    const authForm = html`
        <form class="auth-form" onsubmit=${handleSubmit}>
            ${login}${password}
            <${Button}
                text="Войти"
                type="submit"
                classNames=${["auth-form-button"]}
            />
        </form>
    `;

    let roles_visible = o(null);

    let rolesList = o([]);

    let roles = html`
        <div class="roles">
            <h4>Выберите Роль</h4>
            <div>
                ${map(rolesList, (role) => {
                    let roleEl = html`<p>${role.name}</p>`;
                    roleEl.addEventListener("click", () => {
                        localStorage.role = role.docid;
                        logIn(
                            login.getValue(),
                            password.getValue(),
                            role.docid
                        );

                        roles_visible(null);
                        location.href = "#";
                    });
                    return roleEl;
                })}
            </div>
        </div>
    `;

    function handleSubmit(e) {
        e.preventDefault();
        errors(validate(data()));
        if (errors()) return;

        if (login.getValue() === "" || password.getValue() === "")
            return Message$1(
                props?.alert || "Введите данные для входа!",
                "error"
            );

        authorization(login.getValue(), password.getValue(), ["project"]).then(
            handleAuth
        );
    }

    const handleAuth = (user) => {
        if (!user) return;
        if (user instanceof Error) {
            return console.error(user);
        }
        //Запись в журнал
        let locDevice;
        if (currentDevice["isAndroid"]())
            if (currentDevice["isMobile"]())
                locDevice = "AndroidPhone";
            else
                locDevice = "Android";
        else if (currentDevice["isiPad"]())
            locDevice = "iPad";
        else if (currentDevice["isiPhone"]())
            locDevice = "iPhone";
        else
            locDevice = "default";

        let locSession = login.getValue()+" "+Date.now();
        localStorageService.set("session",locSession);
        console.log("here");
        addAuthRec({
            userid: user.docid,
            ref: location.origin,
            device: locDevice,
            session: locSession,
        });
        
        if (user.roles?.length === 1) {
            localStorage.role = user.roles[0].docid;
            roles_visible(null);
            navigate("/");
            return;
        }        

        roles_visible(roles);
        rolesList(user.roles);
    };

    return html`
        <div class="auth">
            <div class="left-side">
                <h1>Авторизация</h1>
                ${authForm}
                <h1>Войти с помощью</h1>
                <${SSOButton}
                    url="https://np360.nestle.ru"
                    ssoPath="/api/v2/sso"
                    type="oauth2"
                    onAuth=${handleAuth}
                >
                    Nestle/ISACloud
                <//>
            </div>
            <div class="right-side">
               
                
            </div>
            ${roles_visible}
        </div>
    `;
};

const DropdownItemWithList = (props) => {

    const isOpen = o('');

    const iconPath = computed(()=>{
        if(isOpen() == 'open'){
            return '/assets/image/dropdown/folder-open.svg';
        }
        else {
            return '/assets/image/dropdown/folder.svg';
        }
    });

    const icon = html`<img src="${iconPath}"></img>`;
    const id = new Date().valueOf() + Math.random(new Date().valueOf()) + '-dropdown-item';
    const list = props.list;
    const behavior = props.behavior;
    const name = props.name;

    const dropdownList = DropdownList({
        list,
        behavior,
        listItems: props.listItems,
        setItems: props.setItems,
    });

    const classBehavior = computed(()=>{
        return behavior() === 'click' ? 'click-parent' : 'hover-parent'; 
    });

    const itemWithList = html`
        <li title="${name}" class="has-child ${classBehavior} ${isOpen}">
            <span class="custom-dropdown__item-with-list">
                ${icon}
                <span>
                    ${name}
                </span>
            </span>
            ${dropdownList}
        </li>
    `;
    itemWithList.id = id;
    props.setItems(itemWithList);

    const closeOtherItems = () => {
        const parentId = itemWithList.closest('ul').dataset.id;
        const allItemsInParent = [...document.querySelectorAll(`ul[data-id="${parentId}"]>li`)];
        const otherItems = allItemsInParent.filter(el => el.getAttribute('id') != id);
        otherItems.forEach(el => {
            el.isOpen('');
        });
    };

   
    const clickHandler = (event) => {
        event.stopPropagation();
        if(isOpen() === 'open'){
            isOpen('');
        }else {
            isOpen('open');
            closeOtherItems();
        }
    };

    subscribe$1(()=>{
        if(behavior() === 'click'){
            itemWithList.addEventListener('click', clickHandler);
        }else {
            itemWithList.removeEventListener('click', clickHandler);
        }
    });

    itemWithList.isOpen = isOpen;
    itemWithList.type = 'dropdown-item-with-list';

    return itemWithList;
};

const DropdownListItem = (props) => {
    
    const typeElement = props.typeElement;
    const name = props.name;
    const comandScript = props.comandScript;
    const list = props.elements;
    const callback = props.callback;
    const behavior = props.behavior;
    const id = new Date().valueOf() + Math.random(new Date().valueOf()) + '-dropdown-item';
    

    if(typeElement === 0){
        if(comandScript){
            const item = html`
                <li>
                    <a title="${name}" href="${comandScript}">
                        ${name}
                    </a>
                </li>`
            ;
            item.type = 'link';
            item.id = id;
            props.setItems(item);

            return item;
        }else {
            const item = html`<li title="${name}" onclick="${callback}">${name}</li>`;
            item.type = 'item-with-callback';
            item.id = id;
            props.setItems(item);
            return item;
        }
        
    }else {
        
        const item = DropdownItemWithList({
            list,
            behavior,
            name,
            listItems: props.listItems,
            setItems: props.setItems,
            
        });
       
        return item;
    }
};

const DropdownList = (props) => {
    
    const listArr = o(props.list);
    const behavior = props.behavior;
    const id = new Date().valueOf() + Math.random(new Date().valueOf()) + '-dropdown-item';

    const listEl = html`
        <ul data-id="${id}">
            ${map(listArr, item => 
                DropdownListItem({
                    ...item, 
                    behavior, 
                    listItems: props.listItems,
                    setItems: props.setItems,
                })
            )}
        </ul>`
    ;

    return listEl; 
};

const Dropdown = (props) => {

    //data
    const behavior = o(props.behavior ? props.behavior : 'click');
    const name = o(props.name ? props.name : '');
    const isOpen = o(false);
    const dataId = new Date().valueOf() + Math.random(new Date().valueOf()) + '-dropdown';
    const hideArr = o(props.hideArr ? true : false);
    const list = o(props.list);
    const listDirection = props.listDirection ? props.listDirection : 'left';

    
    

    const listItems = o([]);
    const setItems = (item) => {
        listItems().push(item);
        listItems(listItems()); 
    };
     
    //methods
    const open = () => isOpen(true);

    const close = () => isOpen(false);

    const toggle = () => isOpen() ? close() : open();

    function closeOtherDropdown(){
        const allDropdown = [...document.querySelectorAll('.custom-dropdown.open-dropdown')];

        const otherItems = allDropdown.filter(el => el.dataset.id != dataId);

        otherItems.forEach( el => {
            el.classList.remove('open-dropdown');
        }); 
    }

    const closeInnerDropdown = () => {
        listItems().forEach(li => {
            if('isOpen' in li){
                li.isOpen('');
            }
        });
    };

    function clickHandler(event){
        const {type} = event.target.dataset;
        let id = event.target.dataset.id;
        if(!id) id = event.target.closest('.custom-dropdown').dataset.id;

        if(type == 'toggle-dropdown' && id == dataId){
            toggle();
            closeOtherDropdown();
        }else if(type == 'backdrop'){
            close();
            closeInnerDropdown();
        }else if(type == 'dropdown-item'){
            close();
            closeInnerDropdown();
        }
    }

    //computed
    const dropdownArr = computed(()=>{
        if(!hideArr()){
            return html`<div class="custom-dropdown__arr" data-type="toggle-dropdown"></div>`
        }else {
            return '';
        }
    });
    const dropdownBackdrop = computed(()=>{
        if(behavior() === 'hover'){
            return '';
        }else {
            return html`<div class="custom-dropdown__backdrop" data-type="backdrop"></div>`;
        }
    });
    const dropdown_type_class = computed(()=>{
        if(behavior() === 'hover'){
            return '_hover';
        }else {
            return '_toggle';
        }
    });
    const dropdownOpenClass = computed(()=>{
        if(isOpen()){
            return 'open-dropdown';
        }else {
            return '';
        }
    });

    const badgeBox = html`<div class="custom-dropdown__badge-box"></div>`;
    const setBadge = (newBadge) => {
        badgeBox.append(newBadge);
    };
    //template
    const dropdown = html`
        <div class="custom-dropdown ${dropdownOpenClass} ${dropdown_type_class}" 
            data-type="toggle-dropdown"
            data-id="${dataId}"
        >   
            ${badgeBox}
            ${dropdownBackdrop}
            <div class="custom-dropdown__name" 
                data-type="toggle-dropdown" 
                data-id="${dataId}"
            >
                <div data-type="toggle-dropdown">${name} </div>
                ${dropdownArr}
            </div>
            <div class="custom-dropdown__list  ${listDirection}">
                ${DropdownList({
                    list: list(),
                    behavior: behavior,
                    listItems: listItems,
                    setItems: setItems
                })}
            </div>
        </div>`
    ;

    
    //watch
    subscribe$1(()=>{
        closeInnerDropdown();
        if(behavior() === 'click'){ //click
            dropdown.addEventListener('click', clickHandler);
        }else {//hover
            dropdown.removeEventListener('click', clickHandler);
        }
    });

    dropdown.isOpen = isOpen;
    dropdown.behavior = behavior;
    dropdown.name = name;
    dropdown.list = list;
    dropdown.id = dataId;
    dropdown.listItems = listItems;
    dropdown.setBadge = setBadge;

    return dropdown;
};

const NavbarItemDropdown = (props) => {

    const dropdown = Dropdown({
        name: props.name,
        list: props.list,
        hideArr: props.hideArr,
        listDirection: props.listDirection,
        behavior: props.behavior,
    });

    dropdown.componentType = 'dropdown';

    return dropdown;
};

const NavbaritemLink = (props) => {

    const badgeBox = html`<div class="custom-navbar__badge-box"></div>`;

    const item = html`
        <a href="${props.comandScript}">
            ${props.name}
        </a>
        ${badgeBox}
    `;

    const setBadge = (newBadge) => {
        badgeBox.append(newBadge);
    };

    item.componentType = 'link';

    item.setBadge = setBadge;

    return item;
};

const NavbarItem = (props) => {
    const { type } = props;

    const setupBadge = async (dataItem, parent) => {
        const dataBadge = await getBadge(dataItem);

        if (!dataBadge.isOk || !dataBadge.data) return;

        const count = dataBadge.data.badge;
        const badge = Badge({ count, theme: "primary" });

        parent.setBadge(badge);
    };

    if (type === "dropdown") {
        const dropdown = NavbarItemDropdown(props);

        if (props.Badge === true) {
            setupBadge(props, dropdown);
        }

        return dropdown;
    } else {
        const item = NavbaritemLink(props);

        if (props.Badge === true) {
            setupBadge(props, item);
        }
        return item;
    }
};

const Navbar = (props) => {

    //data
    const parent = props.parent;
    const dropdownBehavior = o(localStorage.navbarDropdownBehavior ? localStorage.navbarDropdownBehavior : 'click');
    const closeNavbarClass = o('');
    const direction = o(localStorage.navbarDirection ? localStorage.navbarDirection : '');
    const listDirection = o('left');

    const logoMain = props.logoMain;
    const logoSmall = props.logoSmall;
    const currentLogo = computed(() => {
        if(closeNavbarClass() === 'close'){
            return logoSmall;
        }else {
            return logoMain;
        }
    });

    if(direction()){
        if(direction() === 'left-navbar'){
            listDirection('right');
        }
        else if(direction() === 'top-navbar'){
            listDirection('left');
        }
    }

    const navItems = o([]);
    const nav = html`<ul class="nav">
        ${map(navItems, item =>
            html`<li>${item}</li>`
        )}
    </ul>`;

    const setNavItem = (props) => {
        const navbarItem = NavbarItem({
            ...props,
            listDirection,
        });

        navItems([...navItems(), navbarItem]);
    };

    const navbarWrapper = html`
    <div class="custom-navbar ${closeNavbarClass}" data-type="toggle-navbar">
        <div class="custom-navbar__logo" ><a href="#">${currentLogo}</a></div>
        <div class="custom-navbar__nav-wrapper">${nav}</div>
    </div>`;

    //methods
    const open = () => {
        closeNavbarClass('');
    };
    const close = () => {
        closeNavbarClass('close');
    };
    const toggle = () =>{
        closeNavbarClass() === 'close' ? open() : close();
    };
    const toggleNavbar = (event) => {
        const {type} = event.target.dataset;

        if(type == 'toggle-navbar'){ 
            toggle();
        }
    };
    const changeDirection = (name) => {
        return () => {
            direction(name);
            if(name === 'top-navbar'){
                listDirection('left');
            }else if(name === 'left-navbar'){
                listDirection('right'); 
            }
        }
    };

    const changeBehaviorDropdown = (type) => {
        return () => {
            dropdownBehavior(type);
            localStorage.setItem('navbarDropdownBehavior', type);
        }
    };

    const Setup = (dataInterface) => {
        dataInterface.elements.forEach(element => {

            const typeElement = element.typeElement;

            if(typeElement === 0){
                setNavItem(element);
            }else {
                setNavItem({ 
                    type: 'dropdown',
                    name: element.name,
                    list: element.elements
                });
            }
        });

         //профиль
         setNavItem({ 
            type: 'dropdown',
            name: localStorage.userName,
            list: [
                {   
                    typeElement: 0,
                    name: 'Профиль',
                    comandScript: '#cardfile/profile'
                },
                {   
                    typeElement: 0,
                    name: 'Выйти',
                    comandScript: '#logout'
                },
            ]
        });

        //settings
        setNavItem({
            type: 'dropdown',
            name: html`<img data-type="toggle-dropdown" src="assets/image/setting.svg"></img>`,
            hideArr: true,
            listDirection: 'left',
            list: [
                {   
                    typeElement: 1,
                    name: 'Настройки панели',
                    elements: [
                        { 
                            typeElement: 1,
                            name: 'Расположение',
                            elements: [
                                { typeElement: 0, name: 'Сверху', callback: changeDirection('top-navbar')},
                                { typeElement: 0, name: 'Слева', callback: changeDirection('left-navbar')},
                            ]
                        },
                        { 
                            typeElement: 1,
                            name: 'Поведение списков',
                            elements: [
                                { typeElement: 0, name: 'По клику', callback: changeBehaviorDropdown('click')},
                                { typeElement: 0, name: 'По наведению', callback: changeBehaviorDropdown('hover')},
                            ]
                        },
                    ]
                },
                {   
                    typeElement: 1,
                    name: 'Язык',
                    elements: [
                        {typeElement: 0, name: 'Русский'},
                        {typeElement: 0, name: 'Английский'},
                    ]
                },
            ]
        });
    };

    const Reset = () => {
        navItems([]);
    };

    //watch
    subscribe$1(()=>{
        direction();
        
        parent.classList.add('disactive');

        setTimeout(()=>{
        parent.classList.remove('disactive');
        parent.classList.value = `app-shell shell-application ${direction()}`;
            localStorage.setItem('navbarDirection', direction());
            if(direction() === 'left-navbar' || direction() === 'right-navbar'){
                navbarWrapper.addEventListener('click', toggleNavbar);
            }else {
                navbarWrapper.removeEventListener('click', toggleNavbar);
            }
        }, 300);
    });

    subscribe$1(()=>{
        dropdownBehavior();
        navItems().forEach(item => {
            if(item.componentType === 'dropdown') {
                item.behavior(dropdownBehavior());
                item.isOpen(false); 
            }
        });
    });

    navbarWrapper.setNavItem = setNavItem;
    navbarWrapper.changeDirection = changeDirection;
    navbarWrapper.changeBehaviorDropdown = changeBehaviorDropdown;
    navbarWrapper.Setup = Setup;
    navbarWrapper.Reset = Reset;

    return navbarWrapper; 
};

const SearchField = (
    {
        value,
        key = "search-field",
        onSearchBtnClick,
        onInput,
        onChange,
        loading,
        autocompleteItems,
        onAutocompleteItemClick,
        onClear,
        ItemComponent,
        class: className,
        title,
        showSearchButton,
        tooltip,
        ...rest
    },
    leftItem,
    rightItem
) => {
    showSearchButton =
        showSearchButton == null ? o(true) : getObservable(showSearchButton);
    function handleChange(ev) {
        onChange?.(ev.target.value, ev);
    }
    function handleInput(ev) {
        onInput?.(ev.target.value, ev);
    }
    function renderClearButton() {
        if (!value()) return;
        return html`<${Button}
            class="borderless transparent"
            onmousedown=${(ev) => ev.preventDefault()}
            disableTabFocus=${true}
            onClick=${onClear}
        >
            <${Icon} name="xmark" />
        <//>`;
    }

    const classNames = mergeClasses("search-field field-v2", className);
    const renderSearchButton = () => {
        if (!showSearchButton()) return;
        return html`
            <${Button}
                onmousedown=${(ev) => ev.preventDefault()}
                class="borderless transparent"
                disableTabFocus=${true}
                onClick=${onSearchBtnClick}
            >
                ${() =>
                    loading?.()
                        ? html`<span class="spinner" />`
                        : Icon({ name: "magnifying-glass" })}
            <//>
        `;
    };
    return html`<div class=${classNames} title=${tooltip}>
        ${leftItem}
        <input
            ...${rest}
            class="field-v2-input"
            value=${value}
            name=${key}
            oninput=${handleInput}
            onchange=${handleChange}
        />
        ${title ? html`<span class="field-v2-title">${title}</span>` : null}
        ${renderClearButton} ${renderSearchButton} ${rightItem}
        ${() =>
            autocompleteItems?.().length > 0
                ? Autocomplete({
                      ...rest,
                      items: autocompleteItems,
                      onClick: onAutocompleteItemClick,
                      ItemComponent,
                  })
                : null}
    </div>`;
};

const Autocomplete = ({ items, onClick, ItemComponent }) => {
    return html`<div class="autocomplete">
        <div class="scrollable">
            <${List} class="vertical autocomplete-list">
                ${map(items, (item) =>
                    ItemComponent
                        ? ItemComponent({ data: item, onClick })
                        : html`<${ListItem}
                              data-id=${item.id}
                              onclick=${(ev) => onClick?.(item, ev)}
                          >
                              ${item.name}
                          <//>`
                )}
            <//>
        </div>
    </div>`;
};

class Model$1 {
    #searchValue;
    #suggestions;
    #loading;
    #value;
    #key;
    #placeholder;
    #isCellField;
    #manualInput;
    #type;
    #tooltip;
    #enableManualInput;

    constructor({
        key,
        searchValue,
        placeholder,
        suggestions,
        loading,
        value,
        cellField,
        manualInput,
        type,
        tooltip,
        enableManualInput,
    } = {}) {
        this.#searchValue = o(searchValue ?? "");
        this.#suggestions = o(suggestions ?? []);
        this.#loading = o(loading ?? false);
        this.#value = getObservable(value);
        this.#key = key;
        this.#placeholder = getObservable(placeholder ?? "Поиск...");
        this.#isCellField = getObservable(cellField ?? false);
        this.#manualInput = o(manualInput ?? false);
        this.#type = type ?? "party";
        this.#enableManualInput = getObservable(enableManualInput ?? false);

        this.#tooltip =
            tooltip != null
                ? getObservable(tooltip)
                : computed(() =>
                      suggestionAsString({
                          data: this.#value(),
                          type: this.#type,
                      })
                  );
    }
    get placeholder() {
        return this.#placeholder;
    }
    set placeholder(newValue) {
        this.#placeholder(newValue);
    }

    get searchValue() {
        return this.#searchValue;
    }
    set searchValue(newValue) {
        this.#searchValue(newValue);
    }

    get suggestions() {
        return this.#suggestions;
    }
    set suggestions(newValue) {
        this.#suggestions(newValue);
    }

    get loading() {
        return this.#loading;
    }
    set loading(newValue) {
        this.#loading(newValue);
    }

    get value() {
        return this.#value;
    }
    set value(newValue) {
        this.#value(newValue);
    }

    get key() {
        return this.#key;
    }

    get isCellField() {
        return this.#isCellField;
    }

    get manualInput() {
        return this.#manualInput;
    }
    set manualInput(value) {
        this.#manualInput(value);
    }

    get type() {
        return this.#type;
    }
    get tooltip() {
        return this.#tooltip;
    }
    get isManualInputEnabled() {
        return this.#enableManualInput;
    }
}

class DaDataService {
    /** @type {DaDataService} */
    static instance;

    baseUrl = "https://suggestions.dadata.ru/suggestions/api/4_1/rs/suggest";
    suggestions = {
        party: "/party",
        address: "/address",
    };
    token = "";

    constructor(token) {
        this.token = token;
    }

    createSuggestionsOptions({ query }, signal) {
        return {
            method: "POST",
            mode: "cors",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
                Authorization: "Token " + this.token,
            },
            body: JSON.stringify({ query }),
            signal: signal,
        };
    }

    async fetch(path, options) {
        const response = await fetch(this.baseUrl + path, options);
        return {
            isOk: response.ok,
            data: (await response.json())?.suggestions ?? [],
        };
    }

    async getSuggestions({ query, type }, signal) {
        if (!type) throw new SyntaxError("Type is undefined");
        const options = this.createSuggestionsOptions({ query }, signal);
        return this.fetch(this.suggestions[type], options);
    }

    static getInstance() {
        if (!DaDataService.instance) {
            DaDataService.instance = new DaDataService(
                "19e3778c4f17f0226ebad4bedb820f289ac14c75"
            );
        }
        return DaDataService.instance;
    }
}

/**
 *
 * @param {{
 * onCompanySelect?: ({company}) => void,
 * model?: Model
 * }} param0
 * @returns
 */
const DaDataSearchField = ({
    onSuggestionSelect,
    onChange,
    class: className,
    ...rest
}) => {
    /**@type {Model} */
    const model = rest.model ?? new Model$1(rest);
    // отмена запроса
    let abortController = new AbortController();
    const dadataService = DaDataService.getInstance();
    const cellFieldClass = computed(() =>
        model.isCellField() ? "field-v2--cell" : ""
    );
    const classNames = mergeClasses(
        "dadata-company-search-field",
        className,
        cellFieldClass
    );

    // выполняется только спустя 500 ms после последнего введенного символа
    const searchForDadataItems = debounce$1(async ({ search }) => {
        try {
            model.loading = true;

            const result = await dadataService.getSuggestions(
                { query: search, type: model.type },
                abortController.signal
            );

            if (result.isOk) {
                model.suggestions = result.data;
            }
        } catch (error) {
            console.error(error);
        } finally {
            model.loading = false;
        }
    }, 500);

    /**
     *
     * @param {string} searchValue
     * @param {InputEvent} ev
     * @returns
     */
    const handleSearch = (searchValue, ev) => {
        if (model.searchValue() === searchValue) return;
        if (model.manualInput()) {
            if (ev.type === "input") return;
            handleChange({ value: searchValue });
        } else {
            if (model.value()?.value) {
                handleChange(null);
                // searchValue = "";
            }

            model.searchValue = searchValue;

            if (searchValue) {
                if (!abortController.signal.aborted) {
                    abortController.abort("NewSearch");
                }
                abortController = new AbortController();

                searchForDadataItems({ search: searchValue });
            } else {
                if (!abortController.signal.aborted) {
                    abortController.abort("EmptySearch");
                }
                model.suggestions = [];
            }
        }
    };

    const handleChange = (data) => {
        model.suggestions = [];
        if (onSuggestionSelect) {
            return onSuggestionSelect({ data });
        }
        if (onChange) {
            return onChange({ value: data, key: model.key });
        } else {
            model.value = data;
        }
    };
    const handleClear = () => {
        if (model.loading()) {
            model.loading = false;
            abortController.abort("ClearSearch");
        }
        handleChange(null);
        model.suggestions = [];
        model.searchValue = "";
    };

    const handleManualInputChange = (ev) => {
        const { target } = ev;
        model.manualInput = target.checked;
        model.suggestions = [];
    };

    const renderManualInputCheckbox = () => {
        if (!model.isManualInputEnabled()) return;
        return html`
            <input
                class="dadata-company-search-field__manual-input"
                type="checkbox"
                checked=${model.manualInput}
                disabled=${rest.disabled}
                onchange=${handleManualInputChange}
                title="Вкл/Выкл ручной ввод"
            />
        `;
    };

    const element = html`
        <${SearchField}
            ...${rest}
            value=${model.searchValue}
            key="dadata-company-search-field"
            loading=${model.loading}
            onInput=${handleSearch}
            onChange=${handleSearch}
            autocompleteItems=${model.suggestions}
            onAutocompleteItemClick=${handleChange}
            onClear=${handleClear}
            ItemComponent=${(props) =>
                SuggestionItem({ ...props, type: model.type })}
            placeholder=${model.placeholder}
            class=${classNames}
            showSearchButton=${rest.showSearchButton ??
            (() => (model.manualInput() ? false : true))}
            tooltip=${model.tooltip}
        >
            ${null}${renderManualInputCheckbox}
        <//>
    `;

    on(model.value, () => {
        if (model.value()) {
            model.searchValue = model.value().value;
        }
    });

    return element;
};

const SuggestionItem = ({ data, onClick, type }) => {
    function handleClick(ev) {
        onClick?.(data, ev);
    }
    const element = html`<${ListItem} onclick=${handleClick}>
        ${suggestionAsString({ data, type })}
    <//>`;

    return element;
};

const suggestionAsString = ({ data, type }) => {
    if (!data) return "";
    switch (type) {
        case "party": {
            const address = data?.data?.address?.value;
            const value = data?.value;
            if (!address) return value;
            return `${data.value}, ${data.data.address.value}`;
        }
        default:
            return data.value;
    }
};

const Test = () => {
    return html`<${DaDataSearchField} />`;
};

//import { CardFileControlCommand } from "../../CardFiles/References/CardFileControlCommand/index.js";




const BlankControlCommand = (props, docid) => {
    let blankName = docid ? "Команда управления: " + props.Name : "Новая команда управления";
    let blank = Blank({ data: props, title: blankName, docid });

    let Name = blank.createField({ title: "Имя", key: "Name", type: "string", width: 300 });
    let КлассРеализацииКоманды = blank.createField({ title: "Тип Команды", key: "КлассРеализацииКоманды", type: "string", width: 300 });
    let Значение = blank.createField({ title: "Значение", key: "Значение", type: "string", width: 300 });

    let headerRow = blank.createRow();
    //let centerRow = blank.createRow();
    //let bottomRow = blank.createRow();

    headerRow.addItems([Name, КлассРеализацииКоманды,Значение]);
    //centerRow.addItems([Значение]);
    //bottomRow.addItems([FileName, FileTime, FileSize,DownloadButton]);

    blank.addItem(headerRow);
    //blank.addItem(centerRow);
    //blank.addItem(bottomRow);

    return blank;
};

const CardFileControlCommand = props => {
    let tableHelper = TableHelper();

    let column_props = [
        { id: "IsGroup", text: "", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "display: flex; height: 100%; justify-content: center; align-items: center;", order: "type", fixWidth: 25, callback: tableHelper.fileOrFolder }, //TODO
        { id: "Name", text: "Имя", order : "Name",  style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", width: 25 },
        { id: "КлассРеализацииКоманды", text: "Тип Команды", order: "КлассРеализацииКоманды", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", width: 25 },
        { id: "Значение", text: "Значение", order: "Значение", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", width: 25 },       

        { id: "docid", text: "DOCID", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", order: "docid", width: 5, isHidden: true },
        { id: "CreateDate", text: "Дата создания", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", order: "CreateDate", width: 12, isHidden: true },
        { id: "CreateUser", text: "Кто создал", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", order: "CreateUser", width: 15, isHidden: true },
        { id: "UpdateDate", text: "Дата изменения", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", order: "UpdateDate", width: 12, isHidden: true },
        { id: "UpdateUser", text: "Кто изменил", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", order: "UpdateUser", width: 15, isHidden: true },
    ];

     let cardFile = CardFile({ targetClass: "BaseInt.НастройкаИнтерфейсаИДоступа.КомандаУправления", rootName: "Команда Управления", cardWidth: 80, column_props: column_props, inModal: props?.inModal, callBackElement: props?.callBackElement });

    cardFile.setBlank(BlankControlCommand); // set your blank on cardFile

    cardFile.urlPath = "ControlCommand";


    return cardFile;
 };

const BlankInterfacePanel = (props, docid) => {
    let blankName = docid ? "Интерфейсная панель: " + props.Name : "Новая интерфейсная панель";
    let blank = Blank({ data: props, title: blankName, docid });

    let Name = blank.createField({ title: "Имя", key: "Name", type: "string", width: 300 });
    let Code = blank.createField({ title: "Код", key: "Code", type: "string", width: 300 });
    

    let column_props = [
        { id: "ВидЭлемента", text: "Вид Элемента", style: 'text-align: center; width: 100%; justify-content: center;',  styleCell: "display: flex; height: 100%; justify-content: center; align-items: center;", width: 30, type: "input"},
        { id: "КомандаУправления", text: "Команда", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "display: flex; height: 100%; justify-content: center; align-items: center;", width: 60, type: "input", reference: CardFileControlCommand},
        { id: "Субпанель", text: "Субпанель", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "display: flex; height: 100%; justify-content: center; align-items: center;", width: 60, type: "input", reference: CardFileInterfacePanel},
        { id: "ВиденВДереве", text: "Виден", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "display: flex; height: 100%; justify-content: center; align-items: center;", width: 30, type: "checkbox"},
    ];

    let new_row_СоставПанели_table = [
        {
            ВидЭлемента: "",
            КомандаУправления: "",
            Субпанель: "",
            ВиденВДереве: "",
        }
    ];

    let СоставПанелиTable = blank.createTable({ column_props, tableWidth: 50, key: "СоставПанели" });

    let addRowСоставПанели = html`<button class="add-button"></button>`;
    addRowСоставПанели.addEventListener("click", e => {
        e.preventDefault();
        СоставПанелиTable.createRows(new_row_СоставПанели_table);
    });

    let tableWidthAddButton = html`
        <div style="display: flex; margin-bottom: 10px;">
            ${СоставПанелиTable}
            ${addRowСоставПанели}
        </div>
    `;
    
 
   
    let headerRow = blank.createRow();
    //let centerRow = blank.createRow();
    //let bottomRow = blank.createRow();

    headerRow.addItems([Name, Code]);
    //centerRow.addItems([code,Description]);
    //bottomRow.addItems([FileName, FileTime, FileSize,DownloadButton]);

    blank.addItem(headerRow);
    blank.addItem(tableWidthAddButton);
    
    //blank.addItem(centerRow);
    //blank.addItem(bottomRow);

    return blank;
};

const CardFileInterfacePanel = props => {
    let tableHelper = TableHelper();

    let column_props = [
        { id: "IsGroup", text: "", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "display: flex; height: 100%; justify-content: center; align-items: center;", order: "type", fixWidth: 25, callback: tableHelper.fileOrFolder }, //TODO
        { id: "Code", text: "Код",order : "Code", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", width: 25 },
        { id: "Name", text: "Имя", order : "Name",  style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", width: 25 },

        { id: "docid", text: "DOCID", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", order: "docid", width: 5, isHidden: true },
        { id: "CreateDate", text: "Дата создания", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", order: "CreateDate", width: 12, isHidden: true },
        { id: "CreateUser", text: "Кто создал", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", order: "CreateUser", width: 15, isHidden: true },
        { id: "UpdateDate", text: "Дата изменения", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", order: "UpdateDate", width: 12, isHidden: true },
        { id: "UpdateUser", text: "Кто изменил", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", order: "UpdateUser", width: 15, isHidden: true },
    ];

     let cardFile = CardFile({ targetClass: "BaseInt.НастройкаИнтерфейсаИДоступа.ИнтерфейснаяПанель", rootName: "Интерфейсная панель", cardWidth: 80, column_props: column_props, inModal: props?.inModal, callBackElement: props?.callBackElement });

    cardFile.setBlank(BlankInterfacePanel); // set your blank on cardFile

    cardFile.urlPath = "InterfacePanel";


    return cardFile;
 };

// import { RefreshRightsForRole } from "../../../../api";

const BlankRoles = (props, docid) => {
    let blankName = docid ? "Роль: " + props.docid : "Новая роль:";
    const { cardFile } = props;
    const loader = Loader();
    const settings = {
        targetClass:
            cardFile?.targetClass ?? "Kernel.Settings.Role",
    };

    let blank = Blank({ data: props, title: blankName, docid});

    const columnStyle =
        "text-align: center;width: 100%;justify-content: center;align-items: center;height: 100%;overflow: initial;text-overflow: initial;";
    let columnProps = [
        {
            id: "RecordName",
            // text: "Наименование записи",
            // style: columnStyle,
            // styleCell: "text-align: left;",
            // fixWidth: 300,
            isHidden: true,
        },
        {
            id: "RecordTitleName",
            text: "Наименование записи",
            style: columnStyle,
            styleCell: "text-align: left;",
            fixWidth: 300,
            type: "text",
        },
        {
            id: "CanEdit",
            text: "Редактирование",
            style: columnStyle,
            styleCell:
                "display: flex;  height: 100%; justify-content: center; align-items: center;",
            fixWidth: 150,
            type: "checkbox",
        },
        {
            id: "CanDelete",
            text: "Удаление",
            style: columnStyle,
            styleCell:
                "display: flex;  height: 100%; justify-content: center; align-items: center;",
            fixWidth: 150,
            type: "checkbox",
        },
        {
            id: "CanAdd",
            text: "Добавление",
            style: columnStyle,
            styleCell:
                "display: flex;  height: 100%; justify-content: center; align-items: center;",
            fixWidth: 150,
            type: "checkbox",
        },
        {
            id: "CanVisible",
            text: "Видимость",
            style: columnStyle,
            styleCell:
                "display: flex;  height: 100%; justify-content: center; align-items: center;",
            fixWidth: 150,
            type: "checkbox",
        },
    ];

    let rightTable = blank.createTable({
        column_props: columnProps,
        tableWidth: 400,
        key: "ПраваДоступаКЗаписям",
    });

    const getRightsonClick = async () => {
        loader.show();
        //Сохранение бланка перед отправкой
        createOrUpdateRecord(
            settings.targetClass,
            blank.getData()
        );
        //Получить данные для подтаблицы
        try {
            await RefreshRightsForRole(docid);

            blank.refreshData(docid);
        } finally {
            loader.hide();
        }
    };

    const getRights = html`<${Button} onClick=${getRightsonClick}
        >Обновить права<//
    >`;


    let infoTabContent = html`
        <div class="info-tab-content">
            ${rightTable}
        </div>
    `;

    const blankActionView = blank.actionView(true);

    let name = blank.createField({ title: "Имя", key: "Name", type: "string", width: 800});
    let description = blank.createField({ title: "Описание", key: "Description", type: "string", width: 800});
    let panel = blank.createField({ title: "Интерфейсная панель", key: "InterfacePanel", reference: CardFileInterfacePanel, width: 590});
    let disabled = blank.createField({ title: "Отключено", key: "Disabled", type: "checkbox", width: 200});

    let headerRow = blank.createRow();
    let bottomRow = blank.createRow();
    let lowRow = blank.createRow();

    headerRow.addItems([name]);
    bottomRow.addItems([description]);
    lowRow.addItems([panel, disabled]);

    blank.addItem(headerRow);
    blank.addItem(bottomRow);
    blank.addItem(lowRow);
    blank.addItem(infoTabContent);
    blankActionView.addItems([getRights]);

    return blank;

};

const CardRoles = props => {
    let tableHelper = TableHelper();

    let column_props = [
        {
            id: "IsGroup",
            text: "",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell:
                "display: flex; height: 100%; justify-content: center; align-items: center;",
            order: "IsGroup",
            fixWidth: 25,
            callback: tableHelper.fileOrFolder,
        }, //TODO
        {
            id: "Name",
            text: "Имя",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 30,
        },
        {
            id: "Description",
            text: "Описание",
            order: "Description",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 60
        }, 
    ];

    let cardFile = CardFile({ targetClass: "Kernel.Settings.Role", rootName: "Роли", cardWidth: 85, column_props: column_props, inModal: props?.inModal, callBackElement: props?.callBackElement });

    cardFile.setBlank(BlankRoles); // set your blank on cardFile

    cardFile.urlPath = "roles";

    return cardFile;
};

const BlankStatus = (props, docid) => {
   // let blankName = "Account";
    let blank = Blank({ data: props, title: "Статус:", docid});
    
    let ID = blank.createField({title: "docid", key: "docid", type: "integer", width: 100});
    let name = blank.createField({title: "Наименование", key: "Name", type: "string", width: 340});
    
    let row1 = blank.createRow();
   
    row1.addItems([ID,name]);

    blank.addItem(row1);

    return blank;

};

//import { BlankEmployee } from "../../../Blanks/BlankEmployee/index.js";
//import { BlankProject } from "../../../Blanks/References/BlankProject/index.js"

const settings$1b = {
    targetClass: "BaseInt.Status",
    rootName: "Статус",
    urlPath: "status",
};

const CardStatus = (props) => {
    let tableHelper = TableHelper();

    let column_props = [
        {
            id: "IsGroup",
            text: "",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell:
                "display: flex; height: 100%; justify-content: center; align-items: center;",
            order: "IsGroup",
            fixWidth: 25,
            callback: tableHelper.fileOrFolder,
        },
        {
            id: "docid",
            text: "docid",
            order: "DocID",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 6,
            isHidden: true,
        },
        {
            id: "Name",
            text: "Название",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            // order: "name",
            width: 24,
        },
    ];

    let cardFile = CardFile({
        ...props,
        ...settings$1b,
        cardWidth: 85,
        column_props: column_props,
        hierarchicalNodeName: "Имя",
    });

    cardFile.setBlank(BlankStatus); // set your blank on cardFile

    // cardFile.setConstFilter("");

    cardFile.urlPath = settings$1b.urlPath;

    return cardFile;
};

CardStatus.settings = settings$1b;

//import { Message } from "Core/index.js";
//import { createOrUpdateRecord, getRecord } from "Core/api/index.js";
// import { getUserId } from "Core/utils/index";

const BlankClientType = (props, docid) => {
    let blankName = docid ? "Тип клиента:" : "Новый тип клиента:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-clienttype",
        [HELP_KEYS.PROJECT]: 3302,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 170,
    });
    
    let row1 = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);


    return blank;
};

const settings$1a = {
    targetClass: "C4C.Справочники.ТипКлиента",
    rootName: "Тип клиента",
    urlPath: "ClientType",
    __projectId__: 3302,
};

const CardClientType = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$1a,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankClientType);

    cardFile.urlPath = settings$1a.urlPath;


    return cardFile;
};

CardClientType.settings = settings$1a;

const settings$19 = {
    targetClass: "C4C.Справочники.Account",
    rootName: "Клиенты",
    urlPath: "Account",
    __projectId__: 3408,
};

const CardAccount = (props) => {

    getUserId();
    const searchValue = o("");

    let column_props = [
        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
        {
            id: "ТипКлиента",
            text: "Тип клиента",
            order: "ТипКлиента.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
        {
            id: "ЮрНаименование",
            text: "Юр. наименование",
            order: "ЮрНаименование",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },

        {
            id: "СервиснаяТерритория",
            text: "Сервисная территория",
            order: "СервиснаяТерритория.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },

        {
            id: "Ответственный",
            text: "Ответственный",
            order: "Ответственный.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },
        
        {
            id: "ИНН",
            text: "ИНН",
            order: "ИНН",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
        {
            id: "КПП",
            text: "КПП",
            order: "КПП",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
        {
            id: "Контрагент",
            text: "Контрагент",
            order: "Контрагент.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
        {
            id: "Адрес",
            text: "Адрес",
            order: "Адрес",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
        
        {
            id: "СтатусНаличияФото",
            text: "Наличие фото",
            order: "СтатусНаличияФото.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];
    
    const handleSearchChange = () => {
        const filter = ("Match(AccountID,'*"+searchValue()+"*') or "+
                        "Match(ИНН,'*"+searchValue()+"*') or "+
                        "Match(КПП,'*"+searchValue()+"*') or "+
                        "Match(Name,'*"+searchValue()+"*') or "+
                        "Match(ЮрНаименование,'*"+searchValue()+"*') or "+
                        "Match(Адрес,'*"+searchValue()+"*')");
        if (searchValue()!="")
            cardFile.setIsHierarchycal(false);
        else
            cardFile.setIsHierarchycal(true);                        
        cardFile.setConstFilter(filter);
        cardFile.updateTable();
    };
    const handleSearchInput = (value) => searchValue(value);
    const handleSearchClear = () => {
        handleSearchInput("");
        handleSearchChange();
    };

    let cardFile = CardFile({
        ...settings$19,        
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
        customTools: html`
            <div class="search-tools">                
                <${SearchField}
                    value=${searchValue}
                    onInput=${handleSearchInput}
                    onChange=${handleSearchChange}
                    onClear=${handleSearchClear}
                    placeholder=${"AccountID, наименование, адрес, ИНН, КПП"}
                    showSearchButton=${false}
                />
            </div>
        `,
        class: "account-card-file",
        ...props,
    });

    cardFile.setBlank(BlankAccountSwitch);

    cardFile.urlPath = settings$19.urlPath;


    return cardFile;
};

CardAccount.settings = settings$19;

const BlankInstallationLocation = (props, docid) => {
    let blankName = "Место установки:";
    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-installationlocation",
        [HELP_KEYS.PROJECT]: 3396,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 400,
    });
    let ТорговаяТочка = blank.createField({
        title: "Торговая точка",
        key: "ТорговаяТочка",
        reference: CardAccount,
        width: 400,
        disabled: props.inBlank,
    });

    const filesUploadField = new FilesUploadField({
        onSaveFile: ({ name, data }) => {
            //console.log(name,data);
            return uploadFile(
                name,
                data,
                "C4C.Справочники.МестоУстановки");
        },
        onDeleteFile: deleteFile,
        addFileBtnText: "Добавить",
        uploadFilesBtnText: "Сохранить",
        title: "Файлы",
    });

    if (docid != null && docid > 0) {
        getFilesList({
            docid,
            targetClass: "C4C.Справочники.МестоУстановки",
        }).then((res) => {
            //                console.log(res);
            filesUploadField.setFiles(res.data.data);
        });
    }

    const fileElement = html` ${docid != null
        ? filesUploadField.render()
        : undefined}`;
 
    let row1 = blank.createRow();
    let row2 = blank.createRow();
    let row3 = blank.createRow();

    row1.addItems([name]);
    row2.addItems([ТорговаяТочка]);
    row3.addItems([fileElement]);

    blank.addItem(row1);
    blank.addItem(row2);
    blank.addItem(row3);    

    return blank;
};

const settings$18 = {
    targetClass: "C4C.Справочники.МестоУстановки",
    rootName: "Место установки",
    urlPath: "InstallationLocation",
    __projectId__: 3396,
};

const CardInstallationLocation = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "ТорговаяТочка",
            text: "Торговая точка",
            order: "ТорговаяТочка.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$18,
        ...props,
        cardWidth: 90,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
        initTree: false,
    });
    cardFile.setBlank((blankprops,docid)=> {
        if (props?.curTradePoint)
            blankprops.ТорговаяТочка = props.curTradePoint;
        if (props?.inBlank)
            blankprops.inBlank = true;
        return BlankInstallationLocation(
        blankprops,
        docid
        ) 
        }
    );

    cardFile.urlPath = settings$18.urlPath;


    return cardFile;
};

CardInstallationLocation.settings = settings$18;

//import { Message } from "Core/index.js";
//import { createOrUpdateRecord, getRecord } from "Core/api/index.js";
// import { getUserId } from "Core/utils/index";

const BlankRegion = (props, docid) => {
    let blankName = docid ? "Регион:" : "Новый регион:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-region",
        [HELP_KEYS.PROJECT]: 3368,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 170,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);
    blank.addItem(row1);
    
    return blank;
};

const settings$17 = {
    targetClass: "C4C.Справочники.Регион",
    rootName: "Регион",
    urlPath: "Region",
    __projectId__: 3368,
};

const CardRegion = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },

        {
            id: "region_fias_id",
            text: "region_fias_id",
            order: "region_fias_id",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
            isHidden: true,
        },
        
        {
            id: "region_with_type",
            text: "region_with_type",
            order: "region_with_type",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
            isHidden: true,
        },

        {
            id: "kladr_id",
            text: "kladr_id",
            order: "kladr_id",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
            isHidden: true,
        },

        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
            isHidden: true,
        },
    ];

    let cardFile = CardFile({
        ...settings$17,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankRegion);

    cardFile.urlPath = settings$17.urlPath;


    return cardFile;
};

CardRegion.settings = settings$17;

const BlankIndustry = (props, docid) => {
    let blankName = docid ? "Отрасль:" : "Новая отрасль:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-industry",
        [HELP_KEYS.PROJECT]: 3341,
    });

    let code = blank.createField({
        title: "Код",
        key: "Code",
        type: "string",
        width: 100,
    });

    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 300,
    });

    let nameEU = blank.createField({
        title: "Наименование на английском",
        key: "nameEU",
        type: "string",
        width: 408,
    });
 
    let row1 = blank.createRow();

    row1.addItems([code, name]);

    let row2 = blank.createRow();
    row2.addItems([nameEU]);
    
    blank.addItem(row1);
    blank.addItem(row2);

    return blank;
};

const settings$16 = {
    targetClass: "C4C.Справочники.Отрасль",
    rootName: "Отрасль",
    urlPath: "Industry",
    __projectId__: 3341,
};

const CardIndustry = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Code",
            text: "Код",
            order: "Code",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 150,
        },

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 300,
        },

        {
            id: "nameEU",
            text: "Наименование на английском",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 300,
        },


        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
            isHidden: true,
        },
    ];

    let cardFile = CardFile({
        ...settings$16,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankIndustry);   

    cardFile.urlPath = settings$16.urlPath;


    return cardFile;
};

CardIndustry.settings = settings$16;

const BlankCustomerSegment = (props, docid) => {
    let blankName = docid ? "Отраслевой сегмент:" : "Новый отраслевой сегмент:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-customersegment",
        [HELP_KEYS.PROJECT]: 3345,
    });
   
    let code = blank.createField({
        title: "Код",
        key: "Code",
        type: "string",
        width: 100,
    });

    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 300,
    });

    let nameEU = blank.createField({
        title: "Наименование на английском",
        key: "nameEU",
        type: "string",
        width: 408,
    });

    let industry = blank.createField({
        title: "Отрасль",
        key: "Отрасль",
        reference: CardIndustry,
        width: 408,
    });
 
    let row1 = blank.createRow();

    row1.addItems([code, name]);

    let row2 = blank.createRow();
    row2.addItems([nameEU]);
    

    let row3 = blank.createRow();
    row3.addItems([industry]);

    blank.addItem(row1);
    blank.addItem(row2);
    blank.addItem(row3);


    return blank;
};

const settings$15 = {
    targetClass: "C4C.Справочники.СегментКлиента",
    rootName: "Отраслевой сегмент",
    urlPath: "CustomerSegment",
    __projectId__: 3345,
};

const CardCustomerSegment = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Code",
            text: "Код",
            order: "Code",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 150,
        },

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 300,
        },

        {
            id: "nameEU",
            text: "Наименование на английском",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 300,
        },

        {
            id: "Отрасль",
            text: "Отрасль",
            order: "Отрасль.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 450,
        },

        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
            isHidden: true,
        },
    ];

    let cardFile = CardFile({
        ...settings$15,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankCustomerSegment);

    cardFile.urlPath = settings$15.urlPath;


    return cardFile;
};

CardCustomerSegment.settings = settings$15;

class Model {
    constructor({
        users = [],
        displayValue: path,
        cardFile = CardFileEmployee,
        targetClass,
        docid,
        searchKeys = ["Name"],
    }) {
        this.users = o(users.map((user) => ({ user, path })));
        this.cardFile = cardFile;
        this.targetClass = targetClass;
        this.docid = docid;
        this.path = path;
        this.isEmpty = computed(() => this.users().length === 0);
        this.contextMenuOpened = o(false);
        this.searchKeys = searchKeys;
        // subscribe(() => console.log(this.users()));
    }

    addUser(user, path = this.path) {
        const users = this.users();
        users.push({ user, path });
        this.users(users);
    }

    setUsers(users, path = this.path) {
        this.users(users.map((user) => ({ user, path })));
    }

    containsUser(user) {
        /**@type {Array} */
        const users = this.users();
        return (
            users.find(
                (item) =>
                    (item.user?.docid || item.user?.["Участник"]?.docid) ==
                    user.docid
            ) != null
        );
    }
}

const ParticipantsListItem = ({ path, user, onContextMenu }) => {
    const id = user.docid ?? user["Участник"].docid;
    const element = html`<${ListItem}
        class="participants-list-item"
        data-type="list-item"
        data-id=${id}
    >
        ${path != null ? get(user, path) : user}
    <//>`;
    element.addEventListener("contextmenu", (ev) => {
        ev.preventDefault();
        onContextMenu?.(id, ev);
    });

    return element;
};

/**
 *
 * @param {{model: Model}} param0
 * @returns
 */
const Template = ({ model, onAdd, onDelete }) => {
    const contextMenuOpened = computed(() =>
        model.contextMenuOpened() ? " open" : ""
    );

    const menu = html`<${List}
        class="participants-list__context-menu${contextMenuOpened}"
        onclick=${hideMenu}
    >
        <${ListItem}
            class="menu-item"
            onclick=${(ev) => onDelete?.(+menu.dataset.id, ev)}
        >
            <span>Удалить</span>
        <//>
    <//>`;

    // html`
    //    <div></div>
    // `

    const container = html`
        <div class="participants-list-container scrollable" style="width: 100%">
            <${List} class="participants-list">
                ${map(model.users, (item, _, arr) =>
                    ParticipantsListItem({
                        ...item,
                        index: arr.indexOf(item),
                        onContextMenu,
                    })
                )}
                <${ListItem}>
                    <div class="add" title="Добавить" onclick=${onAdd}>
                        <div class="add__icon"></div>
                        +
                    </div>
                <//>
            <//>
            ${menu}
        </div>
    `;

    function onContextMenu(id, ev) {
        // вычисляем позицию выпадающего меню на экране
        const rect = ev.target.getBoundingClientRect();

        menu.style.top = rect.top + "px";
        menu.style.left = rect.left + rect.width / 2 + "px";

        menu.dataset.id = id;
        document.addEventListener("mousedown", onMouseDown);
        model.contextMenuOpened(true);
    }

    function onMouseDown(ev) {
        // добавляем скрытие контекстного меню
        if (ev.target.closest(".participants-list__context-menu") === menu) {
            return;
        }
        if (!ev.target.closest(".participants-list-item")) {
            hideMenu();
        }
    }

    function hideMenu() {
        model.contextMenuOpened(false);
        document.removeEventListener("mousedown", onMouseDown);
        menu.dataset.index = undefined;
    }

    return container;
};

const SearchView = ({ onSearch }) => {
    const value = o("");
    const isActive = o(false);
    const active = computed(() => (isActive() ? " active" : ""));

    const input = html`<input
        class="field-v2-input${active}"
        name="search"
        type="text"
        value=${value}
        placeholder="Введите ФИО или email"
        autofocus
    />`;

    const element = html`<form
        style="display: flex; flex-direction: column; gap: 0.7em; min-width: 300px; width: 20vw; max-width: 500px"
    >
        <label class="field-v2${active}" style="margin-top: 0.7em">
            ${input}
        </label>
        <div style="display: flex; justify-content: flex-end;">
            <${Button} type="submit">Поиск<//>
        </div>
    </form>`;

    input.addEventListener("change", (ev) => value(ev.target.value));
    input.addEventListener("focus", () => isActive(true));
    input.addEventListener("blur", () => isActive(false));

    element.addEventListener("submit", (ev) => {
        ev.preventDefault();
        onSearch(value());
    });

    return element;
};

const ParticipantsList = (props) => {
    const model = new Model(props ?? {});
    const modal = Modal();

    const element = Template({
        model,
        onAdd: handleAdd,
        onDelete: handleDelete,
    });

    async function handleSelect(user) {
        if (!model.docid || !model.targetClass || !user) return;

        try {
            const result = await addToMembersForDocument({
                targetClass: model.targetClass,
                docid: model.docid,
                persona: user.docid,
            });
            if (result.isOk) {
                model.addUser(user, "Name");
            } else {
                result.error && console.error(result.error);
            }
        } catch (error) {
            console.error(error);
        } finally {
            modal.hide();
        }
    }

    function handleAdd() {
        if (!model.cardFile) return;
        // const contents = model.cardFile({ inModal: handleSelect });
        modal.setContent(SearchView({ onSearch }));
        modal.show();
    }

    async function onSearch(searchTxt) {
        const filter = model.searchKeys
            .map((key) => toFilter(key, searchTxt))
            .join(" or ");

        try {
            const result = await getHierarchyLevel({
                targetClass: model.cardFile.settings.targetClass,
                filter,
                length: 2,
                isHierarchycal: false,
            });

            if (result instanceof Error) {
                throw result;
            }

            const records = Object.values(result);
            if (records.length === 1) {
                handleSelect(records[0]);
                return;
            }
        } catch (error) {
            console.error(error);
        }

        const cardfile = model.cardFile({
            inModal: handleSelect,
            filter,
            isHierarchycal: false,
        });

        modal.setContent(cardfile);
        modal.show();
    }

    async function handleDelete(id) {
        if (id == null || isNaN(id) || !isFinite(id)) return;
        try {
            const index = model
                .users()
                .findIndex(
                    ({ user: u }) =>
                        u.docid === id || u["Участник"]?.docid === id
                );
            const data = model.users()[index];
            if (!data) return;
            const result = await deleteMemberFromDocument({
                targetClass: model.targetClass,
                docid: model.docid,
                persona: data.user.Участник?.docid ?? data.user.docid,
            });
            if (result.isOk) {
                /**@type {Array} */
                const users = model.users();
                users.splice(index, 1);
                model.users([...users]);
            } else {
                result.error && console.error(result.error);
            }
        } catch (error) {
            console.error(error);
        }
    }

    element.isEmpty = () => model.isEmpty();
    element.addUser = (...params) => model.addUser(...params);
    element.setUsers = (...params) => model.setUsers(...params);
    element.containsUser = (user) => model.containsUser(user);

    return element;
};

function toFilter(key, text) {
    return `Match(${key}, '*${text}*')`;
}

//import { Message } from "Core/index.js";
//import { createOrUpdateRecord, getRecord } from "Core/api/index.js";
// import { getUserId } from "Core/utils/index";

const BlankSalesPhase = (props, docid) => {
    let blankName = docid ? "Фаза продажи:" : "Новая фаза продажи:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-salesphase",
        [HELP_KEYS.PROJECT]: 3302,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 240,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);
    blank.addItem(row1);
    
    return blank;
};

const settings$14 = {
    targetClass: "C4C.Справочники.ФормаСобственности",
    rootName: "Форма cобственности",
    urlPath: "LegalType",
    __projectId__: 3302,
};

const CardLegalType = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$14,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    //cardFile.setBlank(BlankSalesPhase);

    cardFile.urlPath = settings$14.urlPath;


    return cardFile;
};

CardLegalType.settings = settings$14;

const EventNumber = ({ color, title, cardfile, id }, ...children) => {
    color = turboColorToHtml(color ?? "");
    const isLight = hexColorIsLight(color);
    const commonStyle = `--background: ${color}; --color: ${
        isLight ? "black" : "white"
    }`;
    if (!cardfile) {
        return html`<span
            class="tree-item__task-number"
            style=${commonStyle}
            title=${title}
        >
            ${children}
        </span>`;
    }
    return html`<a
        class="tree-item__task-number"
        style=${commonStyle}
        href="#cardfile/${cardfile}?id=${id}"
        target="_blank"
        title=${title}
    >
        ${children}
    </a>`;
};

const TreeItem = ({ data, level = 0, activeItem }) => {
    /**
     * @type {HTMLUListElement}
     */
    data.elements = o(data.elements);
    //const cardfile = EVENT_CARDFILES[data.typeEvent];
    const cardfile = data.typeEvent;
    const item = html`<li class="list-item tree-item" data-docid=${data.docid}>
        <${EventNumber}
            color=${data?.color}
            id=${data.docid}
            cardfile=${cardfile}
            title=${data.nameStatus}
        >
            ${data.docid}
        <//>
        <a href="#cardfile/${cardfile}?id=${data.docid}" style="color: black; text-decoration: none;">
            <span class="tree-item__text" style="color: inherit">${data.name}</span>
        </a>
        ${TreeList({
            elements: data.elements,
            level: level + 1,
            activeItem, 
        })}
    </li>`;

    if (level > 0) item.dataset.level = level;

    if (activeItem === data?.docid) item.dataset.active = true;

    return item;
};

function TreeList({ elements, level = 0, activeItem }) {
    return html`<ul class="list tree-list">
        ${map(elements, (el) => TreeItem({ data: el, level, activeItem }))}
    </ul>`;
}

const Tree = ({
    elements,
    activeItem,
    onCreateChild,
    onBindToParent,
    onUnbindToParent,
    hideButtons = false,
}) => {
    const treeList = TreeList({ elements, activeItem });
    return html`<div class="tree">
        <div class="scrollable" style="display: flex; flex-direction: column;">
            ${treeList}
        </div>
        ${!activeItem || hideButtons
            ? null
            : html`<div
                  style="display: flex; align-items: end; justify-content: right; gap: 0.5em; margin-top: 0.5em"
              >
                  ${() => {
                      if (onUnbindToParent != undefined)
                          return html`
                              <${Button} onClick=${onUnbindToParent}>
                                  Отвязать
                              <//>
                          `;
                  }}
                  ${() => {
                      if (onBindToParent != undefined)
                          return html`
                              <${Button} onClick=${onBindToParent}>
                                  Привязать
                              <//>
                          `;
                  }}
                  ${() => {
                      if (onCreateChild != undefined)
                          return html`
                              <${Button} onClick=${onCreateChild}>
                                  Создать визит
                              <//>
                          `;
                  }}
              </div> `}
    </div>`;
};

const BlankParameter = (props, docid) => {
    let blankName = "Параметр:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-parameter",
        [HELP_KEYS.PROJECT]: 3302,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 200,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$13 = {
    targetClass: "C4C.Справочники.Параметр",
    rootName: "Параметр",
    urlPath: "Parameter",
    __projectId__: 3302,
};

const CardParameter = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$13,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankParameter);

    cardFile.urlPath = settings$13.urlPath;


    return cardFile;
};

CardParameter.settings = settings$13;

//import { Message } from "Core/index.js";
//import { createOrUpdateRecord, getRecord } from "Core/api/index.js";
// import { getUserId } from "Core/utils/index";

const BlankFileType = (props, docid) => {
    let blankName = "Тип файла: ";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-filetype",
        //[HELP_KEYS.PROJECT]: 3363,
    });
    let id = blank.createField({
        title: "DocId",
        key: "docid",
        type: "string",
        width: 55,
        disabled: true,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 300,
    });
    let code = blank.createField({
        title: "Код",
        key: "Code",
        type: "string",
        width: 300,
    });


    let headerRow = blank.createRow();
    headerRow.addItems([id]);
    blank.addHeaderLeftItem(headerRow);
    let row1 = blank.createRow();
    let row2 = blank.createRow();
    //let lowRow = blank.createRow();

    row1.addItems([name]);
    row2.addItems([code]);

    blank.addItem(row1);
    blank.addItem(row2);

    return blank;
};

const settings$12 = {
    targetClass: "BaseInt.Служебные.ТипФайла",
    rootName: "Тип файла",
    urlPath: "FileType",
    //__projectId__: 3302,
};

const CardFileType = (props) => {

    getUserId();

    let column_props = [
        {
            id: "docid",
            text: "DocId",
            order: "docid",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 60,
        },
        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 300,
        },
        {
            id: "Code",
            text: "Код",
            order: "Код",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 300,
        },        
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$12,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankFileType);

    cardFile.urlPath = settings$12.urlPath;


    return cardFile;
};

CardFileType.settings = settings$12;

const BlankActivityType = (props, docid) => {
    let blankName = docid ? "Тип активности:" : "Новый тип активности:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-activitytype",
        [HELP_KEYS.PROJECT]: 3302,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: "100%",
    });
    let purpose = blank.createField({
        title: "Цель",
        key: "Цель",
        type: "textarea",
        width: "100%",
        height: 80,
    });

    //Подтаблица
    const positionProps = [
        {
            id: "Параметр",
            text: "Параметр",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 220,
            reference: CardParameter,
        },
        {
            id: "ТипДанных",
            text: "Тип данных",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
            type: "select",
            options: [{value: "Строка", text: "Строка"},
                      {value: "Число",  text: "Число"},
                      {value: "Логический", text: "Логический"}],
            dataType: "string",
        },
    ];

    const tablePositions = blank.createTable({
        column_props: positionProps,
        width: 300,
        key: "Позиции",
    });

    let addRowPositions = html`<button
        class="add-button"
        type="button"
    ></button>`;
    addRowPositions.addEventListener("click", (e) => {
        e.preventDefault();
        tablePositions.createEmptyRow();
    });
    //

    //Подтаблица
    const photoTypesProps = [
        {
            id: "ТипФото",
            text: "Тип фото",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 220,
            isHierarchycal: false,
            initTree: false,
            constFilter: "not docid in [1,2,3,4,5,6,7,8]",
            reference: CardFileType,
        },
    ];

    const tablePhotoTypes = blank.createTable({
        column_props: photoTypesProps,
        width: 300,
        key: "ТипыФото",
    });

    let addRowPhotoTypes = html`<button
        class="add-button"
        type="button"
    ></button>`;
    addRowPhotoTypes.addEventListener("click", (e) => {
        e.preventDefault();
        tablePhotoTypes.createEmptyRow();
    });
//
    
    let mainInfoItem = html`
    ${mainInfo$6({
        name, 
        purpose,
        tablePositions,
        addRowPositions,
        tablePhotoTypes,
        addRowPhotoTypes,
    })}
    `;

    blank.addItem(mainInfoItem);

    return blank;
};

const mainInfo$6 = (fields) => {
    function renderFields() {
        return html`
            <div class="blank-row">${fields.name}</div>
            <div class="blank-row">${fields.purpose}</div>
            <div class="blank-row">
                <div class="tables-container">
                    <div class="tableparameters-container">
                        ${fields.tablePositions}${fields.addRowPositions}
                    </div>
                    <div class="phototable-containter">
                        ${fields.tablePhotoTypes}${fields.addRowPhotoTypes}
                    </div>
                </div>
            </div>
        `;
    }
    return html`
        <!-- <div class="blank-mainInfo"> -->
            ${renderFields}
        <!-- </div> -->
    `;
};

const settings$11 = {
    targetClass: "C4C.Справочники.ТипАктивности",
    rootName: "Тип активности",
    urlPath: "ActivityType",
    __projectId__: 3302,
};

const CardActivityType = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 300,
        },
        {
            id: "Цель",
            text: "Цель",
            order: "Цель",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 500,
        },        
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$11,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankActivityType);

    cardFile.urlPath = settings$11.urlPath;


    return cardFile;
};

CardActivityType.settings = settings$11;

observe(".file-image");

const ImagePreviewItem = ({
    data = {},
    path = "",
    onFileClick,
    isNew = false,
    onFileDelete,
    disabled = () => false,
    tooltip,
}) => {
    const imageUrl = o();
    const imageData = o();
    const imageLoading = o(false);
    const name = isNew ? data.name : get(data, path);

    const unsubscribeImageUrl = subscribe$1(() => {
        let url = sample(imageUrl);
        const image = imageData();
        if (url) {
            URL.revokeObjectURL(url);
        }
        if (!image) {
            if (url) {
                imageUrl(null);
            }
        } else {
            const blob = new Blob([image], { type: "image/*" });
            url = URL.createObjectURL(blob);
            imageUrl(url);
        }
    });

    async function getImageFromDB() {
        // const filesResult = await getFilesList(
        //     {
        //         docid: data.docid,
        //         targetClass: settings.targetClass,
        //     },
        //     abortController.signal,
        //     { showErrors: false }
        // );
        // if (!filesResult.isOk) {
        //     return console.error(filesResult.error);
        // }

        // const imageInfo = filesResult.data.data[0];
        // if (!imageInfo) return;

        // state.image.alt(imageInfo.name ?? "");

        const imageResult = await getFile(data.docid, null, {
            showErrors: false,
        });
        if (imageResult instanceof Error) {
            return console.error(imageResult);
        }
        const uintArray = Uint8Array.from(
            imageResult.Data ?? imageResult.data,
            (c) => c.charCodeAt(0)
        );

        imageData(uintArray);
    }

    async function onConnected() {
        imageLoading(true);
        if (!isNew) {
            await getImageFromDB();
        } else {

            const binData = await getFileData(data);
            // imag
            const uintArray = Uint8Array.from(
                binData,
                (c) => c.charCodeAt(0)
            );
            imageData(uintArray);

        }
        imageLoading(false);

    }

    async function onDisconnected() {
        unsubscribeImageUrl();
    }

    function onDeleteBtnClick(ev) {
        ev.stopPropagation();
        onFileDelete(data);
    }

    function handleFileClick(ev) {
        ev.stopPropagation();
        onFileClick(data);
    }

    const renderDeleteBtn = () => {
        if (disabled()) return null;
        return html`<${Button}
            type="button"
            disableTabFocus=${true}
            class="--transparent --borderless file-delete-btn"
            title="Удалить"
            onClick=${onDeleteBtnClick}
        >
            <${Icon}
            name="xmark" style="font-size: 24px; color: red;"/>            
        <//>`;
    };

    const element = html`<div
        class="files-list-v2-item file-image ${isNew ? " new" : ""}"
        title=${!tooltip ? name : tooltip({ data, path })}
    >
        <span class="file-name">${name}</span>
        <img
            class="file-image__preview"
            alt=${name}
            src=${imageUrl}
            data-loading=${imageLoading}
        />
        ${renderDeleteBtn}
    </div>`;

    element.addEventListener("connected", onConnected);
    element.addEventListener("disconnected", onDisconnected);
    element.addEventListener("click", handleFileClick);

    return element;
};

//import { Message } from "Core/index.js";
//import { createOrUpdateRecord, getRecord } from "Core/api/index.js";
// import { getUserId } from "Core/utils/index";

const BlankReasonForDeviation = (props, docid) => {
    let blankName = docid ? "Причина отклонения:" : "Новая причина отклонения:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-reasonfordeviation",
        [HELP_KEYS.PROJECT]: 3302,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 300,
    });
    
    let nameEU = blank.createField({
        title: "Наименование на английском",
        key: "nameEU",
        type: "string",
        width: 300,
    });
 
    let row1 = blank.createRow();
    let row2 = blank.createRow();
    row1.addItems([name]);
    row2.addItems([nameEU]);
    blank.addItem(row1);
    blank.addItem(row2);
    
    return blank;
};

const settings$10 = {
    targetClass: "C4C.Справочники.ПричинаОтклонения",
    rootName: "Причина отклонения",
    urlPath: "ReasonForDeviation",
    __projectId__: 3302,
};

const CardReasonForDeviation = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "nameEU",
            text: "Наименование на английском",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 250,
        },

    ];

    let cardFile = CardFile({
        ...settings$10,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankReasonForDeviation);

    cardFile.urlPath = settings$10.urlPath;


    return cardFile;
};

CardReasonForDeviation.settings = settings$10;

//import { Message } from "Core/index.js";
//import { createOrUpdateRecord, getRecord } from "Core/api/index.js";
// import { getUserId } from "Core/utils/index";

const BlankReasonForLosing = (props, docid) => {
    let blankName = "Причина проигрыша:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-reasonforlosing",
        [HELP_KEYS.PROJECT]: 3368,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 300,
    });

    let nameEU = blank.createField({
        title: "Наименование на английском",
        key: "nameEU",
        type: "string",
        width: 300,
    });
 
    let row1 = blank.createRow();
    let row2 = blank.createRow();
    row1.addItems([name]);
    row2.addItems([nameEU]);
    blank.addItem(row1);
    blank.addItem(row2);
    
    return blank;
};

const settings$$ = {
    targetClass: "C4C.Справочники.ПричинаПроигрыша",
    rootName: "Причина проигрыша",
    urlPath: "ReasonForLosing",
    __projectId__: 3302,
};

const CardReasonForLosing = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },
        {
            id: "nameEU",
            text: "Наименование на английском",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 250,
        },
    ];

    let cardFile = CardFile({
        ...settings$$,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankReasonForLosing);

    cardFile.urlPath = settings$$.urlPath;


    return cardFile;
};

CardReasonForLosing.settings = settings$$;

//import { Message } from "Core/index.js";
//import { createOrUpdateRecord, getRecord } from "Core/api/index.js";
// import { getUserId } from "Core/utils/index";

const BlankReasonForVictory = (props, docid) => {
    let blankName = "Причина победы:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-reasonforvictory",
        [HELP_KEYS.PROJECT]: 3368,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 300,
    });

    let nameEU = blank.createField({
        title: "Наименование на английском",
        key: "nameEU",
        type: "string",
        width: 300,
    });
 
    let row1 = blank.createRow();
    let row2 = blank.createRow();
    row1.addItems([name]);
    row2.addItems([nameEU]);
    blank.addItem(row1);
    blank.addItem(row2);
    
    return blank;
};

const settings$_ = {
    targetClass: "C4C.Справочники.ПричинаПобеды",
    rootName: "Причина победы",
    urlPath: "ReasonForVictory",
    __projectId__: 3302,
};

const CardReasonForVictory = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },
        {
            id: "nameEU",
            text: "Наименование на английском",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 250,
        },
    ];

    let cardFile = CardFile({
        ...settings$_,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankReasonForVictory);

    cardFile.urlPath = settings$_.urlPath;


    return cardFile;
};

CardReasonForVictory.settings = settings$_;

const BlankRequestComment = props => {

    const {
        rejectTitle = "",
        rejectFieldWidth = 500,
        rejectFieldHeight = 300,
        blankTitle: titleText = "Введите ......?",
        rejectValue = "",
        cancelButtonText = "Отмена",
        rejectButtonText = "Отклонить",
        hideResponsible  = true,
        hideRejectReason = true, 
        hideDatPlan      = true,
        command          = "Отклонить", 
        typeDoc          = "",
        documentId            = 0 ,
    } = props;

    let blank = Blank({
        data: props,
        // title: blankName,
        // docid,
        // class: "blank-ticket",
    });

    let blankTitle = html`<h3>${titleText}</h3>`;

    let cancelButton = html`<button
        class="button-tool cancel-tool"
        type="button"
    >${cancelButtonText}</button>`;

    let rejectButton = html`<button
        class="button-tool"
        style="background: tomato;"
        type="submit"
    >${rejectButtonText}</button>`;

    let textArea = blank.createField({
        key:"comment", 
        type:"textarea", 
        title: titleText, 
        height: 90,
        width: rejectFieldWidth, 
        required: true
    });

    let responsible = blank.createField({
        title: "Ответственный",
        key: "Ответственный",
        reference: CardFileEmployee,
        placeholder: "Укажите ответственного",
        constFilter: "docid <> "+getUserId(), 
        onChange: (params)=>{
            if (params.value?.docid==getUserId())
                responsible.setValue(undefined);
        }
    });

    let rejectReason = blank.createField({
        title: "Причина отклонения",
        key: "rejectReason",
        reference: CardReasonForDeviation,
        placeholder: "Укажите причину отклонения",
    });

    
    let ReasonForLosing = blank.createField({
        title: "Причина проигрыша",
        key: "ПричинаПроигрыша",
        reference: CardReasonForLosing,
        placeholder: "Укажите причину проигрыша",
    });

    let ReasonForVictory = blank.createField({
        title: "Причина выигрыша",
        key: "ПричинаПобеды",
        reference: CardReasonForVictory,
        placeholder: "Укажите причину выигрыша",
    });

    let planDate = blank.createField({
        title: "Дата",
        key: "planDate",
        type: "date",
        width: 140,
    });



    getNewResponsibleForAction(typeDoc , command , documentId ).then((result) => {
        responsible.setValue(result.responsible);
    });


    cancelButton.addEventListener("click", (e) => {
        blankReject.cancelButtonAction?.();
    });

    rejectButton.addEventListener("click", (e) => {
        blankReject.rejectButtonAction?.();
    });

    let extraElements = html`<div
        class="extra-elements"
        style="display: none; margin: 10px 0;"
    ></div>`;

    let fields;

    if (command == "Поставить на удержание") {
        fields = html`${blankTitle}${textArea}${planDate}`;
    }
    if (command == "Отклонить") {
        fields = html`${blankTitle}${textArea}${rejectReason}`;
    }
    if (command == "Передать в продажи") {
        fields = html`${blankTitle}${responsible}${textArea}`;
    }
    if (command == "Назначить ответственного") {
        fields = html`${blankTitle}${responsible}${textArea}`;
    }
    if (command == "Изменить ответственного") {
        fields = html`${blankTitle}${responsible}${textArea}`;
    }
    if (command == "Отменить") {
        fields = html`${blankTitle}${textArea}`;
    }
    if (command == "Отправить на утверждение") {
        fields = html`${blankTitle}${responsible}${textArea}`;
    }
    if (command == "Отправить на согласование") {
        // Это сервисаный запрос так работает. Который на снятие
        fields = html`${blankTitle}${responsible}${textArea}`;
    }
    if (command == "Вернуть на доработку") { 
        fields = html`${blankTitle}${textArea}`;
    }
    if (command == "Проиграно") { 
        fields = html`${blankTitle}${textArea}${ReasonForLosing}`;
    }
    if (command == "Выиграно") { 
        fields = html`${blankTitle}${ReasonForVictory}${textArea}`;
    }
    if (command == "Отправить на исправление") { 
        // Это отправка аналитиком на исправление фото и актов
        fields = html`${blankTitle}${textArea}`;
    }


    let blankReject = html`
        <form
            class="blank-modal reject-blank"
            onkeydown=${(ev) => ev.keyCode === 13 && ev.preventDefault()}
        >
            ${fields}
            <div class="blank-main-tools">${cancelButton}${rejectButton}</div>
        </form>
    `;

    blankReject.extraElements = extraElements;
    blankReject.showExtraElements = () => {
        blankReject.extraElements.style.display = "block";
    };

    blankReject.cancelButton = cancelButton;
    blankReject.rejectButton = rejectButton;

    blankReject.cancelButtonAction = props?.cancelButtonAction;
    blankReject.rejectButtonAction = props?.rejectButtonAction;
    
    blankReject.getData = _ => {               
        if (command == "Поставить на удержание") {

            if (textArea.getValue() == "" || textArea.getValue() == undefined  ) {
                Message$1("Опишите причину отклонения.", "info-message");
                return;
            }

            if (planDate.getValue() == undefined  ) {
                Message$1("Пожалуйста, укажите дату планового звонка.", "info-message");
                return;
            }

            return {
                comment: textArea.getValue(),   
                planDate: planDate.getValue(),
            }
        }
        if (command == "Отклонить") {
            
            if (textArea.getValue() == "" || textArea.getValue() == undefined  ) {
                Message$1("Опишите причину отклонения.", "info-message");
                return;
            }

            if (rejectReason.getValue().docid == undefined  ) {
                Message$1("Пожалуйста, укажите причину из справочника.", "info-message");
                return;
            }


            return {
                comment: textArea.getValue(),
                rejectReason: rejectReason.getValue(),
            };
        }

        if (command == "Отменить") {
            return {
                comment: textArea.getValue(),
            };
        }
        
        if (command == "Передать в продажи") {
      
            if (responsible.getValue().docid == undefined  ) {
                Message$1("Пожалуйста, укажите кому передать лид.", "info-message");
                return;
            }

            return {
                comment: textArea.getValue(),
                responsible: responsible.getValue(),
            };
        }
        if (command == "Назначить ответственного" || command == "Изменить ответственного") {
      
            if (responsible.getValue().docid == undefined  ) {
                Message$1("Пожалуйста, укажите кому передать лид.", "info-message");
                return;
            }

            return {
                comment: textArea.getValue(),
                responsible: responsible.getValue(),
            };
        }
        if (command == "Отправить на утверждение") {
      
            if (responsible.getValue().docid == undefined  ) {
                Message$1("Пожалуйста, укажите кому передать сервисный запрос на согласование.", "info-message");
                return;
            }

            return {
                comment: textArea.getValue(),
                responsible: responsible.getValue(),
            };
        }
        if (command == "Отправить на согласование") {
      
            if (responsible.getValue().docid == undefined  ) {
                Message$1("Пожалуйста, укажите кому передать сервисный запрос на согласование.", "info-message");
                return;
            }

            return {
                comment: textArea.getValue(),
                responsible: responsible.getValue(),
            };
        }
        if (command == "Вернуть на доработку") {
            // Это возврат на доработку возможности
            return {
                comment: textArea.getValue(),
            };
        }

        if (command == "Проиграно") {
      
            if (ReasonForLosing.getValue().docid == undefined  ) {
                Message$1("Пожалуйста, укажите причину проигрыша.", "info-message");
                return;
            }

            return {
                comment: textArea.getValue(),
                ReasonForLosing: ReasonForLosing.getValue(),
            };
        }

        if (command == "Выиграно") {
            if (ReasonForVictory.getValue().docid == undefined  ) {
                Message$1("Пожалуйста, укажите причину победы.", "info-message");
                return;
            }

            return {
                comment: textArea.getValue(),
                ReasonForVictory: ReasonForVictory.getValue(),
            };

        }

        if (command == "Отправить на исправление") {
            // Это возврат аналитиком на испрваление фото и актов
            return {
                comment: textArea.getValue(),
            };
        }

    };

    blankReject.addEventListener("submit", e => {
        e.preventDefault();
    });

    return blankReject;
};

const BlankActivity = (props, docid) => {
    let blankName = "Активность:";
    const modal = Modal();
    const { cardFile } = props;

    getEnabledActionsForVisit(docid).then((res) => {
        const buttons = res.data.elements.map((element) => {
            const button = html`<div class="col-auto">
                ${Button({ text: element.Name, title: element.Desc })}
            </div>`;
            button.addEventListener("click", () => {
                checkBeforeAction(docid, element.Name);
            });

            return button;
        });

        buttonsActions(buttons);
    });

    const buttonsActions = o([]);

    async function checkBeforeAction(docid, commandName) {
        if (commandName == "Отменить") {
            let blTitle;
            let btnText;

            if (commandName == "Отменить") {
                blTitle = "Укажите, пожалуйста, причину отмены";
                btnText = "Отменить";
            }
            let requestCommentBlank = BlankRequestComment({
                rejectFieldWidth: 700,
                rejectFieldHeight: 200,
                command: commandName,
                docid: docid,
                blankTitle: blTitle,
                rejectButtonText: btnText,
            });
            requestCommentBlank.rejectButtonAction = async (_) => {
                if (requestCommentBlank.getData() == undefined) {
                    return;
                }
                await createOrUpdateRecord(
                    "C4C.Документы.Активность",
                    blank.getData()
                ).then((result) => {
                    docid =  result.data?.docid;
                    executeActionForVisit(
                        docid,
                        commandName,
                        requestCommentBlank.getData()
                    ).then(async (res) => {
                        if (res.isOk) {
                            modal.hide();
                            blank.refreshData?.(docid);
                        }
                    });
                });
            };

            requestCommentBlank.cancelButtonAction = () => modal.hide();
            modal.setContent(requestCommentBlank);
            modal.show();
            return;
        } else {
            if (commandName == "Завершить") {
                if (startDateFact.getValue()==null)
                    return Message$1("Не указана факт. дата начала","error");
                if (durationFact.getValue()==null)
                    return Message$1("Не указана факт. длительность","error");  
                const tabledata = tableCheckParameters.getData();
                const parameters = tabledata.filter((m)=> {return (m.ЗначениеСтрока || m.ЗначениеЧисло || m.ЗначениеЛогический)});
                if (tabledata.length !== parameters.length) {
                    return Message$1(
                        "Не заполнены параметры",
                        "error"
                    );
                }           
            }
            await createOrUpdateRecord("C4C.Документы.Активность", blank.getData()).then(
                (result) => {
                    docid =  result.data?.docid;
                    executeActionForVisit(docid, commandName).then(
                        async (res) => {
                            if (res.isOk) {
                                modal.hide();
                                blank.refreshData?.(docid);
                            }
                        }
                    );
                }
            );
        }
    }

    const buttonsContainer = html`
        <div class="buttons-container">${buttonsActions}</div>
    `;

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-activity",
        [HELP_KEYS.PROJECT]: 3304,
    });
    let status = blank.createField({
        title: "Статус",
        key: "Status",
        width: 156,
        reference: CardStatus,
        disabled: true,
    });
    const isROByStatus = computed(() => status.getValue()?.docid === 9);//Отменено

    let id = blank.createField({
        title: "",
        key: "docid",
        type: "string",
        width: 40,
        disabled: true,
    });
    let durationFact = blank.createField({
        title: "Длительность",
        key: "ДлительностьФакт",
        type: "numeric",
        width: 157,
        disabled: isROByStatus,
    });
    let startDateFact = blank.createField({
        title: "Дата начала",
        key: "ДатаФакт",
        type: "dateTime",
        width: 156,
        disabled: isROByStatus,
    });
    let datePlan = blank.createField({
        title: "Дата план.",
        key: "ДатаПлан",
        type: "dateTime",
        width: 156,
        disabled: isROByStatus,
    });
    let durationPlan = blank.createField({
        title: "Длительность план.",
        key: "ДлительностьПлан",
        type: "numeric",
        width: 157,
        disabled: isROByStatus,
    });
    let baseDocument = blank.createField({
        title: "Основание",
        key: "ДокументОснование",
        width: 140,
        disabled: true,
    });

    let customer = blank.createField({
        title: "Клиент",
        key: "Клиент",
        width: 482,
        reference: CardAccount,
        disabled: true,
    });

    let tradePoint = blank.createField({
        title: "Точка",
        key: "Точка",
        width: 482,
        reference: CardAccount,
        isHierarchycal: false,
        initTree: false,
        constFilter: "ТипКлиента.Name = 'Торговая точка'",
        disabled: isROByStatus,
        onChange: async ({value})=>{
            customer.setValue(null);
            address.setValue("");
            if (value.docid==null)
                return;                      
            address.setValue(value.Адрес);
            getRecord$1("C4C.Справочники.Account",value.docid).then((res)=>{
                if (res.Контрагент?.docid)
                    getRecord$1("C4C.Справочники.Account",res?.Контрагент?.docid).then((res)=>{customer.setValue(res);});
            });                          
        }
    });

    let responsible = blank.createField({
        title: "Ответственный",
        key: "Ответственный",
        width: 281,
        reference: CardFileEmployee,
        disabled: isROByStatus,
    });

    let activityType = blank.createField({
        title: "Тип визита",
        key: "ТипАктивности",
        width: 195,
        reference: CardActivityType,
        onChange: async (params)=>{
            const record = await getRecord$1("C4C.Справочники.ТипАктивности",params.value.docid);
            tableCheckParameters.clearRows();
            tablePhoto.clearRows();
            record.Позиции.forEach(element => element.ЗначениеСтрока="");
            tableCheckParameters.createRows(record.Позиции);
            tablePhoto.createRows(record.ТипыФото);
        },
        disabled: isROByStatus,
    });
    let address = blank.createField({
        title: "Адрес",
        key: "Адрес",
        width: 482,
        type: "string",
        disabled: isROByStatus,
    });
    let purpose = blank.createField({
        title: "Цель",
        key: "Цель",
        width: 482,
        type: "string",
        disabled: isROByStatus,
    });
    let notes = blank.createField({
        title: "Заметки",
        key: "Заметки",
        type: "textarea",
        width: 523,
        height: 150,
        disabled: isROByStatus,
    });

    //Подтаблица Параметры
    const checkParameters = [
        {
            id: "Параметр",
            text: "Параметр",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
            reference: CardParameter,
            disabled: true,
        },
        {
            id: "ТипДанных",
            text: "Тип данных",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
            type: "string",
            // type: "select",
            // options: [{value: "Строка" , text:"Строковый" },
            //           {value: "Логический", text:"Логический" },
            //           {value: "Число"  , text:"Числовой" }],
            // dataType: "string",
            disabled: true,
            isHidden: true,
        },          
        {
            id: "ЗначениеСтрока",
            text: "ЗначениеСтрока",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
            type: "string",
            isHidden: true,
            disabled: isROByStatus,
        },  
        {
            id: "ЗначениеЛогический",
            text: "ЗначениеЛогический",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
            type: "integer",
            isHidden: true,
            disabled: isROByStatus,
        },   
        {
            id: "ЗначениеЧисло",
            text: "ЗначениеЧисло",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
            type: "numeric",
            isHidden: true,
            disabled: isROByStatus,
        },    
        {
            id: "Значение",
            text: "Значение",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,       
            disabled: isROByStatus,    
            changeValue: (...params) => {
                const [, , , { cells, columns_hash }] = params;
                const typeCell = cells[columns_hash["ТипДанных"]];
                const stringValueCell = cells[columns_hash["ЗначениеСтрока"]];
                const numericValueCell = cells[columns_hash["ЗначениеЧисло"]];
                const logicalValueCell = cells[columns_hash["ЗначениеЛогический"]];
                if (typeCell.value.getValue()=="Число")
                    return Field({
                        title: "полеЗначениеЧисло",
                        key: "ЗначениеЧисло",
                        type: "numeric",
                        style: "text-align: center; width: 100%; justify-content: center;",
                        styleCell: "text-align: center;",
                        cellField: true,
                        onChange: ({key, value}) => {
                            const dataCell = cells[columns_hash[key]];
                            dataCell.value.setValue(value);
                        },
                        value: numericValueCell.value.getValue(),
                        disabled: isROByStatus,
                    });
                else if (typeCell.value.getValue()=="Логический")
                    return Field({
                        title: "полеЗначениеЛогический",
                        key: "ЗначениеЛогический",
                        type: "select",
                        options: [{value: 2 , text:"Да"  },
                                  {value: 1 , text:"Нет" }],
                        dataType: "integer",
                        style: "text-align: center; width: 100%; justify-content: center;",
                        styleCell: "text-align: center;",
                        cellField: true,
                        onChange: ({key, value}) => {
                            const dataCell = cells[columns_hash[key]];
                            dataCell.value.setValue(value);
                        },
                        value: logicalValueCell.value.getValue(),
                        disabled: isROByStatus,
                    });
                else 
                    return Field({
                        title: "полеЗначениеСтрока",
                        key: "ЗначениеСтрока",
                        type: "string",
                        style: "text-align: center; width: 100%; justify-content: center;",
                        styleCell: "text-align: center;",
                        cellField: true,
                        onChange: ({key, value}) => {
                            const dataCell = cells[columns_hash[key]];
                            dataCell.value.setValue(value);
                        },
                        value: stringValueCell.value.getValue(),
                        disabled: isROByStatus,
                    });
            },
        },            
    ];

    const tableCheckParameters = blank.createTable({
        column_props: checkParameters,
        width: 300,
        key: "ПараметрыПроверки",
        disableContextMenu: true,
    });

    let addRowCheckParameters = html`<button
        class="add-button"
        type="button"
    ></button>`;
    addRowCheckParameters.addEventListener("click", (e) => {
        e.preventDefault();
        tableCheckParameters.createEmptyRow();
    });


    //Подтаблица Фото
    const photo = [
        {
            id: "GUID",
            text: "GUID",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 300,
            type: "string",
            disabled: true,
            isHidden: true,
        },
        {
            id: "ТипФото",
            text: "Тип фото",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 300,
            reference: CardFileType,        
            disabled: true,
        },
        {
            id: "ФотоПрикреплено",
            text: "Фото",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 45,
            changeValue: (...params) => {
                const value = params[0];

                const handleUploadFile = async ({ name, data }) => {
                    const [, , , { cells, columns_hash }] = params;
                    const typeCell = cells[columns_hash["ТипФото"]];
                    const ftype = typeCell.value.getValue().docid;
                    const photoLoaded = cells[columns_hash["ФотоПрикреплено"]];

                    const result = await uploadFileToActivity({
                        name: name,
                        data: data,
                        additional: {
                            fileType: ftype,
                            docid: docid,
                        },
                    });

                    if (result.isOk) {
                        photoLoaded.value.setValue(true);
                    }
                };

                const handleFilePreview = async () => {
                    // открыть модалку с превью
                    const [, , , { cells, columns_hash }] = params;
                    const typeCell = cells[columns_hash["ТипФото"]];
                    const ftype = typeCell.value.getValue().docid;
                    const recdocid = docid;
                    const filePreviewModal = () => {
                        const fileuploadPreview = Field({
                            type: "files-upload",
                            key: "Фото",
                            value: [],
                            onSaveFile: ({ name, data }) => {
                                return;
                            },
                            onDeleteFile: (props) => {
                                // if (isROByStatus())
                                //     return;
                                deleteFileActivity({
                                    ...props,
                                    recdocid,
                                    fileType: ftype,
                                });
                                const photoLoaded = cells[columns_hash["ФотоПрикреплено"]];
                                photoLoaded.value.setValue(false);
                                modal.hide();
                            },
                            title: "Фото",
                            acceptFiles: "image/*",
                            FileItemComponent: ImagePreviewItem,
                            multiple: false,
                            uploadButton: {
                                content: Icon({ name: "floppy-disk" }),
                                class: "transparent",
                            },
                        });

                        getFilesListActivity({
                            docid,
                            targetClass: "C4C.Документы.Активность",
                        }).then((res) => {
                            if (!res.isOk) return;
                            const photos = res.data.data?.filter(
                                (file) =>
                                    file.fileType_docid === ftype
                            );
                            if (photos?.length > 0) {
                                fileuploadPreview.setValue([photos[0]]);
                            }
                        });
                        const backButton = html`<${Button}>Назад<//>`;
                        backButton.addEventListener("click", () => {
                            modal.hide();
                        });

                        let preview = html`
                            <div class="modal-activityfile">
                                <div class="buttons-container">
                                    ${backButton}
                                </div>
                                ${fileuploadPreview}
                            </div>
                        `;
                        return preview;
                    };

                    modal.setContent(filePreviewModal);
                    modal.show();
                };

                return html`${() =>
                    FilesButton$1({
                        loaded: value,
                        onUploadFile: handleUploadFile,
                        onFilePreview: handleFilePreview,
                    })}`;

                // return button;
            },
        },
    ];

    const tablePhoto = blank.createTable({
        column_props: photo,
        width: 300,
        key: "Фото",
        disableContextMenu: true,
    });

    let addRowPhoto = html`<button
        class="add-button"
        type="button"
    ></button>`;
    addRowPhoto.addEventListener("click", (e) => {
        e.preventDefault();
        tablePhoto.createEmptyRow();
    });


    //Загрузка файлов
    const filesUploadField = new FilesUploadField({
        onSaveFile: async ({ name, data }) => {
            await createOrUpdateRecord(
                "C4C.Документы.Активность",
                blank.getData()
            ).then((res)=>{
                if (!docid) 
                    docid = res.data.docid;
                blank.refreshData(docid);
                cardFile?.updateTable();
            });
            const targetClass = "C4C.Документы.Активность";

            const additional = { targetClass, docid };
            return uploadFile({
                name,
                data,
                additional,
            });
        },
        confirmUpload: false,
        onDeleteFile: deleteFile,
        addFileBtnText: "Добавить",
        uploadFilesBtnText: "Сохранить",
        title: "Файлы",
    });

    //if (docid != null && docid > 0) {
        getFilesList({
            docid,
            targetClass: "C4C.Документы.Активность",
        }).then((res) => {
            filesUploadField.setFiles(res.data.data);
        });
    //}

    // const fileElement = html` ${docid != null
    //     ? filesUploadField.render()
    //     : undefined}`;
    const fileElement = filesUploadField.render();

    //Комментарии
    const commentsActivity = CommentsActivity({
        targetClass: "C4C.Документы.Активность",
        docid,
        comments: props?.Comments,
    });

    //Дерево
    const dependentDocs = o([]);
    const tree = Tree({
        elements: dependentDocs,
        activeItem: docid,
        onCreateChild: createChild,
        onBindToParent: bindToParent,
        onUnbindToParent: unbindToParent,
    });

    function createChild() {
        if (!docid) return;
        const initialData = {
        };
        const ChildBlank = (data) => {
            Object.assign(data, { onActivityCreated });
            const blank = BlankActivity();
            blank.cancelButtonAction = () => {
                modal.hide();
                modal.setContent(null);
            };
            blank.refreshData = async () => {};
            return blank;
        };
        const childBlank = ChildBlank(initialData);
        modal.setContent(childBlank);
        modal.show();
        function onActivityCreated() {
            modal.hide();
            modal.setContent(null);
            //blank.refreshData?.(docid);
        }
    }
    function bindToParent() {}
    function unbindToParent() {}

    //Рабочая группа
    const participants = ParticipantsList({
        users: props["РабочаяГруппа"],
        displayValue: "Участник.Name",
        docid,
        targetClass: "C4C.Документы.Активность",
    });

    //При считывании
    blank.addEventListener("connected", async () => {
        if (!docid){
            getRecord$1("BaseInt.Status", +35).then((result) => {
                status.setValue(result);
            });
            getRecord$1("BaseInt.Справочники.Persona", getUserId()).then((result) => {
                responsible.setValue(result);
            });
        }
    });

    //Кнопка сохранить
    const saveButton = html`<${Button}>Сохранить<//>`;
    saveButton.addEventListener("click", async () => {
        if (props?.saveRecord)
        {
            props.saveRecord();
            return;
        }

        const result = await createOrUpdateRecord(
            "C4C.Документы.Активность",
            blank.getData()
        );
        if (!result.isOk) {
            console.error(result.data ?? result.error);
            return;
        }
        blank.refreshData(result.data.docid);
        cardFile?.updateTable();
    });

    //Элементы
    let headerRow = blank.createRow();
    headerRow.addItems([id, status ]);
    blank.addHeaderLeftItem(headerRow);
    blank.addHeaderRightItem(saveButton);

    let mainInfoItem = html`
    ${mainInfo$5({
        datePlan,
        durationPlan,
        startDateFact,
        durationFact, 
        buttonsContainer,
        customer,
        tradePoint, 
        responsible,
        activityType,
        baseDocument,
        address,
        purpose,
        tableCheckParameters,
        tablePhoto,
        addRowPhoto,
        notes, 
        fileElement, 
        commentsActivity,  
        tree,
        participants,
    })}
    `;

    blank.addItem(mainInfoItem);

    return blank;
};

const mainInfo$5 = (fields) => {
    function renderFields() {
        return html`
            <div class="row-with-buttons">
                <div class="blank-row">${fields.datePlan}${fields.durationPlan} ${fields.startDateFact}${fields.durationFact}</div>
                ${fields.buttonsContainer}
            </div>
            <div class="blank-row">${fields.activityType}${fields.responsible} ${fields.baseDocument}</div>
            <div class="blank-row">${fields.customer}</div>
            <div class="blank-row">${fields.tradePoint}</div>
            <div class="blank-row">${fields.address}</div>
            <div class="blank-row">${fields.purpose}</div>
            <div class="blank-row">
                <div class="tables-container">
                    <div class="tableparameters-container">
                        ${fields.tableCheckParameters}
                    </div>
                    <div class="phototable-containter">
                        ${fields.tablePhoto}
                    </div>
                </div>
            </div>
            <div class="blank-row">${fields.fileElement}</div>
            <div class="blank-row">${fields.notes}${fields.participants}</div>
            <div class="blank-row">${fields.tree}${fields.commentsActivity}</div>
        `;
    }
    return html`
        ${renderFields}
    `;
};

//Прикрепление фото
const FilesButton$1 = ({ loaded, onUploadFile, onFilePreview }) => {
    if (loaded)
        return LoadedFileButton$1({ onClick: onFilePreview });
    else 
        return AddFileButton$1({ onChange: onUploadFile });
};

const LoadedFileButton$1 = (props) => {
    return html`<${Button} ...${props} class="green">
        <${Icon} name="file" />
    <//>`;
};

const AddFileButton$1 = (props) => {
    async function handleChange(ev) {
        const { target } = ev;
        const image = target.files[0];
        const fileData = await getFileData(image);
        props?.onChange?.({ name: image.name, data: fileData });
    }
    const element = html`<label class="add-file-button">
        <span class="button red"><${Icon} name="file" /></span>
        <input type="file" multiple=${false} accept="image/*" />
    </label>`;
    element.addEventListener("change", handleChange);
    return element;
};

// import { getObservable } from "Core/utils/index.js";

const FastFilter = ({ value, id: fastFilterId, checked, onSelect }) => {
    const id = `fastFilter_${fastFilterId}`;
    const element = html`<${ListItem} classNames="fast-filter">
        <input
            type="radio"
            name="fast-filter"
            value=${value}
            id=${id}
            class="fast-filter__input"
            checked=${checked}
            onchange=${() => onSelect(fastFilterId)}
        />
        <label
            htmlFor=${id}
            class="button${() => (checked() ? "" : " --outline")}"
            >${value}</label
        >
    <//>`;
    return element;
};

const template = ({ filters, onSelect, currentFilter, path }) => {
    const element = html`<${List} classNames="list fast-filters-list">
        ${map(filters, (data) => {
            return FastFilter({
                value: get(data, path),
                checked: computed(() => data._id === currentFilter()?._id),
                id: data._id,
                onSelect,
            });
        })}
    </${List}>`;
    return element;
};

class FastFilters extends Controller {
    constructor({
        // observable, can't change
        path = "name",
        onSelect,
        getFastFiltersRequest = getFastFilters,
        targetClass,
    }) {
        super({ template });
        this.filters = o([]);
        this.onSelect = onSelect;
        this.currentFilter = o();
        this.getFastFilters = getFastFiltersRequest;
        this.path = path;
        this.loaded = false;
        this.targetClass = targetClass;
        setup(this);
    }

    setFilterByValue(value) {
        const idx = this.filters().findIndex(
            (filter) => get(filter, this.path) == value,
        );
        if (!(idx >= 0)) return;
        this.setFilterByIndex(idx);
    }

    setFilterByIndex(idx) {
        if (idx === this.currentFilter()?._id) return;
        this.currentFilter(this.filters()[idx]);
        this?.onSelect(this.currentFilter());
    }

    async load({ initialFilterIndex = 0 } = {}) {
        if (this.loaded) return;
        try {
            const result = await this.getFastFilters(this.targetClass);
            if (result.isOk) {
                this.filters(
                    result.data.elements.map((v, i) => ({ ...v, _id: i })),
                );
                this.currentFilter(this.filters()[initialFilterIndex]);
            }
        } finally {
            this.loaded = true;
        }
    }

    getCurrentFastFilter() {
        return this.currentFilter()?.[this.path];
    }
}

function setup(fastFilters) {
    fastFilters.configureTemplate({
        filters: fastFilters.filters,
        onSelect: handleSelect,
        currentFilter: fastFilters.currentFilter,
        path: fastFilters.path,
    });

    function handleSelect(idx) {
        fastFilters.setFilterByIndex(idx);
    }
}

const settings$Z = {
    targetClass: "C4C.Справочники.Account",
    rootName: "Холдинг",
    urlPath: "Holding",
    __projectId__: 3408,
};

const CardHolding = (props) => {
    //let tableHelper = TableHelper();

    getUserId();

    const fastFilters = new FastFilters({
        path: "Name",
        onSelect: handleFilterSelect,
        targetClass: "Account",
    });

    const getHoldingWithFastFilter = async (props, ...args) => {
        if (!("isHierarchycal" in props)) return getHolding(props, ...args);
        await fastFilters.load({ initialFilterIndex: 0 });
        const fastFilter = fastFilters.getCurrentFastFilter();
        if (fastFilter) {
            props.fastFilter = fastFilter;
        }
        return getHolding(props, ...args);
    };

    let column_props = [
        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "ЮрНаименование",
            text: "Юр. наименование",
            order: "ЮрНаименование",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "Адрес",
            text: "Адрес",
            order: "Адрес",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "ИНН",
            text: "ИНН",
            order: "ИНН",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "КПП",
            text: "КПП",
            order: "КПП",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "Отрасль",
            text: "Отрасль",
            order: "Отрасль.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
            isHidden: true,
        },
        {
            id: "ОтраслевойСегмент",
            text: "Отраслевой сегмент",
            order: "ОтраслевойСегмент.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
            isHidden: true,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
            isHidden: true,
        },

    ];

    function handleFilterSelect() {
        cardFile.updateTable();
    }

    let cardFile = CardFile({
        ...settings$Z,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
        getCardFileRequest: getHoldingWithFastFilter,
        initTree: false,
    });

    //cardFile.setBlank(BlankAccount);
    cardFile.setBlank((blankprops,docid)=> {
        blankprops.ТипКлиента = {docid: 6, Name: "Холдинг"};
        blankprops.IsGroup = true;
        return BlankAccount(
        blankprops,
        docid
        ) 
        });

    cardFile.urlPath = settings$Z.urlPath;


    return cardFile;
};

CardHolding.settings = settings$Z;

//import { Message } from "Core/index.js";
//import { createOrUpdateRecord, getRecord } from "Core/api/index.js";
// import { getUserId } from "Core/utils/index";

const BlankAddTradePoint = (props, docid) => {
    const { cardFile } = props;
    let blank = Blank({
        data: props,
        title: "Торговая точка:",
        docid,
        class: "blank-addtradepoint",
        [HELP_KEYS.PROJECT]: 3408,
    });

    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 568,
    });
    let legalName = blank.createField({
        title: "Юр. наименование",
        key: "ЮрНаименование",
        type: "string",
        width: 468,
    });
    let legalType = blank.createField({
        title: "ФС",
        key: "ФормаСобственности",
        reference: CardLegalType,
        width: 93,
    });
    let inn = blank.createField({
        title: "ИНН",
        key: "ИНН",
        type: "string",
        width: 280,
    });
    let kpp = blank.createField({
        title: "КПП",
        key: "КПП",
        type: "string",
        width: 280,
    });
    let address = blank.createField({
        title: "Фактический адрес",
        key: "Адрес",
        type: "string",
        width: 377,
    });
    let legalAddress = blank.createField({
        title: "Юридический адрес",
        key: "ЮрАдрес",
        type: "string",
        width: 568,
    });
    let industry = blank.createField({
        title: "Отрасль",
        key: "Отрасль",
        reference: CardIndustry,
        width: 280,
    });
    let industrySegment = blank.createField({
        title: "Отраслевой сегмент",
        key: "ОтраслевойСегмент",
        reference: CardCustomerSegment,
        width: 280,
        isHierarchycal: false,
        initTree: false,
        constFilter: ()=>{
            if (industry.getValue().docid)
                return "Отрасль = {C4C.Справочники.Отрасль:"+industry.getValue().docid+"}";            
        },
        onChange: async ({key, value})=>{            
            if (!value.docid)
                return;
            if (!industry.getValue().docid)
            {
                const valuerec = await getRecord$1("C4C.Справочники.СегментКлиента",value.docid);
                if (!valuerec.Отрасль.docid)
                    return;
                const rec = await getRecord$1("C4C.Справочники.Отрасль",valuerec.Отрасль.docid);
                industry.setValue(rec);     
            }       
        }
    });
    let serviceTerritory = blank.createField({
        title: "Сервисная территория",
        key: "СервиснаяТерритория",
        reference: CardServiceTerritory,
        width: 280,
    });
    let region = blank.createField({
        title: "Регион",
        key: "Регион",
        reference: CardRegion,
        width: 185,
    });
    let xcrmid = blank.createField({
        title: "XCRM ID",
        key: "XCRMID",
        type: "string",
        width: 280,
    });
    let manager = blank.createField({
        title: "Менеджер Нестле",
        key: "Менеджер",
        reference: CardFileEmployee,
        width: 280,
    });
    let responsible = blank.createField({
        title: "Ответственный",
        key: "Ответственный",
        reference: CardFileEmployee,
        width: 280,
    });
    let branding = blank.createField({
        title: "Брендинг Nescafe OOH",
        key: "Брендинг",
        type: "checkbox",
        width: 280,
    });
    let affiliateProgram = blank.createField({
        title: "Программа coffee partners",
        key: "ПартнерскаяПрограмма",
        type: "checkbox",
        width: 280,
    });
    let holding = blank.createField({
        title: "KA-Маркер",
        key: "Холдинг",
        //type: "string",
        reference: CardHolding,
        width: 185,
    });
    let hid = blank.createField({
        title: "hid",
        key: "hid",
        type: "string",
        width: 185,
    });
    let manualInputName = blank.createField({
        title: "Ручной ввод",
        key: "РучВводНаим",
        type: "checkbox",
        width: 185,
    });
    let manualInputAddress = blank.createField({
        title: "Ручной ввод",
        key: "РучВводАдрес",
        type: "checkbox",
        width: 185,
    });
    let legalEntityInfo = blank.createField({
        title: "Есть информация о юр. лице",
        key: "ИнфоОЮрЛице",
        type: "checkbox",
        width: 215,
    });
    let legalTypeStr = blank.createField({
        title: "legalTypeStr",
        key: "ФормаСобственностиСтрокой",
        type: "string",
        width: 480,
    });

    const companySearchField = blank.createComponent({
        key: "ПолеПоиска",
        Component: ({ value }) => {
            const company = o({ value: value() });
            return html`
                <${DaDataSearchField}
                    placeholder="Начните писать для поиска. ИНН, Юр. Наименование, город..."
                    value=${company}
                    title="Юр. Наименование"
                    class="searchcompany"
                    onChange=${({ value }) => {
                        if (value) {
                            inn.setValue(value.data.inn);
                            kpp.setValue(value.data.kpp);
                            legalName.setValue(value.value);
                            legalAddress.setValue(value.data.address.value);
                            hid.setValue(value.data.hid);
                            legalTypeStr.setValue(value.data.opf.short);
                        }
                        company(value);
                    }}
                    showSearchButton=${false}
                />
            `;
        },
    });
    
    const addressSearchField = blank.createComponent({
        key: "АдресКлиента",
        Component: ({ value }) => {
            const addressO = o({ value: value() });
            return html`
                <${DaDataSearchField}
                    type="address"
                    placeholder="Адрес..."
                    value=${addressO}
                    showSearchButton=${false}
                    class="searchaddress"
                    onChange=${({ value }) => {
                        if (value) {
                            getRegion(value.data).then((result) => {
                                getRecord$1(
                                    "C4C.Справочники.Регион",
                                    +result.data.docid
                                ).then((result) => {
                                    region.setValue(result);
                                });
                            });
                            address.setValue(value.value);
                        }
                        addressO(value);
                    }}
                />
            `;
        },
    });

    //Подтаблица
    const installLocProps = [
        {
            id: "name",
            text: "Место установки",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 280,
            type: "string",
            disabled: false,
        },
    ];

    const tableInstallLoc = blank.createTable({
        column_props: installLocProps,
        width: 300,
        key: "МестаУстановки",
    });

    let addRowInstallLoc = html`<button
        class="add-button"
        type="button"
    ></button>`;
    addRowInstallLoc.addEventListener("click", (e) => {
        e.preventDefault();
        tableInstallLoc.createEmptyRow();
    });

    //Функция сохранения
    const createTradePoint = async ()=>{
        if (name.getValue()==null || name.getValue()=="")
            return Message$1("Не указано наименование","error");
        if (serviceTerritory.getValue().docid==null)
            return Message$1("Не указана сервисная территория","error");
        if (industry.getValue().docid==null)
            return Message$1("Не указана отрасль","error");
        if (industrySegment.getValue().docid==null)
            return Message$1("Не указан отраслевой сегмент","error");   
        if (address.getValue()==null || address.getValue()=="")
            return Message$1("Не указан фактический адрес","error");
        if  (legalName.getValue()==null || legalName.getValue()=="")  
            return Message$1("Не указано юр. наименование","error");                     
        const result = await createNewTradePoint({
            legalName: legalName.getValue(),
            legalAddress: legalAddress.getValue(),
            holding: holding.getValue().docid,
            industry: industry.getValue().docid,
            industrySegment: industrySegment.getValue().docid,
            inn: inn.getValue(),
            kpp: kpp.getValue(),
            hid: hid.getValue(),
            manualInput: manualInputName.getValue(),
            legalTypeStr: legalTypeStr.getValue(),
            region: region.getValue().docid,
            address: address.getValue(),
            name: name.getValue(),
            typeOwnership: legalType.getValue().docid,
            st: serviceTerritory.getValue().docid,
            xcrmid: xcrmid.getValue(),
            manager: manager.getValue().docid,
            responsible: responsible.getValue().docid,
            branding: branding.getValue(),
            affiliateProgram: affiliateProgram.getValue(),
            installloc: tableInstallLoc.getData(),
        });
        return result;
    };

    //Кнопка сохранить
    const saveButton = html`<${Button} style="width: 100px; height: 30px;"
        >Сохранить<//
    >`;
    saveButton.addEventListener("click", async () => {
        const result = await createTradePoint();
        if (result?.docid) {
            if (props?.inModal)
            {
                const resRecord = await getRecord$1("C4C.Справочники.Account",result.docid);                
                props.inModal?.(resRecord);
            }
            else
            {
            blank.refreshData(result.docid);
            cardFile?.updateTable();                 
            }
        }
    });

    //Кнопка ок
    blank.applyButtonAction =  async () => {
        const result = await createTradePoint();
        if (result?.docid) {
            if (props?.inModal)
            {
                const resRecord = await getRecord$1("C4C.Справочники.Account",result.docid);                
                props.inModal?.(resRecord);
            }
            else
            {
            blank.refreshData(result.docid);
            cardFile?.updateTable();                 
            }
        }   
    };            

    //Открытие бланка
    blank.addEventListener("connected", async () => {
        if (!docid) {
            legalEntityInfo.setValue(true);
        }
    });

    //Элементы
    let mainDataItem = mainData$1({
        name,
        legalName,
        legalType,
        inn,
        kpp,
        companySearchField,
        addressSearchField,
        address,
        legalAddress,
        industry,
        industrySegment,
        serviceTerritory,
        region,
        xcrmid,
        manager,
        responsible,
        branding,
        affiliateProgram,
        holding,
        hid,
        manualInputName,
        manualInputAddress,
        legalEntityInfo,
        legalTypeStr,
        tableInstallLoc,
        addRowInstallLoc,
        saveButton,
    });

    blank.addItem(mainDataItem);

    return blank;
};


const mainData$1 = (fields) => {
    return html`
        <div class="blank-basicdata">
            <div class="blank-row">${fields.legalEntityInfo}</div>
                ${() => {
                    if (fields.legalEntityInfo.getValue())
                        return html`
                            <div class="blank-row">
                                <h2>Информация о юр. лице</h2>
                            </div>
                            <div class="blank-row">
                                ${fields.holding}
                            </div>
                            <div class="blank-row">
                                ${() => {
                                    if (fields.manualInputName.getValue())
                                        return html`${fields.legalType}${fields.legalName}`;
                                    else
                                        return html`${fields.companySearchField}`;
                                }}
                                ${fields.manualInputName}
                            </div>
                            <div class="blank-row">
                                ${fields.legalAddress}
                            </div>
                            <div class="blank-row">
                                ${fields.inn}
                                ${fields.kpp}
                            </div>
                        `;
                    else return html``;
                }}
                <div class="blank-row">
                    <div class="account-titleleft">
                        <h2>Информация о точке</h2>
                    </div>
                </div>
                <div class="blank-row">
                    ${fields.region}
                    ${() => {
                        if (fields.manualInputAddress.getValue())
                            return html`${fields.address}`;
                        else return html`${fields.addressSearchField}`;
                    }}
                    ${fields.manualInputAddress}
                </div>
                <div class="blank-row">
                    ${fields.name}
                </div>
                <div class="blank-row">
                    ${fields.industry}                                    
                    ${fields.industrySegment}
                </div>
                <div class="blank-row">
                    ${fields.serviceTerritory}
                    ${fields.xcrmid}
                </div>
                <div class="blank-row">
                    ${fields.manager}
                    ${fields.responsible}
                </div>
                <div class="blank-row">
                    ${fields.branding}
                    ${fields.affiliateProgram}
                </div>
                <div class="blank-row">
                    ${fields.tableInstallLoc}
                    ${fields.addRowInstallLoc}
                </div>
                <div class="saveButton-container">${fields.saveButton}</div>
        </div>
    `;
};

//import { getFilesList } from "Core/api/index";
//import { Message } from "Core/index.js";
//import { createOrUpdateRecord, getRecord } from "Core/api/index.js";
// import { getUserId } from "Core/utils/index";

const BlankAccount = (props, docid) => {
    let blankName = "Аккаунт:";
    
    const modal = Modal();
    const { cardFile } = props;
    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-account",
        [HELP_KEYS.PROJECT]: 3408,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 654,
    });
    let status = blank.createField({
        title: "Статус",
        key: "Status",
        reference: CardStatus,
        width: 180,
        disabled: true,
    });

    let statusPhoto = blank.createField({
        title: "Наличие фото",
        key: "СтатусНаличияФото",
        reference: CardStatus,
        width: 220,
        disabled: true,
    });

    let accountType = blank.createField({
        title: "Тип клиента",
        key: "ТипКлиента",
        reference: CardClientType,
        width: 180,
        disabled: true,
    });
    let legalName = blank.createField({
        title: "Юр. наименование",
        key: "ЮрНаименование",
        type: "string",
        width: 274,
    });

    let legalType = blank.createField({
        title: "ФС",
        key: "ФормаСобственности",
        reference: CardLegalType,
        width: 100,
    });

    let inn = blank.createField({
        title: "ИНН",
        key: "ИНН",
        type: "string",
        width: 130,
    });
    let kpp = blank.createField({
        title: "КПП",
        key: "КПП",
        type: "string",
        width: 130,
    });
    let address = blank.createField({
        title: "Фактический адрес",
        key: "Адрес",
        type: "string",
        width: 654,
    });
    let legalAddress = blank.createField({
        title: "Юридический адрес",
        key: "Адрес",
        type: "string",
        width: 654,
    });
    let client = blank.createField({
        title: "Клиент",
        key: "Контрагент",
        reference: CardAccount,
        width: 324,
    });
    let accountTypeName = blank.createField({
        title: "",
        key: "ТипКлиента.Name",
        type: "string",
        width: 180,
        disabled: true,
    });
    let industry = blank.createField({
        title: "Отрасль",
        key: "Отрасль",
        reference: CardIndustry,
        width: 324,
    });

    let industrySegment = blank.createField({
        title: "Отраслевой сегмент",
        key: "ОтраслевойСегмент",
        reference: CardCustomerSegment,
        width: 324,
        isHierarchycal: false,
        initTree: false,
        constFilter: ()=>{
            if (industry.getValue().docid)
                return "Отрасль = {C4C.Справочники.Отрасль:"+industry.getValue().docid+"}";            
        },
        onChange: async ({key, value})=>{            
            if (!value.docid)
                return;
            if (!industry.getValue().docid)
            {
                const valuerec = await getRecord$1("C4C.Справочники.СегментКлиента",value.docid);
                if (!valuerec.Отрасль.docid)
                    return;
                const rec = await getRecord$1("C4C.Справочники.Отрасль",valuerec.Отрасль.docid);
                industry.setValue(rec);     
            }       
        }
    });
    //Площадка партнера
    let distributor = blank.createField({
        title: "Дистрибьютор",
        key: "Контрагент",
        reference: CardAccount,
        width: 324,
    });

    let serviceTerritory = blank.createField({
        title: "Сервисная территория",
        key: "СервиснаяТерритория",
        reference: CardServiceTerritory,
        width: 324,
    });

    let idSAP = blank.createField({
        title: "idSAP",
        key: "idSAP",
        type: "string",
        width: 214,
    });
    let postalCode = blank.createField({
        title: "Индекс",
        key: "ПочтИндекс",
        type: "string",
        width: 214,
    });
    let region = blank.createField({
        title: "Регион",
        key: "Регион",
        reference: CardRegion,
        width: 213,
    });
    let phone = blank.createField({
        title: "Телефон",
        key: "Телефон",
        type: "string",
        width: 195,
    });
    let fax = blank.createField({
        title: "Факс",
        key: "Факс",
        type: "string",
        width: 195,
    });
    //Торговая точка
    let xcrmid = blank.createField({
        title: "XCRM ID",
        key: "XCRMID",
        type: "string",
        width: 324,
    });

    let accountID = blank.createField({
        title: "Account ID",
        key: "AccountID",
        type: "string",
        width: 324,
        disabled: true,
    });

    let manager = blank.createField({
        title: "Менеджер Нестле",
        key: "Менеджер",
        reference: CardFileEmployee,
        width: 324,
    });
    let responsible = blank.createField({
        title: "Ответственный",
        key: "Ответственный",
        reference: CardFileEmployee,
        width: 324,
    });

    let coordinator = blank.createField({
        title: "Координатор",
        key: "Координатор",
        reference: CardFileEmployee,
        width: 435,
    });

    let branding = blank.createField({
        title: "Брендинг Nescafe OOH",
        key: "Брендинг",
        type: "checkbox",
        width: 220,
    });
    let affiliateProgram = blank.createField({
        title: "Программа coffee partners",
        key: "ПартнерскаяПрограмма",
        type: "checkbox",
        width: 220,
    });

    //Участники
    const participants = ParticipantsList({
        users: props["РабочаяГруппа"],
        displayValue: "Участник.Name",
        docid,
        targetClass: "C4C.Справочники.Account",
    });

    //Связанные документы
    const dependentDocs = o([]);
    const tree = Tree({
        elements: dependentDocs,
        activeItem: docid,
        onCreateChild: createChild,
        onBindToParent: bindToParent,
        onUnbindToParent: unbindToParent,
    });
    function createChild() {
        if (!docid) return;
        const initialData = {};
        const ChildBlank = (data) => {
            Object.assign(data, { onActivityCreated });

            const blank = BlankActivity();
            blank.cancelButtonAction = () => {
                modal.hide();
                modal.setContent(null);
            };
            blank.refreshData = async () => {};
            return blank;
        };
        const childBlank = ChildBlank(initialData);
        modal.setContent(childBlank);
        modal.show();
        function onActivityCreated() {
            modal.hide();
            modal.setContent(null);
            //blank.refreshData?.(docid);
        }
    }
    function bindToParent() {}
    function unbindToParent() {}

    //Картотека и вкладки
    let Tabs = html`<div class="blank-content"></div>`;

    let EquipmentTabContentO = o();
    let RelatedDocsTabContentO = o();

    const hideEquipmentTabContent = o(false);
    const hideRelatedDocsTabContent = o(false);
    let InstallLocTabContentO = o();
    let cardFileInstallLoc = CardInstallationLocation({
        useQueryToOpenBlank: false,
        curTradePoint: {docid: props?.docid, Name: props?.Name},
        inBlank: true,
    });
    if (docid)
        cardFileInstallLoc.setConstFilter(
            "ТорговаяТочка is {C4C.Справочники.Account:" + docid + "}"
        );
    else
        cardFileInstallLoc.setConstFilter(
            "ТорговаяТочка is {C4C.Справочники.Account:-1}"
        );
    InstallLocTabContentO(cardFileInstallLoc);

    let EquipmentTabContent = html`<div class="Equipment-tab-content"></div> `;
    EquipmentTabContentO(EquipmentTabContent);
    RelatedDocsTabContentO(tree);

    if (hideEquipmentTabContent()) hideEquipmentTabContent(false);
    if (hideRelatedDocsTabContent()) hideRelatedDocsTabContent(false);

    //Вкладки
    const mainTabType = {
        InstallLoc: { index: 0, name: "Место установки" },
        Equipment: { index: 1, name: "Оборудование" },
        RelatedDocs: { index: 2, name: "Связанные документы" },
    };

    let mainTabView = TabView();

    const InstallLocTab = mainTabView.addTab(
        mainTabType.InstallLoc.name,
        InstallLocTabContentO
    );
    const EquipmentTab = mainTabView.addTab(
        mainTabType.Equipment.name,
        EquipmentTabContentO
    );
    const RelatedDocsTab = mainTabView.addTab(
        mainTabType.RelatedDocs.name,
        RelatedDocsTabContentO
    );

    mainTabView.style.overflow = "auto";
    mainTabView.getTab(0).isActive();
    Tabs.append(mainTabView);

    subscribe$1(() => {
        if (hideEquipmentTabContent()) {
            EquipmentTab.hide();
            InstallLocTab.isActive();
        } else {
            EquipmentTab.show();
        }
        if (hideRelatedDocsTabContent()) {
            RelatedDocsTab.hide();
            InstallLocTab.isActive();
        } else {
            RelatedDocsTab.show();
        }
    });

    //Загрузка файлов
    const filesUploadField = new FilesUploadField({
        onSaveFile: ({ name, data }) => {
            return uploadFileToAccount({
                name: name,
                data: data,
                additional: { docid, fileType: 7 },
            });
        },
        onDeleteFile: deleteFileAccount,
        confirmUpload: false,
        addFileBtnText: "Добавить",
        uploadFilesBtnText: "Сохранить",
        title: "Файлы",
    });

    if (docid != null && docid > 0) {
        getFilesListAccount({
            docid,
            fileType: 7,
        }).then((res) => {
            filesUploadField.setFiles(res.data.data);
        });
    }

    const fileElement = html` ${docid != null
        ? filesUploadField.render()
        : undefined}`;

    //Загрузка файлов Фото точки
    const recdocid = docid;
    const pointPhotoField = new FilesUploadField({
        onSaveFile: async ({ name, data }) => {
            const res = await uploadFileToAccount({
                name: name,
                data: data,
                additional: { docid, fileType: 8 },
            });
            if (res.isOk) {
                const newStatus = await getRecord$1("BaseInt.Status", 23);
                if (newStatus != null) statusPhoto.setValue(newStatus);
            }
            return res;
        },
        onDeleteFile: async (params) => {
            const res = await deleteFileAccount({
                docid: params.docid,
                recdocid: recdocid,
            });
            if (res.isOk) {
                const newStatus = await getRecord$1("BaseInt.Status", 22);
                if (newStatus != null) statusPhoto.setValue(newStatus);
            }
            return res;
        },
        confirmUpload: false,
        addFileBtnText: "Добавить",
        uploadFilesBtnText: "Сохранить",
        acceptFiles: "image/*",
        title: "Фото точки",
        multiple: false,
    });

    if (docid != null && docid > 0) {
        getFilesListAccount({
            docid,
            fileType: 8,
        }).then(async (res) => {
            if (!res.isOk) return;
            pointPhotoField.setFiles(res.data.data);
            if (res.data.data.length) {
                const result = await getRecord$1("BaseInt.Status", 23);
                if (result != null) statusPhoto.setValue(result);
            } else {
                const result = await getRecord$1("BaseInt.Status", 22);
                if (result != null) statusPhoto.setValue(result);
            }
        });
    }

    const pointPhotoElement = html` ${docid != null
        ? pointPhotoField.render()
        : undefined}`;

    //Кнопка ок
    blank.applyButtonAction = () => {
        createOrUpdateRecord(
            "C4C.Справочники.Account",
            blank.getData()
        ).then(async (res) => {
        if (res.isOk) {
            blank.hide();
            cardFile?.updateTable();            
        }
        });            
    };


    //Элементы
    let rowFilesUpload = blank.createRow();
    rowFilesUpload.addItem(fileElement);
    let rowPointPhoto = blank.createRow();
    rowPointPhoto.addItems(pointPhotoElement);

    let switchingFields = switchFields({
        docid,
        name,
        legalName,
        inn,
        kpp,
        address,
        accountTypeName,
        legalType,
        client,
        distributor,
        idSAP,
        postalCode,
        region,
        phone,
        fax,
        industry,
        industrySegment,
        legalAddress,
        xcrmid,
        accountID,
        manager,
        responsible,
        coordinator,
        branding,
        affiliateProgram,
        statusPhoto,
        serviceTerritory,
        participants,
        rowFilesUpload,
        rowPointPhoto,
        Tabs,
    });

    blank.addHeaderLeftItem(
        html`<div class="blank-row">${accountType}${status}</div>`
    );

    blank.addItem(switchingFields);

    return blank;
};

const AccountTypeSelect = ({ onSelect }) => {
    const selectType = async (typeid) => {
        const resType = await getRecord$1("C4C.Справочники.ТипКлиента", typeid);
        if (resType) {
            onSelect?.({ type: resType });
        }
    };
    const clientButton = html`<${Button} style="width: 160px" onClick=${async () => selectType(1)}>
        Клиент
    <//>`;

    const tradePointButton = html`<${Button} style="width: 160px" onClick=${async () => selectType(2)}>
        Торговая точка
    <//>`;

    const distribButton = html`<${Button} style="width: 160px" onClick=${async () => selectType(3)}>
        Дистрибьютор
    <//>`;

    const partnerButton = html`<${Button} style="width: 160px" onClick=${async () => selectType(4)}>
        Площадка партнера
    <//>`;

    const stButton = html`<${Button} style="width: 160px" onClick=${async () => selectType(5)}>
        Сервисная территория
    <//>`;

    const holdingButton = html`<${Button} style="width: 160px" onClick=${async () => selectType(6)}>
        Холдинг
    <//>`;

    const userRole = getCurrentRole();
    if (userRole!=1 && userRole!=4 && userRole!=7)
        selectType(6);
    return html`
        <div class="account-typeselect">
            <h2>Выберите тип:</h2>
            <div class="blank-row">
                ${holdingButton}
                ${()=>{
                    if (userRole==1 || userRole==7)//Админ и аналитик
                        return html`${clientButton}${tradePointButton}`;
                    else if (userRole==4)//Координатор
                        return html`${tradePointButton}`;
                }}
            </div>
            ${()=>{
                if (userRole==1 || userRole==7)//Админ и аналитик
                    return html`
                        <div class="blank-row">
                            ${stButton}${distribButton}${partnerButton}
                        </div>`;
            }}
        </div>
    `;
};

const BlankAccountSwitch = (props, docid) => {
    const accountType = o(props?.ТипКлиента);
    const dynamicBlank = o();
    const selectBlank = () => {
        switch (accountType()?.docid) {
            case 1:
            case 3:
            case 4:
            case 5:
            case 6:
                return BlankAccount(props, docid);
            case 2:
                return docid ? BlankAccount(props, docid) : BlankAddTradePoint(props, docid)
            default:
                return AccountTypeSelect({ onSelect: handleAccountTypeSelect });
        }
    };

    const handleAccountTypeSelect = ({ type }) => {
        props = { ...props, ТипКлиента: type };
        accountType(type);
    };

    const handleConnected = () => {
        bypassFunctions(dynamicBlank());
    };

    const bypassFunctions = (blank) => {
        blank.refreshData = element.refreshData;
        blank.hide = element.hide;
    };

    const element = html`
        <div style="display: contents" onconnected=${handleConnected}>${dynamicBlank}</div>
    `;

    observe(element);

    on(accountType, () => {
        dynamicBlank(selectBlank());
        bypassFunctions(dynamicBlank());
    });

    return element;
};

const switchFields = (fields) => {
    function renderFields() {
        if (fields.accountTypeName.getValue() == "Торговая точка") {
            return html`
                <div class="blank-row">${fields.name}</div>
                <div class="blank-row">${fields.address}</div>
                <div class="blank-row">
                    ${fields.industry}${fields.industrySegment}
                </div>
                <div class="blank-row">
                    ${fields.client}${fields.serviceTerritory}
                </div>
                <div class="blank-row">
                    ${fields.xcrmid}${fields.accountID}
                </div>
                <div class="blank-row">
                    ${fields.manager}${fields.responsible}
                </div>
                <div class="blank-row">${fields.participants}</div>
                <div class="blank-row">
                    ${fields.branding}${fields.affiliateProgram}${fields.statusPhoto}
                </div>
                <div class="blank-row">${fields.rowPointPhoto}</div>
                <div class="blank-row">${fields.rowFilesUpload}</div>
                <div class="blank-row">${fields.Tabs}</div>
            `;
        } else if (fields.accountTypeName.getValue() == "Площадка партнера") {
            return html`
                <div class="blank-row">${fields.name}</div>
                <div class="blank-row">${fields.address}</div>
                <div class="blank-row">
                    ${fields.idSAP}${fields.region}${fields.postalCode}
                </div>
                <div class="blank-row">${fields.phone}${fields.fax}</div>
                <div class="blank-row">
                    ${fields.distributor} ${fields.serviceTerritory}
                </div>
                <div class="blank-row">${fields.rowFilesUpload}</div>
                <div class="blank-row">${fields.Tabs}</div>
            `;
        } else if (fields.accountTypeName.getValue() == "Сервисная территория") {
            return html`
                <div class="blank-row">${fields.name}</div>
                <div class="blank-row">
                    ${fields.coordinator}${fields.region}
                </div>
                <div class="blank-row">${fields.rowFilesUpload}</div>
                <div class="blank-row">${fields.Tabs}</div>
            `;
        } else {
            return html`
                <div class="blank-row">${fields.name}</div>
                <div class="blank-row">
                    ${fields.industry} ${fields.industrySegment}
                </div>
                <div class="blank-row">
                    ${fields.legalType}
                    ${fields.legalName}${fields.inn}${fields.kpp}
                </div>
                <div class="blank-row">${fields.legalAddress}</div>
                <div class="blank-row">${fields.rowFilesUpload}</div>
                <div class="blank-row">${fields.Tabs}</div>
            `;
        }
    }
    return html` <div class="blank-data">${renderFields}</div> `;
};

const settings$Y = {
    targetClass: "C4C.Справочники.Account",
    rootName: "Сервисная территория",
    urlPath: "ServiceTerritory",
    __projectId__: 3408,
};

const CardServiceTerritory = (props) => {
    //let tableHelper = TableHelper();

    getUserId();

    const fastFilters = new FastFilters({
        path: "Name",
        onSelect: handleFilterSelect,
        targetClass: "Account",
    });

    const getSTWithFastFilter = async (props, ...args) => {
        if (!("isHierarchycal" in props)) return getServiceTerritory(props, ...args);
        await fastFilters.load({ initialFilterIndex: 0 });
        const fastFilter = fastFilters.getCurrentFastFilter();
        if (fastFilter) {
            props.fastFilter = fastFilter;
        }
        return getServiceTerritory(props, ...args);
    };

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },

        {
            id: "Контрагент",
            text: "Дистрибьютор",
            order: "Контрагент.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },

        {
            id: "Координатор",
            text: "Координатор",
            order: "Координатор.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },
        {
            id: "Регион",
            text: "Регион",
            order: "Регион.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },

        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
            isHidden: true,
        },

    ];

    function handleFilterSelect() {
        cardFile.updateTable();
    }

    let cardFile = CardFile({
        ...settings$Y,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
        getCardFileRequest: getSTWithFastFilter,
        initTree: false,
    });

    cardFile.setBlank((blankprops,docid)=> {
        blankprops.ТипКлиента = {docid: 5, Name: "Сервисная территория"};
        return BlankAccount(
        blankprops,
        docid
        ) 
        });

    cardFile.urlPath = settings$Y.urlPath;


    return cardFile;
};

CardServiceTerritory.settings = settings$Y;

const genders = [
    { value: 1, text: "Мужской" },
    { value: 2, text: "Женский" },
];

const BlankEmployee = (props, docid) => {
    let blankName = props.isEmployee ? "Сотрудник" : "Контактное лицо";
    const { cardFile } = props;
    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-employee",
        [HELP_KEYS.PROJECT]: 3433,
    });
    let surnameInitial = blank.createField({
        title: "Фамилия инициалы",
        key: "Name",
        type: "string",
        width: 180,
    });
    let name = blank.createField({
        title: "Имя",
        key: "Имя",
        type: "string",
        width: 180,
        onChange: ChangeFullName,
    });
    let surname = blank.createField({
        title: "Фамилия",
        key: "Фамилия",
        type: "string",
        width: 180,
        onChange: ChangeFullName,
    });
    let patronymic = blank.createField({
        title: "Отчество",
        key: "Отчество",
        type: "string",
        width: 180,
        onChange: ChangeFullName,
    });
    let gender = blank.createField({
        title: "Пол",
        key: "Пол",
        type: "select",
        options: genders,
        dataType: "number",
        width: 180,
    });
    let email = blank.createField({
        title: "Email",
        key: "Email",
        type: "string",
        width: 180,
    });
    let phone = blank.createField({
        title: "Телефон",
        key: "Телефон",
        type: "string",
        placeholder: "+7 () - -",
        width: 180,
    });
    let login = blank.createField({
        title: "Логин",
        key: "Login",
        type: "string",
        width: 180,
    });
    let password = blank.createField({
        title: "Пароль",
        key: "Password",
        type: "string",
        width: 180,
    });
    let status = blank.createField({
        title: "Статус",
        key: "Status",
        reference: CardStatus,
        width: 173,
    });
    let c4cUserId = blank.createField({
        title: "C4C user id",
        key: "C4CUserId",
        type: "string",
        width: 180,
    });
    blank.createField({
        title: "Сотрудник",
        key: "isEmployee",
        type: "checkbox",
        width: 180,
    });
    let externalEmployee = blank.createField({
        title: "Внешний сотрудник",
        key: "Внешний",
        type: "checkbox",
        width: 180,
    });

    if (docid == undefined) {
        getRecord$1("BaseInt.Status", +1).then((result) => {
            status.setValue(result);
        });
    }

    function ChangeFullName() {
        surnameInitial.setValue(
            (surname.getValue() != undefined && surname.getValue() != ""
                ? surname.getValue()
                : "") +
                (name.getValue() != undefined && name.getValue() != ""
                    ? " " + name.getValue()[0] + "."
                    : "") +
                (patronymic.getValue() != undefined &&
                patronymic.getValue() != ""
                    ? " " + patronymic.getValue()[0] + "."
                    : "")
        );
    }

    let buttonO = o();
    if (status.getValue().docid == 38) {
        let button = html`<button class="button-tool" style="width:150px">
            Деактивировать
        </button>`;
        button.addEventListener("click", () => {
            deactivationUser(docid).then((result) => {
                button.remove();
                Message$1(result.data.message, "succes");
                getRecord$1("BaseInt.Status", +59).then((result) => {
                    status.setValue(result);
                });
            });
        });
        buttonO(button);
    } else {
        if (
            (status.getValue().docid == 60 || status.getValue().docid == 81) &&
            docid != undefined
        ) {
            let button = html`<button class="button-tool" style="width:150px">
                Пригласить
            </button>`;
            button.addEventListener("click", () => {
                if (
                    positionsTable.getRows()[0] == undefined ||
                    email.getValue() == ""
                ) {
                    Message$1("Необходимо указать email и роль", "error");
                    return;
                }
                registerInvite(
                    email.getValue(),
                    blank.getData().Roles[0].role.docid,
                    true,
                    docid
                ).then((res) => {
                    if (res.data.message == "Заявка отправлена") {
                        Message$1("Приглашение отправлено", "succes");
                    }
                    getRecord$1("BaseInt.Status", +60).then((result) => {
                        status.setValue(result);
                    });
                });
            });
            buttonO(button);
        } else {
            if (docid == undefined) {
                let button = html`<button
                    class="button-tool"
                    style="width:150px"
                >
                    Пригласить
                </button>`;
                button.addEventListener("click", () => {
                    if (
                        positionsTable.getRows()[0] == undefined ||
                        email.getValue() == ""
                    ) {
                        Message$1("Необходимо указать email и роль", "error");
                        return;
                    }
                    createOrUpdateRecord(
                        "BaseInt.Справочники.Persona",
                        blank.getData()
                    ).then((result) => {
                        blank.setDocid(result.data.RecordID);
                        console.log(blank.getData());
                        registerInvite(
                            email.getValue(),
                            blank.getData().Roles[0].role.docid,
                            true,
                            result.data.RecordID
                        ).then((res) => {
                            if (res.data.message == "Заявка отправлена") {
                                Message$1("Приглашение отправлено", "succes");
                            }
                            getRecord$1("BaseInt.Status", +60).then((result) => {
                                status.setValue(result);
                            });
                        });
                    });
                });
                buttonO(button);
            }
        }
    }

    blank.createRow();
    let centerRow = blank.createRow();
    let lowRow = blank.createRow();

    centerRow.addItems([surname, name, patronymic, gender]);
    lowRow.addItems([email, phone, login, password]);

    //Подтаблица
    const positionsProps = [
        {
            id: "role",
            text: "Роли",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 36,
            reference: CardRoles,
        },
    ];

    const positionsTable = blank.createTable({
        column_props: positionsProps,
        width: 80,
        key: "Roles",
    });

    let new_row_sub_table = [
        {
            role: "",
        },
    ];

    let addRowPositions = html`<button class="add-button"></button>`;
    addRowPositions.addEventListener("click", (e) => {
        e.preventDefault();
        positionsTable.createRows(new_row_sub_table);
    });

    //Подтаблица
    const stProps = [
        {
            id: "СервиснаяТерритория",
            text: "Сервисная территория",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 36,
            reference: CardServiceTerritory,
        },
    ];

    const stTable = blank.createTable({
        column_props: stProps,
        width: 80,
        key: "СервисныеТерритории",
    });

    let new_row_st_table = [
        {
            СервиснаяТерритория: "",
        },
    ];

    let addRowST = html`<button class="add-button"></button>`;
    addRowST.addEventListener("click", (e) => {
        e.preventDefault();
        stTable.createRows(new_row_st_table);
    });

    //Подтаблица
    const regionsProps = [
        {
                id: "Регион",
                text: "Регион",
                style: "text-align: center; width: 100%; justify-content: center;",
                styleCell: "text-align: center;",
                width: 36,
                reference: CardRegion,
            },
        ];
    
        const regionsTable = blank.createTable({
            column_props: regionsProps,
            width: 30,
            key: "Регионы",
        });
    
        let new_row_regions_table = [
            {
                Регион: "",
            },
        ];
    
    let addRowRegions = html`<button class="add-button"></button>`;
    addRowRegions.addEventListener("click", (e) => {
        e.preventDefault();
        regionsTable.createRows(new_row_regions_table);
    });
    
    //
    html`
        <div style="display: flex; margin-bottom: 10px;margin-top: 10px">
            ${positionsTable} ${addRowPositions} ${stTable} ${addRowST}
            <div style="margin-left: 8px">${status}</div>
            <div style="margin-left: 5px">${buttonO}</div>
        </div>
    `;

    let mainInfoItem = html`
        ${mainInfo$4({
            surnameInitial,
            name,
            surname,
            patronymic,
            gender,
            email,
            phone,
            login,
            password,
            c4cUserId,
            externalEmployee,
            positionsTable,
            addRowPositions,
            stTable,
            addRowST,
            regionsTable,
            addRowRegions,
        })}
    `;

    blank.addItem(mainInfoItem);
    blank.addHeaderRightItem(status);

    blank.applyButtonAction = () => {
        if (login.getValue()=="" || login.getValue()==undefined)
            return Message$1("Отсутствует логин","error");
        if (email.getValue()=="" || email.getValue()==undefined)
            return Message$1("Отсутствует email","error");
        createOrUpdateRecord(
            "BaseInt.Справочники.Persona",
            blank.getData()
        ).then(async (res) => {
        if (res.isOk) {
            blank.hide();
            cardFile?.updateTable();            
        }
        });            
    };

    return blank;
};

const mainInfo$4 = (fields) => {
    function renderFields() {
        return html` ${fields.stTable}${fields.addRowST} `;
    }
    return html`
        <div class="blank-basicInfo">
            <div class="blank-row">
                ${fields.surname}${fields.name}${fields.patronymic}${fields.gender}${fields.c4cUserId}
            </div>
            <div class="blank-row">
                ${fields.email}${fields.phone}${fields.login}${fields.password}${fields.externalEmployee}
            </div>
            <div class="tables-container">
                <div class="positions-container">
                    ${fields.positionsTable}${fields.addRowPositions}
                </div>
                <div class="st-containter">${renderFields}</div>
                <div class="regions-container">
                    ${fields.regionsTable}${fields.addRowRegions}
                </div>
            </div>
        </div>
    `;
};

const CardFileEmployee = (props) => {
    let tableHelper = TableHelper();
    const searchValue = o("");

    let column_props = [
        {
            id: "IsGroup",
            text: "",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell:
                "display: flex; height: 100%; justify-content: center; align-items: center;",
            order: "IsGroup",
            fixWidth: 25,
            callback: tableHelper.fileOrFolder,
        }, //TODO
        {
            id: "Name",
            text: "Пользователь",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            // order: "name",
            width: 15,
        },
        {
            id: "Телефон",
            text: "Телефон",
            order: "Телефон",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 8,
        },
        {
            id: "Email",
            text: "Email",
            order: "Email",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 11,
        },
        {
            id: "Status",
            text: "Статус",
            order: "Status",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 9,
        },
        {
            id: "C4CUserId",
            text: "C4C user id",
            order: "C4CUserId",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 10,
        },
        {
            id: "Имя",
            text: "Имя",
            order: "Имя",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 15,
        },
        {
            id: "Фамилия",
            text: "Фамилия / территория",
            order: "Фамилия",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 8,
            isHidden: true,
        },
        {
            id: "Отчество",
            text: "Отчество",
            order: "Отчество",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 8,
            isHidden: true,
        },
        {
            id: "Login",
            text: "Логин",
            order: "Login",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 8,
        },
        {
            id: "Password",
            text: "Пароль",
            order: "Password",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 8,
        },
        {
            id: "Пол",
            text: "Пол",
            order: "Пол",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 5,
            callback: tableHelper.sexGender,
        },
    ];

    const handleSearchChange = () => {
        const filter = ("( Match(Фамилия,'*"+searchValue()+"*') or " +
                        "Match(Имя,'*"+searchValue()+"*') or "+
                        "Match(Отчество,'*"+searchValue()+"*') or " +
                        "Match(Email,'*"+searchValue()+"*') or " +
                        "Match(Name,'*"+searchValue()+"*') )" +
                        " and (isEmployee = true)"
                        );
        if (searchValue()!="")
            cardFile.setIsHierarchycal(false);
        else
            cardFile.setIsHierarchycal(true);
        cardFile.setConstFilter(filter);
        cardFile.updateTable();
    };
    const handleSearchInput = (value) => searchValue(value);
    const handleSearchClear = () => {
        handleSearchInput("");
        handleSearchChange();
    };

    let cardFile = CardFile({
        ...props,
        ...settings$X,
        cardWidth: 85,
        column_props: column_props,
        customTools: html`
            <div class="search-tools">
                <${SearchField}
                    value=${searchValue}
                    onInput=${handleSearchInput}
                    onChange=${handleSearchChange}
                    onClear=${handleSearchClear}
                    placeholder=${"Фамилия, имя, отчетство, EMail"}
                    showSearchButton=${false}
                />
            </div>
        `,
        class: "employee-card-file",
        ...props,
    });

    cardFile.setBlank((props, docid) =>
        BlankEmployee(
            { ...(props ?? {}), isEmployee: props?.isEmployee ?? true },
            docid
        )
    ); // set your blank on cardFile

    cardFile.setConstFilter("isEmployee");

    cardFile.urlPath = settings$X.urlPath;

    return cardFile;
};

const settings$X = {
    targetClass: "BaseInt.Справочники.Persona",
    rootName: "Сотрудники",
    urlPath: "members",
};

CardFileEmployee.settings = settings$X;

const BlankCommonFile = (props, docid) => {
    let blankName = docid ? "Общий файл: " + props.docid : "Новый общий файл:";

    let blank = Blank({ data: props, title: blankName, docid});

    let name = blank.createField({ title: "Имя", key: "Name", type: "string", width: 200});
    let timeStamp = blank.createField({ title: "TimeStamp", key: "TimeStamp", type: "string", width: 200});
    let size = blank.createField({ title: "Size", key: "Size", type: "string", width: 200});
    let contents = blank.createField({ title: "Contents", key: "Contents", type: "string", width: 200});

    let headerRow = blank.createRow();
    let bottomRow = blank.createRow();

    headerRow.addItems([name, timeStamp]);
    bottomRow.addItems([size, contents]);

    blank.addItem(headerRow);
    blank.addItem(bottomRow);

    return blank;

};

const CardCommonFile = props => {
    let tableHelper = TableHelper();

    let column_props = [
        {
            id: "IsGroup",
            text: "",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell:
                "display: flex; height: 100%; justify-content: center; align-items: center;",
            order: "IsGroup",
            fixWidth: 25,
            callback: tableHelper.fileOrFolder,
        }, //TODO
        {
            id: "Name",
            text: "Имя",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 15,
        },
        {
            id: "TimeStamp",
            text: "TimeStamp",
            order: "TimeStamp",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 15
        }, 
        {
            id: "Size",
            text: "Size",
            order: "Size",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 15
        }, 
        {
            id: "Contents",
            text: "Contents",
            order: "Contents",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 15
        }, 
    ];

    let cardFile = CardFile({ targetClass: "Kernel.Settings.CommonFile", rootName: "Общие файлы", cardWidth: 85, column_props: column_props, inModal: props?.inModal, callBackElement: props?.callBackElement });

    cardFile.setBlank(BlankCommonFile); // set your blank on cardFile

    cardFile.urlPath = "commonFIile";

    return cardFile;
};

const BlankAttachmentType = (props, docid) => {
    let blankName = docid ? "Тип прикладываемого файла: " + props.docid : "Новый тип прикладываемого файла";


    let blank = Blank({ data: props, title: blankName, docid});
    
    let name = blank.createField({ title: "Имя", key: "Имя", type: "string", width: 200});
    let code = blank.createField({ title: "Код", key: "Код", type: "string", width: 200});

    let headerRow = blank.createRow();

    headerRow.addItems([code, name]);

    blank.addItem(headerRow);

    return blank;
};

const CardFileAttachmentType = props => {
    let tableHelper = TableHelper();

    let column_props = [
        {
            id: "IsGroup",
            text: "",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell:
                "display: flex; height: 100%; justify-content: center; align-items: center;",
            order: "IsGroup",
            fixWidth: 25,
            callback: tableHelper.fileOrFolder,
        }, 
        {
            id: "Имя",
            text: "Имя",
            order: "Имя",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 15,
        },
        {
            id: "Код",
            text: "Код",
            order: "Код",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 15
        },
    ];
    let cardFile = CardFile({ targetClass: "СИС2.Архив.ТипПрикладываемогоФайла", rootName: "Тип прикладываемого файла", cardWidth: 85, column_props: column_props, inModal: props?.inModal, callBackElement: props?.callBackElement });

    cardFile.setBlank(BlankAttachmentType); // set your blank on cardFile

    cardFile.setConstFilter("");

    cardFile.urlPath = "attachmentType";

    return cardFile;
};

const BlankFileArchive = (props, docid) => {
    let blankName = docid ? "Файл: " + props.Код : "Новый файл";


    let blank = Blank({ data: props, title: blankName, docid});
    
    let code = blank.createField({ title: "Код", key: "Код", type: "string", width: 200});
    let description = blank.createField({ title: "Описание", key: "Описание", type: "string", width: 200});
    let name = blank.createField({ title: "Имя файлы", key: "ИмяФайла", type: "string", width: 200});
    let date = blank.createField({ title: "Время", key: "ВремяФайла", type: "dateTimeFull", width: 200});
    let fileType = blank.createField({ title: "Тип прилож. файла", key: "ТипПрикладываемогоФайла", reference: CardFileAttachmentType, width: 200});

    let DownloadButton = html`<button class="button-tool" style="background: green; width: 140px;margin-left:30px;" title="Загрузить выбранный файл">Скачать</button>`;   
    DownloadButton.addEventListener("click", _ => { 
        getFile(props.docid).then(res => { 

            let a = res.Filename;
            var id = a.lastIndexOf(".");
            if (id === -1) return;
            let mime = a.substring(id + 1);
            let type = "";
            switch(mime) {
                case "text":
                    type = "application/plain"; 
                    break;
                case "txt":
                    type = "text/plain";
                    break;
                case "png":
                    type = "image/png";
                    break;
                case "jpeg":
                    type = "image/jpeg";
                    break;
                case "svg":
                    type = "image/svg+xml";
                    break;
                case "xls":
                    type = "application/x-excel";
                    break;
                case "xlsx":
                    type = "application/x-excel";
                    break;
                case "zip":
                    type = "application/zip";
            }

            let d = res.Data;
            let l = d.length;
            let array = new Uint8Array(l);
            for (let i = 0; i < l; i++) array[i] = d.charCodeAt(i);

            let fileBlob = new Blob([array], {type: type});
            let link = document.createElement("a");
            link.href = window.URL.createObjectURL(fileBlob);
            link.download = res.Filename;
            link.click();
        });  

    });
    
    let headerRow = blank.createRow();
    let centerRow = blank.createRow();
    let bottomRow = blank.createRow();

    headerRow.addItems([code, description]);
    centerRow.addItems([name, date]);
    bottomRow.addItems([fileType, DownloadButton]);

    blank.addItem(headerRow);
    blank.addItem(centerRow);
    blank.addItem(bottomRow);

    return blank;
};

const CardFileArchive = props => {
    let tableHelper = TableHelper();

    let column_props = [
        {
            id: "IsGroup",
            text: "",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell:
                "display: flex; height: 100%; justify-content: center; align-items: center;",
            order: "IsGroup",
            fixWidth: 25,
            callback: tableHelper.fileOrFolder,
        }, //TODO
        {
            id: "Описание",
            text: "Описание",
            order: "Описание",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 25,
        },
        {
            id: "ИмяФайла",
            text: "Имя файла",
            order: "ИмяФайла",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 20
        },
        {
            id: "ВремяФайла",
            text: "Время",
            order: "ВремяФайла",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 10,
        },
        {
            id: "ТипПрикладываемогоФайла",
            text: "Тип Прилож. Файла",
            order: "ТипПрикладываемогоФайла",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 12,
        },
    ];
    let cardFile = CardFile({ targetClass: "СИС2.Архив.Файл", rootName: "файлы", cardWidth: 85, column_props: column_props, inModal: props?.inModal, callBackElement: props?.callBackElement });

    cardFile.setBlank(BlankFileArchive); // set your blank on cardFile

    cardFile.setConstFilter("");
    cardFile.setConstOrder("ВремяФайла-");

    cardFile.urlPath = "files";

    return cardFile;
};

const BlankDataStructure = (props, docid) => {
    let blankName = docid ? "Структура записи " + '"' + props.Name + '"' : "Новая структура записи";
    let blank = Blank({ data: props, title: blankName, docid });

    let Наименование = blank.createField({ title: "Наименование", key: "Name",              type: "string", width: 300 });
    let Описание     = blank.createField({ title: "Описание",     key: "Описание",          type: "string", width: 300 });
    let ПолноеИмя    = blank.createField({ title: "Полное имя",   key: "ClassTypeFullName", type: "string", width: 300 });

    let row1 = blank.createRow();
    let row2 = blank.createRow();
    let row3 = blank.createRow();

    row1.addItems([Наименование]);
    row2.addItems([Описание]);
    row3.addItems([ПолноеИмя]);

    blank.addItems([ row1 , row2 , row3 ]);

    return blank;
};

const settings$W = {
    targetClass: "BaseInt.Служебные.InfoBaseStructure",
    rootName: "Стурктура данных",
    urlPath: "DataStructure",
};

const CardDataStructure = props => {
    let tableHelper = TableHelper();
    let column_props = [
        {
            id: "IsGroup",
            text: "",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "display: flex; height: 100%; justify-content: center; align-items: center;",
            order: "IsGroup",
            fixWidth: 25,
            callback: tableHelper.fileOrFolder 
        },
        {
            id: "docid",
            text: "DocId",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            order: "docid",
            width: 4,
            isHidden: true,
        },
        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 12
        },
        {
            id: "Описание",
            text: "Описание",
            order: "Описание",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 20
        },
        {
            id: "ClassTypeFullName",
            text: "Полное имя",
            order: "ClassTypeFullName",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 20
        },
        {
            id: "CreateUser",
            text: "Создал",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            order: "CreateUser",
            width: 7,
            isHidden: true,

        },
        {
            id: "CreateDate",
            text: "Дата Создания",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            order: "CreateDate",
            width: 8,
            isHidden: true,
        },
        {
            id: "UpdateUser",
            text: "Изменил",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            order: "UpdateUser",
            width: 7,
            isHidden: true,
        },
        {
            id: "UpdateDate",
            text: "Дата изменения",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            order: "UpdateDate",
            width: 8,
            isHidden: true,
        },

   ];

    let cardFile = CardFile({ 
        targetClass: settings$W.targetClass, 
        rootName: settings$W.rootName,
        cardWidth: 85, column_props: column_props, 
        inModal: props?.inModal, 
        callBackElement: props?.callBackElement 
    });

    cardFile.setBlank(BlankDataStructure); // set your blank on cardFile
    cardFile.setConstFilter("");
    cardFile.urlPath = settings$W.urlPath;

    return cardFile;
};

//import { Message } from "Core/index.js";
//import { createOrUpdateRecord, getRecord } from "Core/api/index.js";
// import { getUserId } from "Core/utils/index";

const BlankSource = (props, docid) => {
    let blankName = docid ? "Источник:" : "Новый источник:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-source",
        [HELP_KEYS.PROJECT]: 3334,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 170,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);
    blank.addItem(row1);
    
    return blank;
};

const settings$V = {
    targetClass: "C4C.Справочники.Источник",
    rootName: "Источник",
    urlPath: "Source",
    __projectId__: 3334,
};

const CardSource = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [
        // {
        //     id: "DocId",
        //     text: "DocId",
        //     order: "DocId",
        //     style: "text-align: center; width: 100%; justify-content: center;",
        //     styleCell: "text-align: right;",
        //     fixWidth: 20,
        //     isHidden: true,
        // },

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$V,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankSource);

    cardFile.urlPath = settings$V.urlPath;


    return cardFile;
};

CardSource.settings = settings$V;

//import { Message } from "Core/index.js";
//import { createOrUpdateRecord, getRecord } from "Core/api/index.js";
// import { getUserId } from "Core/utils/index";

const BlankCategory = (props, docid) => {
    let blankName = docid ? "Категория продукта:" : "Новая категория продукта:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-category",
        [HELP_KEYS.PROJECT]: 3302,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 170,
    });
 
    //let headerRow = blank.createRow();
    let row1 = blank.createRow();
    //let lowRow = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);
    //blank.addItem(lowRow);
    //blank.addItem(tableWidthAddButton);
    // blank.addItems(html`<h3 style="color: grey">Example</h3>`);
    // blank.addItem(exampleRow);

    // blank.addItem(subTable);

    return blank;
};

const settings$U = {
    targetClass: "C4C.Справочники.КатегорияПродукта",
    rootName: "Категория продукта",
    urlPath: "Category",
    __projectId__: 3302,
};

const CardCategory = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [
        
        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 120,
            isHidden: true,
        },
    ];

    let cardFile = CardFile({
        ...settings$U,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        initTree: true,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankCategory);

    cardFile.urlPath = settings$U.urlPath;


    return cardFile;
};

CardCategory.settings = settings$U;

const BlankPriority = (props, docid) => {
    let blankName = docid ? "Приоритет:" : "Новый приоритет:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-priority",
        [HELP_KEYS.PROJECT]: 3377,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 200,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$T = {
    targetClass: "C4C.Справочники.Приоритет",
    rootName: "Приоритет",
    urlPath: "Priority",
    __projectId__: 3377,
};

const CardPriority = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$T,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankPriority);

    cardFile.urlPath = settings$T.urlPath;


    return cardFile;
};

CardPriority.settings = settings$T;

const BlankContactType = (props, docid) => {
    let blankName = docid ? "Тип контакта:" : "Новый тип контакта:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-contacttype",
        [HELP_KEYS.PROJECT]: 3374,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 200,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

//import { BlankCustomerCategory } from "../../../../Blanks/References/BlankCustomerCategory";



const settings$S = {
    targetClass: "C4C.Справочники.ТипКонтакта",
    rootName: "Тип контакта",
    urlPath: "ContactType",
    __projectId__: 3374,
};

const CardContactType = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 240,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$S,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankContactType);   

    cardFile.urlPath = settings$S.urlPath;


    return cardFile;
};

CardContactType.settings = settings$S;

const BlankContactFunction = (props, docid) => {
    let blankName = docid ? "Функция контакта:" : "Новая функция контакта:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-contactfunction",
        [HELP_KEYS.PROJECT]: 3302,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 170,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$R = {
    targetClass: "C4C.Справочники.ФункцияКонтактногоЛица",
    rootName: "Функция контакта",
    urlPath: "ContactFunction",
    __projectId__: 3302,
};

const CardContactFunction = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$R,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankContactFunction);

    cardFile.urlPath = settings$R.urlPath;


    return cardFile;
};

CardContactFunction.settings = settings$R;

const BlankDepartament = (props, docid) => {
    let blankName = docid ? "Отношения отдела:" : "Отношения отдела:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-departament",
        [HELP_KEYS.PROJECT]: 3371,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 200,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$Q = {
    targetClass: "C4C.Справочники.ОтношенияОтдела",
    rootName: "Отношения отдела",
    urlPath: "Departament",
    __projectId__: 3371,
};

const CardDepartament = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 210,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$Q,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankDepartament);   

    cardFile.urlPath = settings$Q.urlPath;


    return cardFile;
};

CardDepartament.settings = settings$Q;

const BlankContactRole = (props, docid) => {
    let blankName = docid ? "Роль контакта:" : "Новая роль контакта:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-contactrole",
        [HELP_KEYS.PROJECT]: 3302,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 170,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$P = {
    targetClass: "C4C.Справочники.РольКонтактногоЛица",
    rootName: "Роль контакта",
    urlPath: "ContactRole",
    __projectId__: 3302,
};

const CardContactRole = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 210,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$P,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankContactRole);

    cardFile.urlPath = settings$P.urlPath;


    return cardFile;
};

CardContactRole.settings = settings$P;

const BlankContactTitle = (props, docid) => {
    let blankName = docid ? "Обращение:" : "Новое обращение:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-contacttitle",
        [HELP_KEYS.PROJECT]: 3375,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 200,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$O = {
    targetClass: "C4C.Справочники.Обращение",
    rootName: "Обращение",
    urlPath: "ContactTitle",
    __projectId__: 3375,
};

const CardContactTitle= (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$O,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankContactTitle);

    cardFile.urlPath = settings$O.urlPath;


    return cardFile;
};

CardContactTitle.settings = settings$O;

const BlankCommunicationMethod = (props, docid) => {
    let blankName = docid ? "Способ связи:" : "Новый способ связи:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-communicationmethod",
        [HELP_KEYS.PROJECT]: 3302,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 170,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$N = {
    targetClass: "C4C.Справочники.СпособСвязи",
    rootName: "Способ cвязи",
    urlPath: "CommunicationMethod",
    __projectId__: 3302,
};

const CardCommunicationMethod = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$N,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankCommunicationMethod);

    cardFile.urlPath = settings$N.urlPath;


    return cardFile;
};

CardCommunicationMethod.settings = settings$N;

const BlankLanguage = (props, docid) => {
    let blankName = docid ? "Язык:" : "Новый язык:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-language",
        [HELP_KEYS.PROJECT]: 3370,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 200,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

//import { BlankCustomerCategory } from "../../../../Blanks/References/BlankCustomerCategory";



const settings$M = {
    targetClass: "C4C.Справочники.Язык",
    rootName: "Язык",
    urlPath: "Language",
    __projectId__: 3370,
};

const CardLanguage = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$M,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankLanguage);   

    cardFile.urlPath = settings$M.urlPath;


    return cardFile;
};

CardLanguage.settings = settings$M;

//import { Message } from "Core/index.js";
//import { createOrUpdateRecord, getRecord } from "Core/api/index.js";
// import { getUserId } from "Core/utils/index";

const BlankAccountType = (props, docid) => {
    let blankName = docid ? "Account Type" : "Account Type:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-accounttype",
        [HELP_KEYS.PROJECT]: 3363,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 180,
    });
 
    //let headerRow = blank.createRow();
    let row1 = blank.createRow();
    //let lowRow = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$L = {
    targetClass: "C4C.Справочники.AccountType",
    rootName: "Account Type",
    urlPath: "AccountType",
    __projectId__: 3363,
};

const CardAccountType = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$L,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankAccountType);

    cardFile.urlPath = settings$L.urlPath;


    return cardFile;
};

CardAccountType.settings = settings$L;

const BlankCustomerCategory = (props, docid) => {
    let blankName = docid ? "Категория клиента:" : "Новая категория клиента:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-customercategory",
        [HELP_KEYS.PROJECT]: 3365,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 170,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$K = {
    targetClass: "C4C.Справочники.КатегорияКлиента",
    rootName: "Категория клиента",
    urlPath: "CustomerCategory",
    __projectId__: 3365,
};

const CardCustomerCategory = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$K,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankCustomerCategory);   

    cardFile.urlPath = settings$K.urlPath;


    return cardFile;
};

CardCustomerCategory.settings = settings$K;

//import { Message } from "Core/index.js";
//import { createOrUpdateRecord, getRecord } from "Core/api/index.js";
// import { getUserId } from "Core/utils/index";

const BlankRouteToMarket = (props, docid) => {
    let blankName = docid ? "Тип Route-To-Market:" : "Новый тип Route-To-Market:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-routetomarkettype",
        [HELP_KEYS.PROJECT]: 3366,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 240,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);
    blank.addItem(row1);
    
    return blank;
};

const settings$J = {
    targetClass: "C4C.Справочники.ТипRouteToMarket",
    rootName: "Тип Route-To-Market",
    urlPath: "RouteToMarketType",
    __projectId__: 3366,
};

const CardRouteToMarketType = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 300,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$J,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankRouteToMarket);

    cardFile.urlPath = settings$J.urlPath;


    return cardFile;
};

CardRouteToMarketType.settings = settings$J;

const BlankPOCMetric = (props, docid) => {
    let blankName = docid ? "Измерение для ТТ:" : "Новое измерение для ТТ:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-pocmetric",
        [HELP_KEYS.PROJECT]: 3306,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 200,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$I = {
    targetClass: "C4C.Справочники.ИзмерениеДляТТ",
    rootName: "Измерение для ТТ",
    urlPath: "POCMetric",
    __projectId__: 3306,
};

const CardPOCMetric = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [
        
        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 210,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$I,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankPOCMetric);

    cardFile.urlPath = settings$I.urlPath;


    return cardFile;
};

CardPOCMetric.settings = settings$I;

//import { Message } from "Core/index.js";
//import { createOrUpdateRecord, getRecord } from "Core/api/index.js";
// import { getUserId } from "Core/utils/index";

const BlankSalesMetric = (props, docid) => {
    let blankName = docid ? "Метрика продаж:" : "Новая метрика продаж:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-salesmetric",
        [HELP_KEYS.PROJECT]: 3307,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 240,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);
    blank.addItem(row1);
    
    return blank;
};

const settings$H = {
    targetClass: "C4C.Справочники.МетрикиПродаж",
    rootName: "Метрики продаж",
    urlPath: "SalesMetric",
    __projectId__: 3307,
};

const CardSalesMetric = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 240,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$H,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankSalesMetric);

    cardFile.urlPath = settings$H.urlPath;


    return cardFile;
};

CardSalesMetric.settings = settings$H;

//import { Message } from "Core/index.js";
//import { createOrUpdateRecord, getRecord } from "Core/api/index.js";
// import { getUserId } from "Core/utils/index";

const BlankSalesMetricNumber = (props, docid) => {
    let blankName = docid ? "Метрика продаж (знач.):" : "Новая метрика продаж (знач.):";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-salesmetricnumber",
        [HELP_KEYS.PROJECT]: 3314,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 240,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);
    blank.addItem(row1);
    
    return blank;
};

const settings$G = {
    targetClass: "C4C.Справочники.ЗначМетрикПродаж",
    rootName: "Значение метрик продаж",
    urlPath: "SalesMetricNumber",
    __projectId__: 3314,
};

const CardSalesMetricNumber = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 240,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$G,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankSalesMetricNumber);

    cardFile.urlPath = settings$G.urlPath;


    return cardFile;
};

CardSalesMetricNumber.settings = settings$G;

const BlankOperatingDaysPerWeek = (props, docid) => {
    let blankName = docid ? "Рабочих дней в неделю:" : "Рабочих дней в неделю:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-operatingdaysperweek",
        [HELP_KEYS.PROJECT]: 3308,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 200,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$F = {
    targetClass: "C4C.Справочники.РабочихДнейВНеделю",
    rootName: "Рабочих дней в неделю",
    urlPath: "OperatingDaysPerWeek",
    __projectId__: 3308,
};

const CardOperatingDaysPerWeek = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$F,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankOperatingDaysPerWeek);   

    cardFile.urlPath = settings$F.urlPath;


    return cardFile;
};

CardOperatingDaysPerWeek.settings = settings$F;

const BlankPrimaryConsumers = (props, docid) => {
    let blankName = docid ? "Основные потребители:" : "Основные потребители:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-primaryconsumers",
        [HELP_KEYS.PROJECT]: 3315,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 200,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$E = {
    targetClass: "C4C.Справочники.ОсновныеПотребители",
    rootName: "Основные потребители",
    urlPath: "PrimaryConsumers",
    __projectId__: 3315,
};

const CardPrimaryConsumers = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 210,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$E,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankPrimaryConsumers);

    cardFile.urlPath = settings$E.urlPath;


    return cardFile;
};

CardPrimaryConsumers.settings = settings$E;

const BlankExistingBeverageMachines = (props, docid) => {
    let blankName = docid ? "Текущее кол-во кофе-машин:" : "Текущее кол-во кофе-машин:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-existingbeveragemachines",
        [HELP_KEYS.PROJECT]: 3316,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 200,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$D = {
    targetClass: "C4C.Справочники.ТекущееКолВоКофемашин",
    rootName: "Текущее кол-во кофемашин",
    urlPath: "ExistingBeverageMachines",
    __projectId__: 3316,
};

const CardExistingBeverageMachines = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$D,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankExistingBeverageMachines);   

    cardFile.urlPath = settings$D.urlPath;


    return cardFile;
};

CardExistingBeverageMachines.settings = settings$D;

//import { Message } from "Core/index.js";
//import { createOrUpdateRecord, getRecord } from "Core/api/index.js";
// import { getUserId } from "Core/utils/index";

const BlankBeverageNeeds = (props, docid) => {
    let blankName = docid ? "Что важно в напитках:" : "Что важно в напитках:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-beverageneeds",
        [HELP_KEYS.PROJECT]: 3310,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 170,
    });
 
    //let headerRow = blank.createRow();
    let row1 = blank.createRow();
    //let lowRow = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$C = {
    targetClass: "C4C.Справочники.ЧтоВажноВНапитках",
    rootName: "Что важно в напитках",
    urlPath: "BeverageNeeds",
    __projectId__: 3310,
};

const CardBeverageNeeds = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [
        
        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$C,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankBeverageNeeds);

    cardFile.urlPath = settings$C.urlPath;


    return cardFile;
};

CardBeverageNeeds.settings = settings$C;

//import { Message } from "Core/index.js";
//import { createOrUpdateRecord, getRecord } from "Core/api/index.js";
// import { getUserId } from "Core/utils/index";

const BlankAccountClassification = (props, docid) => {
    let blankName = docid ? "Классификация клиента" : "Новая классификация клиента:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-accountclassification",
        [HELP_KEYS.PROJECT]: 3343,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 180,
    });
 
    //let headerRow = blank.createRow();
    let row1 = blank.createRow();
    //let lowRow = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$B = {
    targetClass: "C4C.Справочники.КлассификацияКлиента",
    rootName: "Классификация клиента",
    urlPath: "AccountClassification",
    __projectId__: 3343,
};

const CardAccountClassification = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$B,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankAccountClassification);

    cardFile.urlPath = settings$B.urlPath;


    return cardFile;
};

CardAccountClassification.settings = settings$B;

//import { Message } from "Core/index.js";
//import { createOrUpdateRecord, getRecord } from "Core/api/index.js";
// import { getUserId } from "Core/utils/index";

const BlankBrandedMenu = (props, docid) => {
    let blankName = docid ? "Брендированное меню:" : "Новое брендированное меню:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-brandedmenu",
        [HELP_KEYS.PROJECT]: 3312,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 180,
    });
 
    //let headerRow = blank.createRow();
    let row1 = blank.createRow();
    //let lowRow = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$A = {
    targetClass: "C4C.Справочники.БрендированноеМеню",
    rootName: "Брендированное меню",
    urlPath: "BrandedMenu",
    __projectId__: 3312,
};

const CardBrandedMenu = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$A,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankBrandedMenu);

    cardFile.urlPath = settings$A.urlPath;


    return cardFile;
};

CardBrandedMenu.settings = settings$A;

//import { Message } from "Core/index.js";
//import { createOrUpdateRecord, getRecord } from "Core/api/index.js";
// import { getUserId } from "Core/utils/index";

const BlankSelfService = (props, docid) => {
    let blankName = docid ? "Самообслуживание:" : "Самообслуживание:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-selfservice",
        [HELP_KEYS.PROJECT]: 3313,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 180,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);
    blank.addItem(row1);
    
    return blank;
};

const settings$z = {
    targetClass: "C4C.Справочники.Самообслуживание",
    rootName: "Самообслуживание",
    urlPath: "SelfService",
    __projectId__: 3313,
};

const CardSelfService = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 240,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$z,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankSelfService);

    cardFile.urlPath = settings$z.urlPath;


    return cardFile;
};

CardSelfService.settings = settings$z;

const BlankCoffeeToBeGivenAway = (props, docid) => {
    let blankName = docid ? "Предоставление бесплатного продукта:" : "Предоставление бесплатного продукта:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-coffeetobegivenaway",
        [HELP_KEYS.PROJECT]: 3309,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 170,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$y = {
    targetClass: "C4C.Справочники.ПредоставБесплатПрод",
    rootName: "Предоставление бесплатного продукта",
    urlPath: "CoffeeToBeGivenAway",
    __projectId__: 3309,
};

const CardCoffeeToBeGivenAway = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$y,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankCoffeeToBeGivenAway);

    cardFile.urlPath = settings$y.urlPath;


    return cardFile;
};

CardCoffeeToBeGivenAway.settings = settings$y;

const BlankExpectedValueCurrency = (props, docid) => {
    let blankName = docid ? "Ожидаемая сумма выручки (валюта):" : "Ожидаемая сумма выручки (валюта):";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-expectedvaluecurrency",
        [HELP_KEYS.PROJECT]: 3317,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 200,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$x = {
    targetClass: "C4C.Справочники.ОжидаемаяСуммаВыручкиВалюта",
    rootName: "Ожидаемая сумма выручки (валюта)",
    urlPath: "ExpectedValueCurrency",
    __projectId__: 3317,
};

const CardExpectedValueCurrency = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$x,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankExpectedValueCurrency);   

    cardFile.urlPath = settings$x.urlPath;


    return cardFile;
};

CardExpectedValueCurrency.settings = settings$x;

const BlankLikelyPurchaseDate = (props, docid) => {
    let blankName = docid ? "Ожидаемый срок закрытия:" : "Ожидаемый срок закрытия:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-likelypurchasedate",
        [HELP_KEYS.PROJECT]: 3318,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 200,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$w = {
    targetClass: "C4C.Справочники.ОжидаемыйСрокЗакрытия",
    rootName: "Ожидаемый срок закрытия",
    urlPath: "LikelyPurchaseDate",
    __projectId__: 3318,
};

const CardLikelyPurchaseDate = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$w,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankLikelyPurchaseDate);   

    cardFile.urlPath = settings$w.urlPath;


    return cardFile;
};

CardLikelyPurchaseDate.settings = settings$w;

const BlankMA = (props, docid) => {
    let blankName = docid ? "Маркетинговая кампания:" : "Новая маркетинговая кампания:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-ma",
        [HELP_KEYS.PROJECT]: 3193,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "NumberDoc",
        type: "string",
        width: 200,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$v = {
    targetClass: "C4C.Документы.МаркетинговаяКампания",
    rootName: "Кампания",
    urlPath: "MarketingActivity",
    __projectId__: 3193,
};

const CardMA = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "NumberDoc",
            text: "Наименование",
            order: "NumberDoc",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$v,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankMA);

    cardFile.urlPath = settings$v.urlPath;


    return cardFile;
};

CardMA.settings = settings$v;

//import { Message } from "Core/index.js";
//import { createOrUpdateRecord, getRecord } from "Core/api/index.js";
// import { getUserId } from "Core/utils/index";

const BlankSalesOrganization = (props, docid) => {
    let blankName = docid ? "Сбытовая организация:" : "Новая сбытовая организация:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-salesorganization",
        [HELP_KEYS.PROJECT]: 3359,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 240,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);
    blank.addItem(row1);
    
    return blank;
};

const settings$u = {
    targetClass: "C4C.Справочники.СбытоваяОрганизация",
    rootName: "Сбытовая организация",
    urlPath: "SalesOrganization",
    __projectId__: 3359,
};

const CardSalesOrganization = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 240,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$u,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankSalesOrganization);

    cardFile.urlPath = settings$u.urlPath;


    return cardFile;
};

CardSalesOrganization.settings = settings$u;

const BlankDistributionChannel = (props, docid) => {
    let blankName = docid ? "Канал сбыта:" : "Новый канал сбыта:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-distributionchannel",
        [HELP_KEYS.PROJECT]: 3397,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 200,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$t = {
    targetClass: "C4C.Справочники.КаналСбыта",
    rootName: "Канал сбыта",
    urlPath: "DistributionChannel",
    __projectId__: 3397,
};

const CardDistributionChannel = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$t,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankDistributionChannel);   

    cardFile.urlPath = settings$t.urlPath;


    return cardFile;
};

CardDistributionChannel.settings = settings$t;

const BlankDivision = (props, docid) => {
    let blankName = docid ? "Сектор:" : "Новый сектор:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-division",
        [HELP_KEYS.PROJECT]: 3360,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 200,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$s = {
    targetClass: "C4C.Справочники.Сектор",
    rootName: "Сектор",
    urlPath: "Division",
    __projectId__: 3360,
};

const CardDivision = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$s,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankDivision);   

    cardFile.urlPath = settings$s.urlPath;


    return cardFile;
};

CardDivision.settings = settings$s;

//import { Message } from "Core/index.js";
//import { createOrUpdateRecord, getRecord } from "Core/api/index.js";
// import { getUserId } from "Core/utils/index";

const BlankSalesUnit = (props, docid) => {
    let blankName = docid ? "Сбытовая единица:" : "Новая сбытовая единица:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-salesunit",
        [HELP_KEYS.PROJECT]: 3359,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 240,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);
    blank.addItem(row1);
    
    return blank;
};

const settings$r = {
    targetClass: "C4C.Справочники.СбытовыеЕдиницы",
    rootName: "Сбытовые единицы",
    urlPath: "SalesUnit",
    __projectId__: 3359,
};

const CardSalesUnit = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 240,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$r,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankSalesUnit);

    cardFile.urlPath = settings$r.urlPath;


    return cardFile;
};

CardSalesUnit.settings = settings$r;

const BlankOwner = (props, docid) => {
    let blankName = docid ? "Владелец:" : "Новый владелец:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-owner",
        [HELP_KEYS.PROJECT]: 3355,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 200,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$q = {
    targetClass: "C4C.Справочники.Владелец",
    rootName: "Владелец",
    urlPath: "Owner",
    __projectId__: 3355,
};

const CardOwner = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$q,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankOwner);   

    cardFile.urlPath = settings$q.urlPath;


    return cardFile;
};

CardOwner.settings = settings$q;

//import { Message } from "Core/index.js";
//import { createOrUpdateRecord, getRecord } from "Core/api/index.js";
// import { getUserId } from "Core/utils/index";

const BlankSalesTeam = (props, docid) => {
    let blankName = docid ? "Команда продаж:" : "Новая команда продаж:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-salesteam",
        [HELP_KEYS.PROJECT]: 3351,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 240,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);
    blank.addItem(row1);
    
    return blank;
};

const settings$p = {
    targetClass: "C4C.Справочники.КомандаПродаж",
    rootName: "Команда продаж",
    urlPath: "SalesTeam",
    __projectId__: 3351,
};

const CardSalesTeam = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 240,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$p,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankSalesTeam);

    cardFile.urlPath = settings$p.urlPath;


    return cardFile;
};

CardSalesTeam.settings = settings$p;

const BlankLeadAssignTo = (props, docid) => {
    let blankName = docid ? "Ответств. за потенц. возможность:" : "Новый ответств. за потенц. возможность:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-leadassignto",
        [HELP_KEYS.PROJECT]: 3302,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 200,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$o = {
    targetClass: "C4C.Справочники.ОтветствЗаПотенцВозможность",
    rootName: "Ответственный за потенциальную возможность",
    urlPath: "LeadAssignTo",
    __projectId__: 3302,
};

const CardLeadAssignTo = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [
        
        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$o,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankLeadAssignTo);   

    cardFile.urlPath = settings$o.urlPath;


    return cardFile;
};

CardLeadAssignTo.settings = settings$o;

const BlankLead = (props, docid) => {
    const { cardFile } = props;
    const possibleCustomers = o([]);
    const loader = Loader();
    let Tabs = html`<div class="blank-content"></div>`;

    getEnabledActionsForLead(docid).then((res) => {
        const buttons = res.data.elements.map((element) => {
            const button = html`<div class="col-auto">
                ${Button({ text: element.Name, title: element.Desc })}
            </div>`;
            button.addEventListener("click", () => {
                checkBeforeAction(docid, element.Name);
            });

            return button;
        });

        buttonsActions(buttons);
    });
    // };

    const buttonsActions = o([]);

    const modal = Modal();

    function checkBeforeAction(docid, commandName) {
        if (
            commandName == "Отклонить" ||
            commandName == "Поставить на удержание" ||
            commandName == "Передать в продажи" ||
            commandName == "Назначить ответственного" ||
            commandName == "Изменить ответственного"
        ) {
            let blTitle;
            let btnText;

            if (commandName == "Отклонить") {
                blTitle = "Укажите пожалуйста причину отклонения";
                btnText = "Отклонить";
            }
            if (commandName == "Поставить на удержание") {
                blTitle = "Укажите комментарий и дату когда связаться по лиду";
                btnText = "Поставить на удержание";
            }
            if (commandName == "Передать в продажи") {
                blTitle = "Укажите комментарий";
                btnText = "Передать";

                if (Source.getValue().docid == undefined)
                    return Message$1("Не указан источник", "error");
                if (Категория.getValue().docid == undefined)
                    return Message$1("Не указана основная категория", "error");
            }
            if (
                commandName == "Назначить ответственного" ||
                commandName == "Изменить ответственного"
            ) {
                blTitle = "Укажите комментарий";
                btnText = "Назначить";
            }

            let requestCommentBlank = BlankRequestComment({
                rejectFieldWidth: 700,
                rejectFieldHeight: 200,
                command: commandName,
                docid: docid,
                blankTitle: blTitle,
                rejectButtonText: btnText,
            });

            requestCommentBlank.rejectButtonAction = (_) => {
                if (requestCommentBlank.getData() == undefined) {
                    return;
                }

                createOrUpdateRecord(
                    "C4C.Документы.Lead",
                    blank.getData()
                ).then(() => {
                    executeActionForLead(
                        docid,
                        commandName,
                        requestCommentBlank.getData()
                    ).then(async (res) => {
                        if (res.isOk) {
                            modal.hide();
                            cardFile?.updateTable();
                            if ((
                                commandName == "Передать в продажи" ||
                                commandName == "Назначить ответственного" ||
                                commandName == "Изменить ответственного"
                                ) && blank.hide != undefined
                            ){
                                blank.hide();
                            } else {
                                blank.refreshData?.(docid);
                            }
                        }
                    });
                });
            };

            requestCommentBlank.cancelButtonAction = () => modal.hide();
            modal.setContent(requestCommentBlank);
            modal.show();
            return;
        } else {
            createOrUpdateRecord("C4C.Документы.Lead", blank.getData()).then(
                () => {
                    executeActionForLead(docid, commandName).then(
                        async (res) => {
                            if (res.isOk) {
                                modal.hide();
                                cardFile?.updateTable();
                                if (
                                    commandName == "Преобразовать в возможность" && blank.hide != undefined && res.success
                                ) {
                                    blank.hide();
                                } else {
                                    blank.refreshData?.(docid);
                                }
                            }
                        }
                    );
                }
            );
        }
    }

    let blank = Blank({
        data: props,
        title: "Lead №",
        docid,
        class: "blank-lead",
        [HELP_KEYS.PROJECT]: 3300,
    });

    let Status = blank.createField({
        title: "Статус",
        key: "Status",
        reference: CardStatus,
        width: 200,
        disabled: true,
    });
    const isROByStatus = computed(() => Status.getValue()?.docid === 8);

    let docNumber = blank.createField({
        title: "Название лида",
        key: "NumberDoc",
        type: "string",
        width: 300,
        disabled: isROByStatus,
    });

    let id = blank.createField({
        title: "№",
        key: "docid",
        type: "string",
        width: 47,
        disabled: true,
    });

    let requestId = blank.createField({
        title: "Request Id",
        key: "request_id",
        type: "string",
        width: 150,
        disabled: true,
    });
    

    let Ответственный = blank.createField({
        title: "Ответственный",
        key: "Ответственный",
        reference: CardFileEmployee,
        width: 200,
        disabled: true,
    });

    let Initiator = blank.createField({
        title: "Инициатор",
        key: "Инициатор",
        reference: CardFileEmployee,
        width: 200,
        disabled: true,
    });

    //Основная информация
    let Категория = blank.createField({
        title: "Основная категория",
        key: "Категория",
        reference: CardCategory,
        initTree: false,
        disabled: isROByStatus,
        width: 200,
    });

    let Приоритет = blank.createField({
        title: "Приоритет",
        key: "Приоритет",
        reference: CardPriority,
        initTree: false,
        disabled: isROByStatus,
        width: 200,
    });

    let Source = blank.createField({
        title: "Источник",
        key: "Источник",
        reference: CardSource,
        initTree: false,
        disabled: isROByStatus,
        width: 200,
    });
    //Подтаблица

    const OtherCategory = [
        {
            id: "ДопКатегория",
            text: "Интересующая категория",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 300,
            reference: CardCategory,
            disabled: isROByStatus,
        },
    ];

    const TableOtherCategory = blank.createTable({
        column_props: OtherCategory,
        width: 300,
        key: "ДопКатегории",
    });

    let addRowOtherCategory = html`<button
        class="add-button"
        type="button"
    ></button>`;
    addRowOtherCategory.addEventListener("click", (e) => {
        e.preventDefault();
        TableOtherCategory.createEmptyRow();
    });

    //
    blank.createField({
        title: "Создал",
        key: "CreateUser",
        type: "string",
        width: 420,
        disabled: true,
    });

    //Контактная информация
    let existCustomer = blank.createField({
        title: "Существующий клиент",
        key: "СущКлиент",
        type: "checkbox",
        width: 280,
        disabled: isROByStatus,
    });
    let manualInput = blank.createField({
        title: "Ручной ввод",
        key: "РучВвод",
        type: "checkbox",
        width: 226,
        disabled: isROByStatus,
    });

    let Account = blank.createField({
        title: "Аккаунт",
        key: "Аккаунт",
        reference: CardAccount,
        width: 567, //853,
        isHierarchycal: false,
        initTree: false,
        constFilter: "ТипКлиента.Name = 'Клиент'",
        disabled: isROByStatus,
    });

    // let manualInputStr = blank.createField({
    //     title: "Аккаунт",
    //     key: "СтрокаРучногоВвода",
    //     reference: CardAccount,
    //     width: 567,//853,
    //     type: "string",
    //     disabled: isROByStatus,
    // });

    let ContactFirstName = blank.createField({
        title: "Имя контактного лица",
        key: "ИмяКонтакт",
        type: "string",
        width: 280,
        disabled: isROByStatus,
    });

    let ContactLastName = blank.createField({
        title: "Фамилия контактного лица",
        key: "ФамилияКонтакт",
        type: "string",
        width: 280,
        disabled: isROByStatus,
    });

    let Company = blank.createField({
        title: "Холдинг/Франшиза",
        key: "Компания",
        reference: CardHolding,
        width: 260,
        disabled: isROByStatus,
    });

    let ИНН = blank.createField({
        title: "ИНН",
        key: "ИНН",
        type: "string",
        onChange: onInnChange,
        width: 110,
        disabled: isROByStatus,
    });

    let КПП = blank.createField({
        title: "КПП",
        key: "КПП",
        type: "string",
        width: 110,
        disabled: isROByStatus,
    });

    let legalName = blank.createField({
        title: "Юр. наименование",
        key: "ЮрНазваниеКлиента",
        type: "string",
        width: 384,
        disabled: isROByStatus,
        onChange: async (params)=>{
            if (params.value == "" || docNumber.getValue())
                return;
            let res = [];
            res.push(String(getCurrentDateTurbo()));
            if (manualInput.getValue() && legalType.getValue().docid)
            {
                const type = await getRecord$1("C4C.Справочники.ФормаСобственности",legalType.getValue().docid); 
                res.push(type?.Name);
            }
            res.push(params.value);
            console.log(res);
            docNumber.setValue(res.join(" "));             
        }
                        
    });

    let legalType = blank.createField({
        title: "ФС",
        key: "ФормаСобственности",
        reference: CardLegalType,
        width: 90,
        disabled: isROByStatus,
    });


    let legalTypeStr = blank.createField({
        title: "legalTypeStr",
        key: "ФормаСобственностиСтрокой",
        type: "string",
        width: 480,
        //  disabled: isROByStatus,
    });

    let legaladress = blank.createField({
        title: "Юр. адрес",
        key: "ЮрАдрес",
        type: "string",
        width: 480,
        disabled: isROByStatus,
    });

    let legalhid = blank.createField({
        title: "Юр. адрес",
        key: "hid",
        type: "string",
        width: 480,
        disabled: isROByStatus,
    });

    let Mobile = blank.createField({
        title: "Мобильный контактного лица",
        key: "Мобильный",
        type: "phone",
        width: 280,
        disabled: isROByStatus,
    });

    let EMail = blank.createField({
        title: "Эл.почта контактного лица ",
        key: "ЭлПочта",
        type: "string",
        width: 280,
        disabled: isROByStatus,
    });

    let JobTitle = blank.createField({
        title: "Название должности",
        key: "НазваниеДолжности",
        type: "string",
        width: 280,
        disabled: isROByStatus,
    });

    let ContactFunction = blank.createField({
        title: "Функция",
        key: "ФункцияКонтакт",
        reference: CardContactFunction,
        width: 280,
        disabled: isROByStatus,
    });

    let Departament = blank.createField({
        title: "Департамент контактного лица",
        key: "ОтношенияОтдела",
        reference: CardDepartament,
        width: 280,
        disabled: isROByStatus,
    });

    let ContactRole = blank.createField({
        title: "Роль контакта в принятии решений",
        key: "РольКонтакт",
        reference: CardContactRole,
        width: 280,
        disabled: isROByStatus,
    });

    let reasonForRejecting = blank.createField({
        title: "Причина отклонения",
        key: "ПричинаОтклонения",
        reference: CardReasonForDeviation,
        width: 280,
        disabled: isROByStatus,
    });

    let commentForRejecting = blank.createField({
        title: "Комментарий к причине отклонения",
        key: "КомментКОтклонению",
        //type: "textarea",
        type: "string",
        width: 693,
        disabled: isROByStatus,
    });

    const companySearchField = blank.createComponent({
        key: "ЮрНазваниеКлиента",
        Component: ({ value }) => {
            const company = o({ value: value() });
            return html`
                <${DaDataSearchField}
                    placeholder="Начните писать для поиска. ИНН, Юр. Наименование, город..."
                    value=${company}
                    title="Юр. Наименование"
                    disabled=${isROByStatus()}
                    onChange=${({ value }) => {
                        if (value) {
                            ИНН.setValue(value.data.inn);
                            КПП.setValue(value.data.kpp);
                            legalName.setValue(value.value);
                            legaladress.setValue(value.data.address.value);
                            legalhid.setValue(value.data.hid);
                            legalTypeStr.setValue(value.data.opf.short);                            
                        }
                        company(value);
                    }}
                    showSearchButton=${false}
                />
            `;
        },
    });

    // let ContactTitle = blank.createField({
    //     title: "Обращение",
    //     key: "Обращение",
    //     reference: CardContactTitle,
    //     width: 280,
    //     disabled: isROByStatus,
    // });

    // let LinkedInName = blank.createField({
    //     title: "LinkedIn - имя профиля",
    //     key: "LinkedInИмя",
    //     type: "string",
    //     width: 280,
    //     disabled: isROByStatus,
    // });

    //Адрес
    // let HouseNumber = blank.createField({
    //     title: "Номер дома",
    //     key: "НомерДома",
    //     type: "string",
    //     width: 280,
    //     disabled: isROByStatus,
    // });

    // let Street = blank.createField({
    //     title: "Улица",
    //     key: "Улица",
    //     type: "string",
    //     width: 280,
    //     disabled: isROByStatus,
    // });

    // let Address = blank.createField({
    //     title: "Адрес",
    //     key: "Адрес",
    //     type: "string",
    //     width: 280,
    //     disabled: isROByStatus,
    // });

    // let Region = blank.createField({
    //     title: "Регион",
    //     key: "Регион",
    //     reference: CardRegion,
    //     width: 280,
    //     disabled: isROByStatus,
    // });

    // let City = blank.createField({
    //     title: "Город",
    //     key: "Город",
    //     type: "string",
    //     width: 280,
    //     disabled: isROByStatus,
    // });

    // let PostalCode = blank.createField({
    //     title: "Почтовый индекс",
    //     key: "ПочтовыйИндекс",
    //     type: "string",
    //     width: 280,
    //     disabled: isROByStatus,
    // });

    // let CountryRegion = blank.createField({
    //     title: "Страна/Регион",
    //     key: "СтранаРегион",
    //     reference: CardRegion,
    //     width: 280,
    //     disabled: isROByStatus,
    // });

    // let CompanyURL = blank.createField({
    //     title: "Вебсайт",
    //     key: "Вебсайт",
    //     type: "string",
    //     width: 280,
    //     disabled: isROByStatus,
    // });

    //Классификация клиента
    // let AccountType = blank.createField({
    //     title: "Тип клиента",
    //     key: "AccountType",
    //     reference: CardAccountType,
    //     width: 280,
    //     disabled: isROByStatus,
    // });

    // let AccountClassification = blank.createField({
    //     title: "Классификация клиента",
    //     key: "КлассификацияКлиента",
    //     reference: CardAccountClassification,
    //     width: 280,
    //     disabled: isROByStatus,
    // });

    // let CustomerCategory = blank.createField({
    //     title: "Категория клиента",
    //     key: "КатегорияКлиента",
    //     reference: CardCustomerCategory,
    //     width: 280,
    //     disabled: isROByStatus,
    // });

    let IndustrySegment = blank.createField({
        title: "Отраслевой cегмент",
        key: "ОтраслевойСегмент",
        reference: CardCustomerSegment,
        width: 260,
        disabled: isROByStatus,
        isHierarchycal: false,
        initTree: false,
        constFilter: ()=>{
            if (Industry.getValue().docid)
                return "Отрасль = {C4C.Справочники.Отрасль:"+Industry.getValue().docid+"}";            
        },
        onChange: async ({key, value})=>{            
            if (!value.docid)
                return;
            if (!Industry.getValue().docid)
            {
                const valuerec = await getRecord$1("C4C.Справочники.СегментКлиента",value.docid);
                if (!valuerec.Отрасль.docid)
                    return;
                const rec = await getRecord$1("C4C.Справочники.Отрасль",valuerec.Отрасль.docid);
                Industry.setValue(rec);     
            }       
        }
    });

    let Industry = blank.createField({
        title: "Отрасль",
        key: "Отрасль",
        reference: CardIndustry,
        width: 260,
        disabled: isROByStatus,
        onChange: ({ value }) => {
            const docid = value?.docid;
            switch (docid) {
                case 1:
                    HideSubtableColumns(
                        [
                            "ПосетителейВДень",
                            "КолВоСотрудников",
                            "КолВоНомеров",
                            "КолВоЛюдей",
                            "КолВоПассажиров",
                            "КолВоКоек",
                            "КолВоУчащихся",
                            "КолВоСлужащих",
                        ],
                        ["ПосадочныхМест"]
                    );
                    break;
                case 2:
                case 3:
                case 4:
                case 7:
                case 13:
                    HideSubtableColumns(
                        [
                            "ПосадочныхМест",
                            "КолВоСотрудников",
                            "КолВоНомеров",
                            "КолВоЛюдей",
                            "КолВоПассажиров",
                            "КолВоКоек",
                            "КолВоУчащихся",
                            "КолВоСлужащих",
                        ],
                        ["ПосетителейВДень"]
                    );
                    break;
                case 5:
                    HideSubtableColumns(
                        [
                            "ПосадочныхМест",
                            "ПосетителейВДень",
                            "КолВоНомеров",
                            "КолВоЛюдей",
                            "КолВоПассажиров",
                            "КолВоКоек",
                            "КолВоУчащихся",
                            "КолВоСлужащих",
                        ],
                        ["КолВоСотрудников"]
                    );
                    break;
                case 6:
                    HideSubtableColumns(
                        [
                            "ПосадочныхМест",
                            "ПосетителейВДень",
                            "КолВоСотрудников",
                            "КолВоЛюдей",
                            "КолВоПассажиров",
                            "КолВоКоек",
                            "КолВоУчащихся",
                            "КолВоСлужащих",
                        ],
                        ["КолВоНомеров"]
                    );
                    break;
                case 8:
                    HideSubtableColumns(
                        [
                            "ПосадочныхМест",
                            "ПосетителейВДень",
                            "КолВоСотрудников",
                            "КолВоНомеров",
                            "КолВоПассажиров",
                            "КолВоКоек",
                            "КолВоУчащихся",
                            "КолВоСлужащих",
                        ],
                        ["КолВоЛюдей"]
                    );
                    break;
                case 9:
                    HideSubtableColumns(
                        [
                            "ПосадочныхМест",
                            "ПосетителейВДень",
                            "КолВоСотрудников",
                            "КолВоНомеров",
                            "КолВоЛюдей",
                            "КолВоКоек",
                            "КолВоУчащихся",
                            "КолВоСлужащих",
                        ],
                        ["КолВоПассажиров"]
                    );
                    break;
                case 10:
                    HideSubtableColumns(
                        [
                            "ПосадочныхМест",
                            "ПосетителейВДень",
                            "КолВоСотрудников",
                            "КолВоНомеров",
                            "КолВоЛюдей",
                            "КолВоПассажиров",
                            "КолВоУчащихся",
                            "КолВоСлужащих",
                        ],
                        ["КолВоКоек"]
                    );
                    break;
                case 12:
                    HideSubtableColumns(
                        [
                            "ПосадочныхМест",
                            "ПосетителейВДень",
                            "КолВоСотрудников",
                            "КолВоНомеров",
                            "КолВоЛюдей",
                            "КолВоПассажиров",
                            "КолВоКоек",
                            "КолВоСлужащих",
                        ],
                        ["КолВоУчащихся"]
                    );
                    break;
                case 11:
                    HideSubtableColumns(
                        [
                            "ПосадочныхМест",
                            "ПосетителейВДень",
                            "КолВоСотрудников",
                            "КолВоНомеров",
                            "КолВоЛюдей",
                            "КолВоПассажиров",
                            "КолВоКоек",
                            "КолВоУчащихся",
                        ],
                        ["КолВоСлужащих"]
                    );
                    break;
                default:
                    HideSubtableColumns([
                        "ПосадочныхМест",
                        "ПосетителейВДень",
                        "КолВоСотрудников",
                        "КолВоНомеров",
                        "КолВоЛюдей",
                        "КолВоПассажиров",
                        "КолВоКоек",
                        "КолВоУчащихся",
                        "КолВоСлужащих",
                    ]);
            }
        },
    });

    const HideSubtableColumns = (fields = null, show = null) => {
        if (fields)
            fields.forEach((key) => {
                //console.log(key);
                const hiddenColumn = TableTradePoints.getHiddenColumnByKey(key);
                if (hiddenColumn) return;
                const column = TableTradePoints.getColumnByKey(key);
                TableTradePoints.hideColumn(column);
            });
        if (show)
            show.forEach((key) => {
                const hiddenColumn = TableTradePoints.getHiddenColumnByKey(key);
                if (!hiddenColumn) return;
                TableTradePoints.showColumn(hiddenColumn);
            });
    };



    //Классификация потенциальной возможности


    let LikelyPurchaseDate = blank.createField({
        title: "Ожидаемый срок закрытия",
        key: "ОжидаемыйСрокЗакрытия",
        reference: CardLikelyPurchaseDate,
        width: 222, //280
        disabled: isROByStatus,
    });

    //Заметки
    let Notes = blank.createField({
        title: "Заметки",
        key: "Заметки",
        type: "textarea",
        placeholder: "Внесите необходимые заметки к лиду тут...",
        width: 1140,
        height: 70,
        disabled: isROByStatus,
    });

    //Данные о кампании

    let Campaign = blank.createField({
        key: "Кампания",
        title: "Кампания",
        reference: CardMA,
        width: 280,
        onChange: setCampaignInfo,
        disabled: getCurrentRole() == 5 || isROByStatus,
    });
    //()=>{return ((isROByStatus)||(getCurrentRole()==5))},
    //console.log((((isROByStatus)||(getCurrentRole()==5))));

    let CMTCampaignDescription = blank.createField({
        title: "Описание кампании",
        key: "ОписаниеКампании",
        type: "string",
        width: 560,
        disabled: true,
    });

    let CMTCreationDate = blank.createField({
        title: "Дата создания кампании",
        key: "ДатаСозданияКампании",
        type: "string",
        width: 280,
        disabled: true,
    });

    let CMTCampaignID = blank.createField({
        title: "Ид. кампании",
        key: "CMTCampaignID",
        type: "string",
        width: 280,
        disabled: true,
    });

    let CampaignID = blank.createField({
        title: "Ид. кампании",
        key: "CampaignID",
        type: "integer",
        width: 280,
        disabled: true,
    });

    //Организационные данные
    blank.createField({
        title: "Сбытовая организация",
        key: "СбытоваяОрганизация",
        reference: CardSalesOrganization,
        width: 280, //420
        disabled: isROByStatus,
    });

    blank.createField({
        title: "Канал сбыта",
        key: "КаналСбыта",
        reference: CardDistributionChannel,
        width: 280,
        disabled: isROByStatus,
    });

    blank.createField({
        title: "Сектор",
        key: "Сектор",
        reference: CardDivision,
        width: 280,
        disabled: isROByStatus,
    });

    blank.createField({
        title: "Сбытовая единица",
        key: "СбытоваяЕдиница",
        reference: CardSalesUnit,
        width: 280,
        disabled: isROByStatus,
    });

    blank.createField({
        title: "Владелец",
        key: "Владелец",
        reference: CardOwner,
        width: 280,
        disabled: isROByStatus,
    });

    blank.createField({
        title: "Команда продаж",
        key: "КомандаПродаж",
        reference: CardSalesTeam,
        width: 280,
        disabled: isROByStatus,
    });

    function setCampaignInfo(params) {
        let id = params?.value?.docid;
        getRecord$1("Документы.МаркетинговаяКампания", id).then((result) => {
            CMTCampaignDescription.setValue(result.Описание);
            CMTCreationDate.setValue(result.CreateDate);
            CampaignID.setValue(result.docid);
            CMTCampaignID.setValue(result.docid);
        });
    }

    const AddressSearchTable = (data, rowData, ...props) => {
        const [, {cells, columns_hash} , key] = props;
        const value = o(data ? { value: data } : null);
        const handleChange = ({ value: newValue }) => {
            // здесь обработать выбранное значение из дадаты
            if (newValue)
                rowData[key] = newValue?.value;
            else
                rowData[key] = "";
            value(newValue);
            getRegion(newValue?.data).then((result) => {
                getRecord$1("C4C.Справочники.Регион", +result.data.docid).then((result) => {
                    // const [, , , { cells, columns_hash }] = rowData;
                    const Cell = cells[columns_hash["Регион"]];
                    Cell.value.setValue(result);
                });
            });

            const cellGeolat = cells[columns_hash["geo_lat"]];
            cellGeolat.value.setValue(newValue.data.geo_lat);
            const cellGeolon = cells[columns_hash["geo_lon"]];
            cellGeolon.value.setValue(newValue.data.geo_lon);
            const cellCity = cells[columns_hash["city"]];
            cellCity.value.setValue(newValue.data.city);
            const cellStreet = cells[columns_hash["street"]];
            cellStreet.value.setValue(newValue.data.street);
            const cellPostalCode = cells[columns_hash["postal_code"]];
            cellPostalCode.value.setValue(newValue.data.postal_code);

        };

        return html`
            <${DaDataSearchField}
                type="address"
                placeholder="Адрес..."
                cellField=${true}
                value=${value}
                onChange=${handleChange}
                disabled=${isROByStatus}
                enableManualInput=${true}
                showSearchButton=${false}
            />
        `;
    };
    //Подтаблица
    const TradePoints = [
        {
            id: "Регион",
            text: "Регион",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 155,
            reference: CardRegion,
            disabled: isROByStatus,
        },
        {
            id: "ФактАдрес",
            text: "Фактический адрес",
            style: "text-align: center; width: 100%; justify-content: center;",
            fixWidth: 300,
            changeValue: AddressSearchTable,
            // type: "string",
            // disabled: isROByStatus,
        },
        {
            id: "Вывеска",
            text: "Наименование",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 162,
            type: "string",
            disabled: isROByStatus,
        },
        {
            id: "КолВоКофемашин",
            text: "Кол-во кофемашин",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 140,
            type: "integer",
            disabled: isROByStatus,
        },
        {
            id: "ЧашекВДень",
            text: "Чашек в день на точку",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 105,
            type: "integer",
            disabled: isROByStatus,
        },
        //метрики
        {
            id: "ПосадочныхМест",
            text: "Мест",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 105,
            type: "integer",
            isHidden: Industry.getValue().docid != 1,
            disabled: isROByStatus,
        },
        {
            id: "ПосетителейВДень",
            text: "Посетителей",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 105,
            type: "integer",
            isHidden:
                Industry.getValue().docid != 2 &&
                Industry.getValue().docid != 3 &&
                Industry.getValue().docid != 4 &&
                Industry.getValue().docid != 7 &&
                Industry.getValue().docid != 13,
            disabled: isROByStatus,
        },

        {
            id: "КолВоСотрудников",
            text: "Сотрудников",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 105,
            type: "integer",
            isHidden: Industry.getValue().docid != 5,
            disabled: isROByStatus,
        },

        {
            id: "КолВоНомеров",
            text: "Номеров",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 105,
            type: "integer",
            isHidden: Industry.getValue().docid != 6,
            disabled: isROByStatus,
        },

        {
            id: "КолВоЛюдей",
            text: "Людей",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 105,
            type: "integer",
            isHidden: Industry.getValue().docid != 8,
            disabled: isROByStatus,
        },

        {
            id: "КолВоПассажиров",
            text: "Пассажиров",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 105,
            type: "integer",
            isHidden: Industry.getValue().docid != 9,
            disabled: isROByStatus,
        },
        {
            id: "КолВоКоек",
            text: "Коек",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 105,
            type: "integer",
            isHidden: Industry.getValue().docid != 10,
            disabled: isROByStatus,
        },
        {
            id: "КолВоУчащихся",
            text: "Учащихся",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 105,
            type: "integer",
            isHidden: Industry.getValue().docid != 12,
            disabled: isROByStatus,
        },
        {
            id: "КолВоСлужащих",
            text: "Служащих",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 105,
            type: "integer",
            isHidden: Industry.getValue().docid != 11,
            disabled: isROByStatus,
        },
        //конец метрик
        {
            id: "Поставщик",
            text: "Поставщик",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 220,
            type: "string",
            disabled: isROByStatus,
        },
        {
            id: "ОжидаемаяСуммаВыручки",
            text: "Ожидаемая выручка, NPS в год",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
            type: "numeric",
            disabled: isROByStatus,
        },

        {
            id: "geo_lat",
            text: "geo_lat",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
            type: "numeric",
            disabled: true,
            isHidden: true,
        },

        {
            id: "geo_lon",
            text: "geo_lon",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
            type: "numeric",
            disabled: true,
            isHidden: true,
        },
        
        {
            id: "city",
            text: "city",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
            type: "string",
            disabled: true,
            isHidden: true,
        },
                
        {
            id: "street",
            text: "street",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
            type: "string",
            disabled: true,
            isHidden: true,
        },
        
        {
            id: "postal_code",
            text: "postal_code",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
            type: "string",
            isHidden: true,
            disabled: true,

        },
    ];

    const RequestPersonalData = html`<${Button}
        >Отправить запрос по персональным данным<//
    >`;
    const AdditionalInfo = html`<${Button}>Доп. информация<//>`;

    const TableTradePoints = blank.createTable({
        column_props: TradePoints,
        width: 100,
        key: "ТорговыеТочки",
        disableContextMenu: isROByStatus,
    });

    let addRowTradePoints = html`<button
        class="add-button"
        type="button"
    ></button>`;
    addRowTradePoints.addEventListener("click", (e) => {
        if (isROByStatus()) return;
        e.preventDefault();
        TableTradePoints.createEmptyRow();
        // TableTradePoints.createRows([{}]);
    });

    //Подтаблица

    const LifeCycle = [
        {
            id: "ДатаСобытия",
            text: "Дата cобытия",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 210,
            type: "string",
            disabled: true,
        },
        {
            id: "Persona",
            text: "Исполнитель",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 300,
            reference: CardFileEmployee,
            disabled: true,
        },
        {
            id: "ОписаниеСобытия",
            text: "Описание события",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 300,
            type: "string",
            disabled: true,
        },
    ];

    const TableLifeCycle = blank.createTable({
        column_props: LifeCycle,
        width: 300,
        key: "ЖизненныйЦикл",
        disableContextMenu: true,
    });

    let addRowLifeCycle = html`<button
        class="add-button"
        type="button"
    ></button>`;
    addRowLifeCycle.addEventListener("click", (e) => {
        e.preventDefault();
        TableLifeCycle.createEmptyRow();
    });

    //Загрузка файлов
    const filesUploadField = new FilesUploadField({
        onSaveFile: ({ name, data }) => {
            if (isROByStatus()) return;
            const targetClass = "C4C.Документы.Lead";
            const additional = { targetClass, docid };
            return uploadFile({
                name,
                data,
                additional,
            });
        },
        readOnly: isROByStatus,
        confirmUpload: false,
        onDeleteFile: deleteFile,
        addFileBtnText: "Добавить",
        uploadFilesBtnText: "Сохранить",
        title: "Файлы",
    });

    if (docid != null && docid > 0) {
        getFilesList({
            docid,
            targetClass: "C4C.Документы.Lead",
        }).then((res) => {
            //console.log(res);
            filesUploadField.setFiles(res.data.data);
        });
    } else {
        if (!docid) {
            if (getCurrentRole()==2)
                getRecord$1("BaseInt.Status", +2).then((result) => {
                    Status.setValue(result);
                });//5
            else
                getRecord$1("BaseInt.Status", +5).then((result) => {
                    Status.setValue(result);
                });

            getRecord$1("C4C.Справочники.Приоритет", +5).then((result) => {
                Приоритет.setValue(result);
            });

            getRecord$1("BaseInt.Справочники.Persona", +getUserId()).then(
                (result) => {
                    Initiator.setValue(result);
                    Ответственный.setValue(result);
                }
            );
        }
    }

    const fileElement = html`${docid != null
        ? filesUploadField.render()
        : undefined}`;
    let rowFilesUpload = blank.createRow();
    rowFilesUpload.addItems([fileElement]);

    let headerRow = blank.createRow();
    headerRow.addItems([id , docNumber, Status]);

    blank.addHeaderLeftItem(headerRow);

    //Кнопка сохранить
    const saveButton = html`<${Button}>Сохранить<//>`;
    saveButton.addEventListener("click", async () => {
        const result = await createOrUpdateRecord(
            "C4C.Документы.Lead",
            blank.getData()
        );
        if (!result.isOk) {
            console.error(result.data ?? result.error);
            return;
        }
        blank.refreshData(result.data.docid);
        cardFile?.updateTable();
    });

    blank.addHeaderRightItem(saveButton);

    const buttonsContainer = html`
        <div class="buttons-container">${buttonsActions}</div>
    `;

    const dependentDocs = o([]);
    const tree = Tree({
        elements: dependentDocs,
        activeItem: docid,
        onCreateChild: createChild,
        onBindToParent: bindToParent$1,
        onUnbindToParent: unbindToParent$1,
    });

    const commentsActivity = CommentsActivity({
        targetClass: "C4C.Документы.Lead",
        docid,
        comments: props?.Comments,
    });

    let basicInfoItem = html`
        ${BasicInfo$2({
            Категория,
            Source,
            Initiator, 
            Приоритет, 
            Ответственный,
            TableOtherCategory,
            addRowOtherCategory,
            buttonsContainer,
        })}
    `;
    //Tabs
    let ContactInfoItem = html`
        ${ContactInfo({
            ContactFirstName,
            ContactLastName,
            Mobile,
            EMail,
            JobTitle,
            ContactFunction,
            Departament,
            ContactRole,
            RequestPersonalData,
            AdditionalInfo,
        })}
    `;

    let NotesRow = blank.createRow();
    NotesRow.addItems([Notes]);

    let TreeCommentsBlockItem = html`
        ${TreeCommentsBlock$1({ tree, commentsActivity })}
    `;

    let legalEntityInfoItem = html`
        ${legalEntityInfo(
            { possibleCustomers, onFillAccountClick },
            {
                reasonForRejecting,
                commentForRejecting,
                Status,
                existCustomer,
                manualInput,
                // manualInputStr,
                // checkButton,
                Account,
                Company,
                legalName,
                legalType,
                legaladress,
                legalhid,
                ИНН,
                КПП,
                Industry,
                IndustrySegment,
                companySearchField,
            }
        )}
    `;

    let TradePointInfoItem = html`
        ${TradePointInfo({ TableTradePoints, addRowTradePoints })}
    `;

    let LeadClassificationItem = html`
        ${LeadClassification({ LikelyPurchaseDate, Campaign, Notes })}
    `;

    let browseData = html`
        ${legalEntityInfoItem} ${TradePointInfoItem} ${ContactInfoItem}
        ${LeadClassificationItem} ${rowFilesUpload} ${TreeCommentsBlockItem}
    `;

    blank.addItem(basicInfoItem);
    blank.addItem(Tabs);

    //Вкладки
    let BrowseTabContentO = o();
    let AdditionalInfoTabContentO = o();

    const hideAdditionalInfoTabContent = o(false);

    let BrowseTabContent = html`<div class="browse-tab-content">
        ${browseData}
    </div> `;
    BrowseTabContentO(BrowseTabContent);

    let AdditionalInfoTabContent = html`
        <div class="additionalinfo-tab-content">
            <div class="blank-row">${requestId}</div>
            <div class="blank-row">${TableLifeCycle}</div>
        </div>
    `;
    AdditionalInfoTabContentO(AdditionalInfoTabContent);

    if (hideAdditionalInfoTabContent()) hideAdditionalInfoTabContent(false);

    const mainTabType = {
        Browse: { index: 0, name: "Обзор" },
        AdditionalInfo: { index: 0, name: "Доп. информация" },
    };

    let mainTabView = TabView();

    const BrowseTab = mainTabView.addTab(
        mainTabType.Browse.name,
        BrowseTabContentO
    );
    const AdditionalInfoTab = mainTabView.addTab(
        mainTabType.AdditionalInfo.name,
        AdditionalInfoTabContentO
    );

    mainTabView.style.overflow = "auto";
    mainTabView.getTab(0).isActive();
    Tabs.append(mainTabView);

    subscribe$1(() => {
        if (hideAdditionalInfoTabContent()) {
            AdditionalInfoTab.hide();
            BrowseTab.isActive();
        } else {
            AdditionalInfoTab.show();
        }
    });
    //

    observe(blank);
    blank.addEventListener("connected", async () => {
        // Бланк при считывании. По сути в пропсах уже лежит record
        docid != null &&
            docid > 0 &&
            getDependenceDocument({
                targetClass: "C4C.Документы.Lead",
                docid,
            }).then((result) => {
                if (!result.isOk) return console.error(result.error);
                dependentDocs(result.data ? [result.data] : []);
            });
            
        [].forEach.call( document.querySelectorAll('.phone-field-input'), function(input) {
            var keyCode;
            function mask(event) {
                event.keyCode && (keyCode = event.keyCode);
                var pos = this.selectionStart;
                if (pos < 2) event.preventDefault();
                var matrix = "+7 ___-___-__-__",
                    i = 0,
                    def = matrix.replace(/\D/g, ""),
                    val = this.value.replace(/\D/g, ""),
                    new_value = matrix.replace(/[_\d]/g, function(a) {
                        return i < val.length ? val.charAt(i++) || def.charAt(i) : a
                    });
                i = new_value.indexOf("_");
                if (i != -1) {
                    i < 4 && (i = 2);
                    new_value = new_value.slice(0, i);
                }
                var reg = matrix.substr(0, this.value.length).replace(/_+/g,
                    function(a) {
                        return "\\d{1," + a.length + "}"
                    }).replace(/[+()]/g, "\\$&");
                reg = new RegExp("^" + reg + "$");
                if (!reg.test(this.value) || this.value.length < 5 || keyCode > 47 && keyCode < 58) this.value = new_value;
                if (event.type == "blur" && this.value.length < 5)  this.value = "";
            }
        
            input.addEventListener("input", mask, false);
            input.addEventListener("focus", mask, false);
            input.addEventListener("blur", mask, false);
            input.addEventListener("keydown", mask, false);
        
          });
    });

    function createChild() {
        if (!docid) return;
        const initialData = {
            //[projectField.getKey()]: projectField.getData(),
            //[subProjectField.getKey()]: subProjectField.getData(),
            //[parentTaskField.getKey()]: {
            //    docid,
            //    targetClass: settings.targetClass,
            //},
        };
        const ChildBlank = (data) => {
            Object.assign(data, { onActivityCreated });
            const blank = BlankActivity();
            blank.cancelButtonAction = () => {
                modal.hide();
                modal.setContent(null);
            };
            blank.refreshData = async () => {};
            return blank;
        };
        const childBlank = ChildBlank(initialData);
        modal.setContent(childBlank);
        modal.show();
        function onActivityCreated() {
            modal.hide();
            modal.setContent(null);
            //blank.refreshData?.(docid);
        }
    }

    blank.style.height = 90 + "vh";
    blank.style.width = 90 + "vw"; //83
    //blank.style.width = "100%";
    blank.style.maxWidth = 1500+"px";//"min-content";

    async function onInnChange({ value }) {
        // формируем фильтр
        const filter = `ИНН = "${value}"`;

        loader.show();
        const result = await getHierarchyLevel({
            filter,
            targetClass: CardAccount.settings.targetClass,
        });
        loader.hide();

        if (result instanceof Error) {
            possibleCustomers([]);
            return console.error(result);
        }
        // преобразовываем объект в массив
        const records = Object.values(result);
        possibleCustomers(records);
    }

    // заполняем юр лицо, выставляем чек бокс, очищаем возможные юр лица
    async function onFillAccountClick() {
        const customer = possibleCustomers()[0];

        Account.setValue(customer);
        existCustomer.setValue(true);

        possibleCustomers([]);
    }

    return blank;
}; //

const BasicInfo$2 = (fields) => {
    function renderFields() {
        return html`
            <div class="blank-row">
                <div style="display: flex; gap: 0.5em;">
                    ${fields.Приоритет}${fields.Ответственный}                    
                </div>
                ${fields.buttonsContainer}                
            </div>
            <div class="blank-row">
                ${fields.Категория} ${fields.Source} ${fields.Initiator}
            </div>
        `;
    }
    return html`<div class="blank-basicInfo">
        ${renderFields} ${fields.Tabs}
    </div>`;
};

const ContactInfo = (fields) => {
    function renderFields() {
        return html`
            <div class="blank-row">
                ${fields.ContactFirstName}
                ${fields.ContactLastName}${fields.JobTitle}${fields.ContactFunction}
            </div>
            <div class="blank-row">
                ${fields.Mobile} ${fields.EMail}${fields.ContactRole}
                ${fields.Departament}
            </div>
            <div class="blank-row">
                <div class="additionalbuttons-container">
                    ${fields.RequestPersonalData}${fields.AdditionalInfo}
                </div>
            </div>
        `;
    }
    return html`<div class="blank-contactinfo">
        <h3>Контактная информация</h3>
        ${renderFields}
    </div>`;
};

const TreeCommentsBlock$1 = (fields) => {
    function renderFields() {
        return html`${fields.tree}${fields.commentsActivity} `;
    }
    return html`<div class="blank-treecomments">${renderFields}</div>`;
};

function bindToParent$1() {}
function unbindToParent$1() {}

const legalEntityInfo = (props, fields) => {
    // динамически проверяем есть ли возможные юр лица
    const isPossibleCustomersEmpty = computed(
        () => props.possibleCustomers().length === 0
    );
    o();

    function isRejected(){
        if (fields.Status.getValue().docid==3 || fields.Status.getValue().docid==36)
            return html`
                <div class="blank-row" style="margin-bottom: 0px; margin-top: 0.7em;">${fields.reasonForRejecting}${fields.commentForRejecting}</div>
            `;
    }

    function renderFields() {
        // Если по умолчанию, поиск в дадате
        if (!fields.manualInput.getValue()) {
            return html`
                <div class="blank-row">
                    ${fields.Company} ${fields.companySearchField}
                    ${fields.manualInput}
                </div>
                <div class="blank-row">
                    ${fields.Industry} ${fields.legaladress} ${fields.ИНН}
                    ${fields.КПП}
                </div>
                <div class="blank-row">${fields.IndustrySegment}</div>
            `;
        }
        // Это если ручной ввод
        return html`
            <div class="blank-row">
                ${fields.Company} ${fields.legalType}
                ${fields.legalName}${fields.AccountType}${fields.manualInput}
            </div>
            <div class="blank-row">
                ${fields.Industry} ${fields.legaladress} ${fields.ИНН}
                ${fields.КПП}
            </div>
            <div class="blank-row">${fields.IndustrySegment}</div>
            ${() =>
                isPossibleCustomersEmpty()
                    ? null
                    : html`<div class="blank-row">
                          <span
                              onclick=${props.onFillAccountClick}
                              style="color: red; font-size: 1.5rem; cursor: pointer"
                              title="Нажмите для заполнения"
                          >
                              Организация уже существует
                          </span>
                      </div>`}
        `;
    }
    return html`<div class="blank-legalentityinfo">
        ${isRejected}
        <h3>Информация о юридическом лице</h3>
        ${renderFields}
    </div>`;
};

const TradePointInfo = (fields) => {
    function renderFields() {
        return html`
        <div class="blank-row">
            <div class="scroll-table">
                ${fields.TableTradePoints}
            </div>
            ${fields.addRowTradePoints}
        </div>            
        `;
    }
    return html`<div class="blank-TradePointinfo">
        <h3>Информация о точках</h3>
        ${renderFields}
    </div>`;
};

const LeadClassification = (fields) => {
    function renderFields() {
        return html`
            <div class="blank-row">
                ${fields.LikelyPurchaseDate}${fields.Campaign}
            </div>
            <div class="blank-row">${fields.Notes}</div>
        `;
    }
    return html`<div class="blank-leadclassification">
        <h3>Классификация потенциальной возможности</h3>
        ${renderFields}
    </div>`;
};

const settings$n = {
    targetClass: "C4C.Документы.Lead",
    rootName: "Лиды",
    urlPath: "Lead",
    __projectId__: 3300,
};

const CardLead = (props) => {
    let tableHelper = TableHelper();

    getUserId();
    const searchValue = o("");

    const fastFilters = new FastFilters({
        path: "Name",
        onSelect: handleFilterSelect,
        targetClass: settings$n.targetClass,
    });

    function handleFilterSelect() {
        cardFile.updateTable();
    }

    const getHierarchyLevelWithFastFilter = async (props, ...args) => {
        if (!("isHierarchycal" in props)) return getHierarchyLevel(props, ...args);

        await fastFilters.load({ initialFilterIndex: 0 });
        const fastFilter = fastFilters.getCurrentFastFilter();
        if (fastFilter) {
            props.fastFilter = fastFilter;
        }
        return getHierarchyLevel(props, ...args);
    };

    let column_props = [
        {
            id: "IsGroup",
            text: "",
            order: "IsGroup",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell:
                "display: flex; height: 100%; justify-content: center; align-items: center;",
            fixWidth: 25,
            callback: tableHelper.fileOrFolder,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 150,
        },
        {
            id: "NumberDoc",
            text: "Наименование",
            order: "NumberDoc",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },
        {
            id: "Источник",
            text: "Источник",
            order: "Источник.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 120,
        },
        {
            id: "Status",
            text: "Статус",
            order: "Status.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 120,
            reference: CardStatus,

            callback: (data, rowData) => {
                const element = html`<span>${data}</span>`;
                const setColor = () => {
                    const tableCell = element.closest(".table-cell");
                    if (!tableCell) return;
                    tableCell.style.backgroundColor = rowData.StatusColor;
                };
                if (rowData.StatusColor) {
                    observe(element);
                    element.addEventListener("connected", setColor);
                    element.addEventListener("disconnected", () => {
                        element.removeEventListener("connected", setColor);
                        unobserve(element);
                    });
                }

                return element;
            },

        },
        {
            id: "Приоритет",
            text: "Приоритет",
            order: "Приоритет.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 120,
            reference: CardPriority,
        },

        {
            id: "ДатаСледующегоЗвонка",
            text: "План. дата",
            order: "ДатаСледующегоЗвонка",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 92,
        },
        

        {
            id: "Категория",
            text: "Основная категория",
            order: "Категория.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
            reference: CardCategory,
        },
        {
            id: "Ответственный",
            text: "Ответственный",
            order: "Ответственный.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 150,
            reference: CardFileEmployee,
        },
        {
            id: "Компания",
            text: "Компания",
            order: "Компания",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 150,
        },
        {
            id: "КатегорияКлиента",
            text: "Категория клиента",
            order: "КатегорияКлиента.name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
            reference: CardCustomerCategory,
        },
        {
            id: "Отрасль",
            text: "Отрасль",
            order: "Отрасль.name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
            reference: CardCustomerSegment,
        },
        {
            id: "ОтраслевойСегмент",
            text: "Отраслевой сегмент",
            order: "ОтраслевойСегмент.name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
            reference: CardCustomerSegment,
        },
    ];

    const handleSearchChange = () => {
        const filter = ("ТорговыеТочки.Exists(Match(Вывеска, '*"+searchValue()+"*')) or "+
                        "ТорговыеТочки.Exists(Match(ФактАдрес, '*"+searchValue()+"*')) or "+
                        "Match(numberDoc,'*"+searchValue()+"*') or "+
                        "Match(ЮрНазваниеКлиента,'*"+searchValue()+"*') or "+
                        "Match(ЮрАдрес,'*"+searchValue()+"*')");
        if (searchValue()!="")
            cardFile.setIsHierarchycal(false);
        else
            cardFile.setIsHierarchycal(true);                        
        cardFile.setConstFilter(filter);
        cardFile.updateTable();
    };
    const handleSearchInput = (value) => searchValue(value);
    const handleSearchClear = () => {
        handleSearchInput("");
        handleSearchChange();
    };

    let cardFile = CardFile({
        ...settings$n,
        cardWidth: 85,
        getCardFileRequest: getHierarchyLevelWithFastFilter, 
        column_props: column_props, 
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
        order: "CreateDate-",
        customTools: html`
            ${fastFilters.render()}
            <div class="search-tools">                
                <${SearchField}
                    value=${searchValue}
                    onInput=${handleSearchInput}
                    onChange=${handleSearchChange}
                    onClear=${handleSearchClear}
                    placeholder=${"Наименование, юр.лицо, торговая точка"}
                    showSearchButton=${false}
                />
            </div>
        `,
        class: "lead-card-file",
        ...props,
    });

    cardFile.setBlank(BlankLead);

    cardFile.urlPath = settings$n.urlPath;


    return cardFile;
};

CardLead.settings = settings$n;

const settings$m = {
    targetClass: "C4C.Документы.Активность",
    rootName: "Активность",
    urlPath: "Activity",
    __projectId__: 3304,
};

const CardActivity = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Цель",
            text: "Цель",
            order: "Цель",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
        {
            id: "Status",
            text: "Статус",
            order: "Status.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
        {
            id: "Точка",
            text: "Точка",
            order: "Точка.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
        {
            id: "ТипАктивности",
            text: "Тип активности",
            order: "ТипАктивности.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        }, 
        {
            id: "ДатаПлан",
            text: "Дата план",
            order: "ДатаПлан",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
        {
            id: "ДлительностьПлан",
            text: "Длительность план",
            order: "ДлительностьПлан",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
        {
            id: "ДатаФакт",
            text: "Дата факт",
            order: "ДатаФакт",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
        {
            id: "ДлительностьФакт",
            text: "Длительность факт",
            order: "ДлительностьФакт",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },  
    ];

    let cardFile = CardFile({
        ...settings$m,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankActivity);

    cardFile.urlPath = settings$m.urlPath;


    return cardFile;
};

CardActivity.settings = settings$m;

//import { Message } from "Core/index.js";
//import { createOrUpdateRecord, getRecord } from "Core/api/index.js";
// import { getUserId } from "Core/utils/index";

const BlankServiceRequestType = (props, docid) => {
    let blankName = docid ? "Тип сервисного запроса:" : "Новый тип сервисного запроса:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-servicerequesttype",
        [HELP_KEYS.PROJECT]: 3299,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 170,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);
    blank.addItem(row1);
    
    return blank;
};

const settings$l = {
    targetClass: "C4C.Справочники.ТипСервисногоЗапроса",
    rootName: "Тип сервисного запроса",
    urlPath: "ServiceRequestType",
    __projectId__: 3299,
};

const CardServiceRequestType = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$l,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankServiceRequestType);

    cardFile.urlPath = settings$l.urlPath;


    return cardFile;
};

CardServiceRequestType.settings = settings$l;

const BlankEquipmentModel = (props, docid) => {
    let blankName = docid ? "Модель оборудования:" : "Новая модель оборудования:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-equipmentmodel",
        [HELP_KEYS.PROJECT]: 3302,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 200,
    });
    let productId = blank.createField({
        title: "ProductID",
        key: "ProductID",
        type: "string",
        width: 200,
    });
    
 
    let row1 = blank.createRow();

    row1.addItems([name, productId]);

    blank.addItem(row1);

    return blank;
};

const settings$k = {
    targetClass: "C4C.Справочники.МодельОборудования",
    rootName: "Модель оборудования",
    urlPath: "EquipmentModel",
    __projectId__: 3302,
};

const CardEquipmentModel = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [
        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 300,
        },
        {
            id: "ProductID",
            text: "ProductID",
            order: "ProductID",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 100,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 150,
        },
    ];

    let cardFile = CardFile({
        ...settings$k,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankEquipmentModel);

    cardFile.urlPath = settings$k.urlPath;


    return cardFile;
};

CardEquipmentModel.settings = settings$k;

const Report301 = (props) => {
    const { selection = false, st , distrib } = props;
    //const { filter = "" } = props;
    //console.log(distrib);
    let loader = Loader();

    let blank = Blank({ data: "", title: "" });

    let датаПо = blank.createField({
        title: "Дата по",
        key: "датаПо",
        type: "date",
        width: 160,
    });

    датаПо.setValue(getCurrentDateTurbo());

    function refreshReport() {
        if (датаПо.getValue() == null) return;
        loader.show();
        GetReport301({ doe: датаПо.getValue(), st , distrib})
            .then((result) => {
                repData(result.data ?? []);
            })
            .catch((error) => {
                console.log(error);
            })
            .finally(() => loader.hide());
    }

    refreshReport();

    const repData = o([]);

    let refreshButton = html`<${Button} style="margin-right: 10px"
        >Обновить<//
    >`;

    refreshButton.addEventListener("click", () => {
        if (датаПо.getValue() == null)
            return Message$1("Отсутствует дата", "error");

        refreshReport();
    });

    const toolBar = html`<div class="toolbar">
        <div class="filters">
            <h3>301 - Выбор свободных моделей</h3>
            ${датаПо}
        </div>
        <div class="report-buttons"><${HelpLink} projectId=${3413}/>${refreshButton}</div>
    </div>`;

    const reportBody = html`<div class="report301">
        ${toolBar}
        <div class="scrollable">
            ${map(repData, (data) => ReportViewContaiter$9({ ...props, data }))}
        </div>
    </div>`;
    //console.log(reportBody);
    return reportBody;
};

const ReportViewContaiter$9 = (props) => {
    const repTable = ReportTable$9(props);
    const view = html`<div class="report-view-container">${repTable}</div> `;

    return view;
};

const ReportTable$9 = ({ data, selection, onMachineSelect }) => {
    if (!data) return;

    let column_totalRep = [
        {
            id: "Модель",
            text: "Модель",
            order: "Модель",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 340,
        },
    ];

    const columnsRep = data.Columns[0].body;

    columnsRep.forEach((element) => {
        column_totalRep.push({
            id: element.SplitValue,
            text: element.DisplayValue,
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: right;",
            fixWidth: 100,
        });
    });

    if (selection)
        column_totalRep.push({
            id: "Кнопка",
            text: "",
            order: "Модель",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 77,
            changeValue: (...params) => {
                const [, rowData] = params;
                const button = html`<${Button}>Выбрать<//>`;
                button.addEventListener("click", () => {
                    onMachineSelect?.({
                        model: {
                            docid: rowData.Модель_DocId,
                            Name: rowData.Модель,
                        },
                    });
                });
                return button;
            },
        });

    const tableTotalRep = Table({
        column_props: column_totalRep,
        class: "table-total",
    });

    data.Columns.map(({ body }) => body).forEach((columns, rowIndex) => {
        columns.forEach((column) => {
            //console.log(column)
            data.Rows[rowIndex][column.SplitValue] = column.Volume;
        });
    });

    tableTotalRep.createRows(data.Rows);

    const view = html`<div>${tableTotalRep}</div> `;

    return view;
};

const Report302 = (props) => {
    const { selection = false, filter = "", onAccept, tradepoint , st } = props;
    const repData = o();
    const tableRef = new Ref();

    let loader = Loader();

    let blank = Blank({ data: "", title: "" });

    let датаПо = blank.createField({
        title: "Дата по",
        key: "датаПо",
        type: "date",
        width: 160,
        value: getCurrentDateJS(),
    });

    function handleAcceptBtnClick() {
        let data = tableRef.current.getData();
        data = data.filter((rowData) => rowData.Кнопка);
        const keys = [
            { src: "Место", dest: "МестоУстановки" },
            { src: "Модель", dest: "Модель" },
            { src: "Оборудование", dest: "Оборудование"},
            { src: "СервиснаяТерритория", dest: "СервиснаяТерритория"},
            { src: "Площадка", dest: "Площадка"},
        ];

        const selectdata = data.map((rowData) => {
            return keys.reduce((acc, { src, dest }) => {
                const result = {...acc, [dest]: {
                    Name: rowData[src],
                    docid: rowData[`${src}_DocId`],
                }};
                result["СостояниеСтрокой"]="";
                return result;
            }, {});
        });
        onAccept?.({ data: selectdata });
    }
    const confirmButton = html`<${Button} onClick=${handleAcceptBtnClick}>
        Принять
    <//>`;

    function refreshReport() {
        if (датаПо.getValue() == null) return;
        loader.show();
        GetReport302({ doe: датаПо.getValue(), tradepoint, st })
            .then((result) => {
                repData(result.data?.[0]);
            })
            .catch((error) => {
                console.log(error);
            })
            .finally(() => loader.hide());
    }

    let refreshButton = html`<${Button} style="margin-right: 10px">
        Обновить
    <//>`;

    refreshButton.addEventListener("click", () => {
        if (датаПо.getValue() == null)
            return Message$1("Отсутствует дата", "error");

        refreshReport();
    });

    const toolBar = html`<div class="toolbar">
        <div class="filters">
            <h3>302 - Выбор машин на точке</h3>
            ${датаПо}
        </div>
        <div class="report-buttons"><${HelpLink} projectId=${3413}/>${refreshButton}${confirmButton}</div>
    </div>`;

    // const tableObservable = o();
    const renderTable = on(
        repData,
        () => ReportViewContaiter$8({ ...props, data: repData, ref: tableRef }),
        null,
        true
    );

    const reportBody = html`<div class="report302">
        ${toolBar}
        <div class="scrollable">
            ${renderTable}
        </div>
    </div>`;
    
    //Автообновление
    refreshReport();

    //console.log(reportBody);
    return reportBody;
};

const ReportViewContaiter$8 = (props) => {
    const repTable = ReportTable$8(props);
    const view = html`<div class="report-view-container">${repTable}</div>`;
    return view;
};

const ReportTable$8 = ({ data, selection = false, onSelect, ref }) => {
    if (!data()) return;

    let column_totalRep = [
        {
            id: "СервиснаяТерритория",
            text: "СервиснаяТерритория",
            order: "СервиснаяТерритория",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
            isHidden: true,
        },
        {
            id: "СервиснаяТерритория_DocId",
            text: "СервиснаяТерритория_DocId",
            order: "СервиснаяТерритория_DocId",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
            isHidden: true,
        },
        {
            id: "Площадка",
            text: "Площадка",
            order: "Площадка",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
            isHidden: true,
        },
        {
            id: "Площадка_DocId",
            text: "Площадка_DocId",
            order: "Площадка_DocId",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
            isHidden: true,
        },
        {
            id: "Место",
            text: "Место установки",
            order: "Место",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
        },
        {
            id: "Место_DocId",
            text: "Место установки",
            order: "Место",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
            isHidden: true,
        },
        {
            id: "Оборудование",
            text: "Оборудование",
            order: "Оборудование",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
        },
        {
            id: "Оборудование_DocId",
            text: "Оборудование",
            order: "Оборудование",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
            isHidden: true,
        },
        {
            id: "Модель_DocId",
            text: "Модель",
            order: "Модель",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
            isHidden: true,
        },
        {
            id: "Модель",
            text: "Модель",
            order: "Модель",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
        },
    ];

    const columnsRep = data().Columns[0].body;

    columnsRep.forEach((element) => {
        column_totalRep.push({
            id: element.SplitValue,
            text: element.DisplayValue,
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: right;",
            fixWidth: 100,
        });
    });

    if (selection)
        column_totalRep.push({
            id: "Кнопка",
            text: "",
            order: "Модель",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 24,
            type: "checkbox",
            // changeValue: (...params) => {
            //     const [, rowData] = params;
            //     const button = html`<${Button}>Выбрать<//>`;
            //     button.addEventListener("click", () => {
            //         onSelect?.({
            //             model: {
            //                 docid: rowData.Модель_DocId,
            //                 Name: rowData.Модель,
            //             },
            //         });
            //     });
            //     return button;
            // },
        });

    const tableTotalRep = Table({
        column_props: column_totalRep,
        class: "table-total",
    });

    ref.current = tableTotalRep;

    data()
        .Columns.map(({ body }) => body)
        .forEach((columns, rowIndex) => {
            columns.forEach((column) => {
                //console.log(column)
                data().Rows[rowIndex][column.SplitValue] = column.Volume;
            });
        });

    tableTotalRep.createRows(data().Rows);

    return tableTotalRep;
};

const BlankEquipCategory = (props, docid) => {
    let blankName = "Основное средство:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-equipcategory",
        [HELP_KEYS.PROJECT]: 3302,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 200,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$j = {
    targetClass: "C4C.Справочники.ОсновноеСредство",
    rootName: "Основное средство",
    urlPath: "EquipCategory",
    __projectId__: 3302,
};

const CardEquipCategory = (props) => {
    //  let tableHelper = TableHelper();
  
      getUserId();
  
      let column_props = [
  
          {
              id: "Name",
              text: "Наименование",
              order: "Name",
              style: "text-align: center; width: 100%; justify-content: center;",
              styleCell: "text-align: center;",
              fixWidth: 180,
          },
          {
              id: "CreateDate",
              text: "Дата создания",
              order: "CreateDate",
              style: "text-align: center; width: 100%; justify-content: center;",
              styleCell: "text-align: center;",
              fixWidth: 160,
          },
      ];
  
      let cardFile = CardFile({
          ...settings$j,
          ...props,
          cardWidth: 85,
          column_props: column_props,
          inModal: props?.inModal,
          callBackElement: props?.callBackElement,
      });
  
      cardFile.setBlank(BlankEquipCategory);
  
      cardFile.urlPath = settings$j.urlPath;
  
  
      return cardFile;
  };
  
  CardEquipCategory.settings = settings$j;

const BlankEquipmentPosition = (props, docid) => {
    let blankName = "Основное средство:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-equipmentposition",
        [HELP_KEYS.PROJECT]: 3302,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 200,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$i = {
    targetClass: "C4C.Справочники.EquipmentPosition",
    rootName: "Позиция",
    urlPath: "EquipmentPosition",
    __projectId__: 3302,
};

const CardEquipmentPosition = (props) => {
    //  let tableHelper = TableHelper();
  
      getUserId();
  
      let column_props = [
  
          {
              id: "Name",
              text: "Наименование",
              order: "Name",
              style: "text-align: center; width: 100%; justify-content: center;",
              styleCell: "text-align: center;",
              fixWidth: 180,
          },
          {
              id: "CreateDate",
              text: "Дата создания",
              order: "CreateDate",
              style: "text-align: center; width: 100%; justify-content: center;",
              styleCell: "text-align: center;",
              fixWidth: 160,
          },
      ];
  
      let cardFile = CardFile({
          ...settings$i,
          ...props,
          cardWidth: 85,
          column_props: column_props,
          inModal: props?.inModal,
          callBackElement: props?.callBackElement,
      });
  
      cardFile.setBlank(BlankEquipmentPosition);
  
      cardFile.urlPath = settings$i.urlPath;
  
  
      return cardFile;
  };
  
  CardEquipmentPosition.settings = settings$i;

const settings$h = {
    targetClass: "C4C.Справочники.СтатусОборудования",
    rootName: "Статус оборудования",
    urlPath: "EquipmentStatus",
    __projectId__: 3501,
};

const CardStatusEquipment = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 220,
        },

        {
            id: "nameEU",
            text: "Наименование на английском",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 220,
        },

        
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$h,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankParameter);

    cardFile.urlPath = settings$h.urlPath;


    return cardFile;
};

CardStatusEquipment.settings = settings$h;

const BlankEquipment = (props, docid) => {
    let blankName = "Оборудование:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-equipment",
        [HELP_KEYS.PROJECT]: 3302,
    });


    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 200,
    });

    let modelid = blank.createField({
        title: "Модель id",
        key: "IdМодели",
        type: "string",
        width: 200,
        disabled: true,
    });

    let model = blank.createField({
        title: "Модель",
        key: "МодельОборудования",
        reference: CardEquipmentModel,
        width: 200,
        onChange: async (params)=>{            
            if (params.value.docid)
            {            
                const res = await getRecord$1("C4C.Справочники.МодельОборудования",params.value.docid);
                if (res)
                    modelid.setValue(res.ProductID);                
            }else {
                modelid.setValue(null);   
            }
        }
    });

    let manufacturerNumber = blank.createField({
        title: "Номер производителя",
        key: "ManufacturerNumber",
        type: "string",
        width: 200,
    });

    let IDSAP = blank.createField({
        title: "Серийный номер",
        key: "IDSAP",
        type: "string",
        width: 200,
    });

    let equipmentNumber = blank.createField({
        title: "Номер прибора",
        key: "EquipmentNumber",
        type: "string",
        width: 200,
    });

    // let externalID = blank.createField({
    //     title: "Внешний ид.",
    //     key: "ExternalID",
    //     type: "string",
    //     width: 200,
    // });

    let assetNumber = blank.createField({
        title: "Основное средство / Asset",
        key: "AssetNumber",
        type: "string",
        width: 200,
        disabled: true,
    });

    // let productID = blank.createField({
    //     title: "Ид. Продукта",
    //     key: "ProductID",
    //     type: "string",
    //     width: 200,
    // });

    let registeredProductCategory = blank.createField({
        title: "Registered product category",
        key: "RegisteredProductCategory",
        reference: CardEquipCategory,
        width: 200,
    });
    let statusSAP = blank.createField({
        title: "Статус SAP",
        key: "StatusSAP",
        type: "string",
        width: 200,
        disabled: true,
    });
    let validFrom = blank.createField({
        title: "Действителен с",
        key: "ValidFrom",
        type: "date",
        width: 200,
    });
    let validTo = blank.createField({
        title: "Действителен по",
        key: "ValidTo",
        type: "date",
        width: 200,
    });
    let userStatus = blank.createField({
        title: "Пользовательский статус",
        key: "UserStatus",
        reference: CardStatusEquipment,
        width: 200,
        disabled: true,
    });
    let salesOrganization = blank.createField({
        title: "Сбытовая организация",
        key: "SalesOrganization",
        reference: CardSalesOrganization,
        width: 200,
        disabled: true,
    });
    let distributionChannel = blank.createField({
        title: "Канал сбыта",
        key: "DistributionChannel",
        reference: CardDistributionChannel,
        width: 200,
        disabled: true,
    });
    // let manufactureNumber = blank.createField({
    //     title: "Номер производителя",
    //     key: "ManufactureNumber",
    //     type: "string",
    //     width: 200,
    // });
    let position = blank.createField({
        title: "Позиция",
        key: "Position",
        reference: CardEquipmentPosition,
        width: 200,
    });

    blank.addEventListener("connected", async () => {
        if (model.getValue().docid)
        {            
            const res = await getRecord$1("C4C.Справочники.МодельОборудования",model.getValue().docid);
            if (res)
                modelid.setValue(res.ProductID);                
        }
    });

    let basicInfoItem = html`
        ${BasicInfo$1({
            name,
            model, 
            modelid,
            IDSAP,
            manufacturerNumber,
            assetNumber,
            equipmentNumber,
            registeredProductCategory,
            statusSAP,
            validFrom,
            validTo,
            userStatus,
            salesOrganization,
            distributionChannel,
            position,
        })}
    `;

    blank.addItem(basicInfoItem);

    return blank;
};

const BasicInfo$1 = (fields) => {
    function renderFields() {
        return html`
            <div class="blank-row">
                ${fields.manufacturerNumber}${fields.registeredProductCategory}${fields.validFrom}${fields.validTo} 
            </div>
            <div class="blank-row">
                ${fields.IDSAP}${fields.position}${fields.model}${fields.modelid}
            </div>
            <div class="blank-row">
                ${fields.equipmentNumber}${fields.assetNumber}
            </div>
            <div class="blank-row">
                ${fields.userStatus}${fields.statusSAP} ${fields.salesOrganization}${fields.distributionChannel}
            </div>
            <div class="blank-row">
                
            </div>
        `;
    }
    return html`<div class="blank-basicinfo">${renderFields}</div>`;
};

const settings$g = {
    targetClass: "C4C.Справочники.Оборудование",
    rootName: "Оборудование",
    urlPath: "Equipment",
    __projectId__: 3302,
};

const CardEquipment = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "ManufacturerNumber",
            text: "Номер производителя",
            order: "ManufacturerNumber",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },

        {
            id: "IDSAP",
            text: "Серийный номер",
            order: "IDSAP",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },

        {
            id: "UserStatus",
            text: "Статус",
            order: "UserStatus",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },

        {
            id: "МодельОборудования",
            text: "Модель",
            order: "МодельОборудования.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 260,
        },

        // {
        //     id: "Name",
        //     text: "Наименование",
        //     order: "Name",
        //     style: "text-align: center; width: 100%; justify-content: center;",
        //     styleCell: "text-align: center;",
        //     fixWidth: 120,
        // },



        // {
        //     id: "CreateDate",
        //     text: "Дата создания",
        //     order: "CreateDate",
        //     style: "text-align: center; width: 100%; justify-content: center;",
        //     styleCell: "text-align: center;",
        //     fixWidth: 160,
        //     isHidden: true,
        // },
        // {
        //     id: "AssetNumber",
        //     text: "Номер актива",
        //     order: "AssetNumber",
        //     style: "text-align: center; width: 100%; justify-content: center;",
        //     styleCell: "text-align: center;",
        //     fixWidth: 180,
        // },

        // {
        //     id: "RegisteredProductCategory",
        //     text: "Основное средство",
        //     order: "RegisteredProductCategory.Name",
        //     style: "text-align: center; width: 100%; justify-content: center;",
        //     styleCell: "text-align: center;",
        //     fixWidth: 180,
        // },
        {
            id: "StatusSAP",
            text: "Статус SAP",
            order: "StatusSAP",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        // {
        //     id: "ValidFrom",
        //     text: "Действителен с",
        //     order: "ValidFrom",
        //     style: "text-align: center; width: 100%; justify-content: center;",
        //     styleCell: "text-align: center;",
        //     fixWidth: 180,
        // },
        // {
        //     id: "ValidTo",
        //     text: "Действителен по",
        //     order: "ValidTo",
        //     style: "text-align: center; width: 100%; justify-content: center;",
        //     styleCell: "text-align: center;",
        //     fixWidth: 180,
        // },

        // {
        //     id: "SalesOrganization",
        //     text: "Сбытовая организация",
        //     order: "SalesOrganization.Name",
        //     style: "text-align: center; width: 100%; justify-content: center;",
        //     styleCell: "text-align: center;",
        //     fixWidth: 180,
        // },
        // {
        //     id: "DistributionChannel",
        //     text: "Канал сбыта",
        //     order: "DistributionChannel.Name",
        //     style: "text-align: center; width: 100%; justify-content: center;",
        //     styleCell: "text-align: center;",
        //     fixWidth: 180,
        // },

        // {
        //     id: "Position",
        //     text: "Позиция",
        //     order: "Position",
        //     style: "text-align: center; width: 100%; justify-content: center;",
        //     styleCell: "text-align: center;",
        //     fixWidth: 180,
        // },
    ];

    let cardFile = CardFile({
        ...settings$g,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankEquipment);

    cardFile.urlPath = settings$g.urlPath;


    return cardFile;
};

CardEquipment.settings = settings$g;

//import { Message } from "Core/index.js";
//import { createOrUpdateRecord, getRecord } from "Core/api/index.js";
// import { getUserId } from "Core/utils/index";

const BlankReasonForMovement = (props, docid) => {
    let blankName = "Причина движения:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-reasonformovement",
        [HELP_KEYS.PROJECT]: 3302,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 300,
    });

    let nameEU = blank.createField({
        title: "Наименование на английском",
        key: "nameEU",
        type: "string",
        width: 300,
    });

    let codeId = blank.createField({
        title: "Код-id",
        key: "КодID",
        type: "string",
        width: 300,
    });

    let applicableFor = blank.createField({
        title: "Применим для",
        key: "ПрименимДля",
        type: "select",
        options: [{value:"Установка", text:"Установка"},
                  {value:"Замена", text:"Замена"},
                  {value:"Снятие", text:"Снятие"}],
        dataType: "string",
        width: 150,
    });
 
    let row1 = blank.createRow();
    let row2 = blank.createRow();
    let row3 = blank.createRow();
    row1.addItems([name, applicableFor]);
    row2.addItems([nameEU]);
    row3.addItems([codeId]);
    blank.addItem(row1);
    blank.addItem(row2);
    blank.addItem(row3);

    return blank;
};

const settings$f = {
    targetClass: "C4C.Справочники.ПричинаДвижения",
    rootName: "Причина движения",
    urlPath: "ReasonForMovement",
    __projectId__: 3302,
};

const CardReasonForMovement = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 250,
        },
        {
            id: "nameEU",
            text: "Наименование на английском",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 250,
        },
        {
            id: "КодID",
            text: "Код-id",
            order: "КодID",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 150,
        },
        {
            id: "ПрименимДля",
            text: "Применим для",
            order: "ПрименимДля",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 150,
        },

    ];

    let cardFile = CardFile({
        ...settings$f,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankReasonForMovement);

    cardFile.urlPath = settings$f.urlPath;


    return cardFile;
};

CardReasonForMovement.settings = settings$f;

const BlankServiceRequest = (props, docid) => {
    let blankName = "Сервисный запрос:";
    const modal = Modal();
    const {cardFile} = props;
    
    getEnabledActionsForSR(docid).then((res) => {
        const buttons = res.data.elements.map((element) => {
            const button = html`<div class="col-auto">
                ${Button({ text: element.Name, title: element.Desc })}
            </div>`;
            button.addEventListener("click", () => {
                checkBeforeAction(docid, element.Name);
            });

            return button;
        });

        buttonsActions(buttons);
    });

    const buttonsActions = o([]);

    async function checkBeforeAction(docid, commandName) {
        if (
            commandName == "Отменить" ||
            commandName == "Отправить на согласование" || 
            commandName == "Вернуть на доработку"
        ) {
            let blTitle;
            let btnText;

            if (commandName == "Отменить") {
                blTitle = "Укажите пожалуйста причину отмены";
                btnText = "Отменить";
            }
            
            if (commandName == "Отправить на согласование") {
                if (reasonForMovement.getValue().docid==null)
                    return Message$1("Не указана причина движения","error");
                
                blTitle = "Отправка данных на согласование";
                btnText = "Отправить на согласование";
            }

            if (commandName == "Вернуть на доработку") {
                blTitle = "Возврат сервисного запроса инициатору";
                btnText = "Вернуть на доработку";
            }
            

            let requestCommentBlank = BlankRequestComment({
                rejectFieldWidth: 700,
                rejectFieldHeight: 200,
                command: commandName,
                docid: docid,
                blankTitle: blTitle,
                rejectButtonText: btnText,
                typeDoc : "Сервисный запрос",
                documentId : docid, 
            });

            requestCommentBlank.rejectButtonAction = async (_) => {
                if (requestCommentBlank.getData() == undefined) {
                    return;
                }

                await createOrUpdateRecord(
                    "C4C.Документы.СервисныйЗапрос",
                    blank.getData()
                ).then((result) => {
                    docid =  result.data?.docid;
                    executeActionForSR(
                        docid,
                        commandName,
                        requestCommentBlank.getData()
                    ).then(async (res) => {
                        if (res.isOk) {
                            modal.hide();
                            if (blank.hide!=undefined && commandName == "Отправить на согласование" && res.success) 
                            {    
                                blank.hide();
                                cardFile?.updateTable();
                            }
                            else
                                blank.refreshData?.(docid);
                        }
                    });
                });
            };
            
            requestCommentBlank.cancelButtonAction = () => modal.hide();
            modal.setContent(requestCommentBlank);
            modal.show();
            return;
        } else {
            if (
                commandName == "Сформировать наряды" || 
                commandName == "Согласовать запрос на снятие" ||
                commandName == "Согласовать запрос на замену"
            )
                if (reasonForMovement.getValue().docid==null)
                    return Message$1("Не указана причина движения","error");
            await createOrUpdateRecord(
                "C4C.Документы.СервисныйЗапрос",
                blank.getData()
            ).then((result) => {
                docid =  result.data?.docid;
                executeActionForSR(docid, commandName).then(async (res) => {
                    if (res.isOk) {
                        modal.hide();
                        if (blank.hide!=undefined && (commandName == "Согласовать запрос на снятие" || commandName == "Согласовать запрос на замену" || commandName == "Сформировать наряды"))                            
                        {    
                            blank.hide();
                            cardFile?.updateTable();
                        }
                        else
                            blank.refreshData?.(docid);
                    }
                });
            });
        }
    }

    const buttonsContainer = html`
        <div class="buttons-container">${buttonsActions}</div>
    `;

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-servicerequest",
        [HELP_KEYS.PROJECT]: 3296,
    });

    let Status = blank.createField({
        title: "Статус",
        key: "Status",
        reference: CardStatus,
        width: 158,
        disabled: true,
    });
    const isROByStatus = computed(() => (Status.getValue()?.docid === 12 || Status.getValue()?.docid === 17 || Status.getValue()?.docid === 10));

    blank.createField({
        title: "Тема",
        key: "NumberDoc",
        type: "string",
        width: 553,
        disabled: isROByStatus,
    });
    let Номер = blank.createField({
        title: "", //Номер
        key: "docid",
        type: "string",
        width: 70,
        disabled: true,
    });
    let OperDate = blank.createField({
        title: "Дата проведения",
        key: "OperDate",
        type: "date",
        width: 125,
        disabled: isROByStatus,
    });

    let Responsible = blank.createField({
        title: "Ответственный",
        key: "Ответственный",
        reference: CardFileEmployee,
        width: 140,
        disabled: isROByStatus,
    });

    let srTypeName = blank.createField({
        title: "",
        key: "ТипСЗ.Name",
        type: "string",
        width: 180,
        disabled: true,
    });

    let SRType = blank.createField({
        title: "Тип сервисного запроса",
        key: "ТипСЗ",
        reference: CardServiceRequestType,
        width: 167,
        disabled: isROByStatus,
        constFilter: "Name = 'Снятие' or Name = 'Замена'",
        onChange: ({value}) => {
            const name = value?.Name;
            ["Кнопка","МодельЗаменитьНа"].forEach(key => {
                let hiddenColumn = TableEquipmentModels.getHiddenColumnByKey(key);
                if (!hiddenColumn) return;
                TableEquipmentModels.showColumn(hiddenColumn);
            });
            if ( name === "Снятие"){
                ["Кнопка","МодельЗаменитьНа"].forEach(key => {
                    let hiddenColumn = TableEquipmentModels.getHiddenColumnByKey(key);
                    if (hiddenColumn) return;
                    const column = TableEquipmentModels.getColumnByKey(key);
                    TableEquipmentModels.hideColumn(column);
                });
            }
        }
    });


    let distrib = blank.createField({
        title: "Площадка партнера",
        key: "ПлощадкаПартнера",
        reference: CardAccount,
        isHierarchycal: false,
        initTree: false,
        disabled: true,
        width: 200,
        // constFilter: ()=>{
        //     if (serviceTerritory.getValue().docid!=null)
        //         return "СервиснаяТерритория = {C4C.Справочники.Account:"+serviceTerritory.getValue().docid+"} and ТипКлиента.Name = 'Площадка партнера'";            
        //     return "ТипКлиента.Name = 'Площадка партнера'";
        // },
        // onChange: async (params)=>{
        //     if (!params.value?.docid || serviceTerritory.getValue().docid!=null)
        //         return;
        //     const result = await getRecord(
        //         "C4C.Справочники.Account",
        //         params.value.docid);
        //     if (!(result instanceof Error)) {
        //         if (result.СервиснаяТерритория.docid)
        //             serviceTerritory.setValue(result.СервиснаяТерритория);            
        //     }
        // },
        // width: 200,
        // disabled: isROByStatus,
    });

    let serviceTerritory = blank.createField({
        title: "Сервисная территория",
        key: "СервиснаяТерритория",
        reference: CardServiceTerritory,
        isHierarchycal: false,
        initTree: false,
        width: 407,
        disabled: isROByStatus,
        // onChange: async (params)=>{            
        //     if (!params.value?.docid)
        //         return;
        //     distrib.setValue(null);
        //     const st = params.value.docid;
        //     const result = await getHierarchyLevel({
        //         targetClass: "C4C.Справочники.Account",
        //         filter: "СервиснаяТерритория = {C4C.Справочники.Account:"+st+"} and ТипКлиента.Name = 'Площадка партнера'",
        //         isHierarchycal: false,
        //     });            
        //     // if (!(result instanceof Error)) {
        //     //     if (Object.keys(result).length==1)
        //     //         if (!distrib.getValue().docid)
        //     //             distrib.setValue(result[0]);            
        //     // }
        // }
    });

    let Account = blank.createField({
        title: "Клиент",
        key: "Клиент",
        reference: CardAccount,
        isHierarchycal: false,
        initTree: false,
        constFilter: "ТипКлиента.Name = 'Клиент'",
        width: 200,
        disabled: true,
    });

    let Initiator = blank.createField({
        title: "Инициатор",
        key: "Инициатор",
        reference: CardFileEmployee,
        width: 200,
        disabled: isROByStatus,
    });
    let opportunity = blank.createField({
        title: "Возможность",
        key: "opportunity",
        //reference: CardFile,
        width: 200,
        disabled: isROByStatus,
    });
    let datePlan = blank.createField({
        title: "Дата план. выполнения",
        key: "ДатаПлан",
        type: "date",
        width: 200,
        disabled: isROByStatus,
    });
    let reasonForMovement = blank.createField({
        title: "Причина движения",
        key: "ПричинаДвижения",
        reference: CardReasonForMovement,
        constFilter: ()=>
        {
            if (ТипСЗName.getValue()!="")
                return "ПрименимДля = '"+ТипСЗName.getValue()+"'";
            else
                return "";
        },
        width: 338,
        disabled: isROByStatus,
    });

    let tradePoint = blank.createField({
        title: "Точка",
        key: "Точка",
        reference: CardAccount,
        isHierarchycal: false,
        initTree: false,
        disabled: isROByStatus,
        constFilter: () => {
            let filter = [];
            const accountValue = Account.getValue();
            if (accountValue?.docid) {
                filter.push(`Контрагент.docid = ${accountValue.docid}`);
            }
            filter.push(`ТипКлиента = {C4C.Справочники.ТипКлиента:2}`);
            return filter.join(" and ");
        },
        onChange: (...props)=>{
            if ((!Account.getValue().docid)||(!distrib.getValue().docid))
                getRecord$1("C4C.Справочники.Account", +(props[0].value.docid)).then((result) => {
                    if (!Account.getValue().docid) Account.setValue(result.Контрагент);
                    if (!serviceTerritory.getValue().docid) serviceTerritory.setValue(result.СервиснаяТерритория);
                });
        },
        width: 407,
    });

    let ТипСЗName = blank.createField({
        title: "",
        key: "ТипСЗ.Name",
        type: "string",
        width: 180,
        disabled: true,
    });

    const selectModel = html`<${Button}>Выбрать из доступных<//>`;

    //Подтаблица
    const EquipmentModels = [
        {
            id: "МестоУстановки",
            text: "Место",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
            reference: CardInstallationLocation,
            isHierarchycal: false,
            initTree: false,
            disabled: isROByStatus,
            constFilter: () => {
                let filter = [];
                const tradePointValue = tradePoint.getValue();
                if (tradePointValue?.docid) {
                    filter.push(
                        `ТорговаяТочка.docid = ${tradePointValue.docid}`
                    );
                }
                return filter.join(" and ");
            },
        },

        {
            id: "Модель",
            text: "Модель",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
            reference: CardEquipmentModel,
            disabled: true,
        },

        {
            id: "Оборудование",
            text: "Номер производителя",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center; display: flex; align-items: center;",
            fixWidth: 208,
            changeValue: (value, ...rest) => {
                const [,,{cells, columns_hash}] = rest;
                const  handleChange = (ev) => {
                    // ev - event; беру его значение из таргета 
                    ev.target.value;
                    
                    if (srTypeName.getValue() == "Снятие" || srTypeName.getValue() == "Замена" ) {
                        findEquipmentByNumber( SRType.getValue() , serviceTerritory.getValue() , tradePoint.getValue() , ev.target.value).then(async (res) => {
                            if (res.CountRecords == 1) {
                                serviceTerritory.setValue(res.ST);
                                distrib.setValue(res.Площадка);
                                Account.setValue(res.Клиент);
                                tradePoint.setValue(res.Точка);
                                cells[columns_hash['МестоУстановки']]?.value.setValue(res.Место);
                                cells[columns_hash['Модель']]?.value.setValue(res.Модель);
                                cells[columns_hash['Оборудование']]?.value.setValue(res.Оборудование);
                            }
    
                            if (res.CountRecords > 1) {
                                modal.setContent(ReportSelectInstalledEquipment$1({data: res.data, onSelect: ({data}) => {
                                     serviceTerritory.setValue({docid: data.СервиснаяТерритория_ID , Name: data.СервиснаяТерритория});
                                     distrib.setValue({docid: data.Площадка_ID , Name: data.Площадка});
                                     if (data.Клиент_ID != 0 ) {
                                        Account.setValue({docid: data.Клиент_ID , Name: data.Клиент});
                                     }
                                     tradePoint.setValue({docid: data.Точка_ID , Name: data.Точка});
                                     cells[columns_hash['МестоУстановки']]?.value.setValue({docid: data.Место_ID , Name: data.Место});
                                     cells[columns_hash['Модель']]?.value.setValue({docid: data.Модель_ID , Name: data.Модель});
                                     cells[columns_hash['Оборудование']]?.value.setValue({docid: data.Оборудование_ID , Name: data.Оборудование});
                                     modal.hide();
                                }}));
                                modal.show();
                            }
        
                            if (res.CountRecords == 0) {
                                ev.target.blur();
                                return Message$1("Не найдено ни одного совпадения по серийному номеру или нет свободного остатка","error"); 
                            }
        
                        });
                    }
                    

                    // выход из ячейки
                    ev.target.blur();

                    //console.log(ev.target.value);
                };

                const inputSN = html`<input value=${value?.Name} onchange=${handleChange}/>`;

                return inputSN;
            }

        },

        {
            id: "МодельЗаменитьНа",
            text: "Модель замены",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
            reference: CardEquipmentModel,
            //disabled: true,
            isHidden: (ТипСЗName.getValue() == "Снятие"),
        },
        {
            id: "Кнопка",
            text: "",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 93,
            disabled: isROByStatus,
            isHidden: (ТипСЗName.getValue() == "Снятие"),
            changeValue: (...params) => {
                const [, , , { cells, columns_hash }] = params;                
                const modelCell = cells[columns_hash["МодельЗаменитьНа"]];
                const button = html`<${Button}>из наличия<//>`;
                button.addEventListener("click", () => {
                    if (isROByStatus()) 
                        return;

                    if (serviceTerritory.getValue().docid == undefined)
                        return Message$1("Не указана сервисная территория", "error");
                    
                    if (distrib.getValue().docid == undefined)
                        return Message$1("Не указана площадка партнера", "error");
                        

                    let report301Blank = Report301({
                        selection: true,
                        st: serviceTerritory.getValue(),
                        distrib: distrib.getValue(),
                        onMachineSelect: ({ model }) => {
                            modelCell.value.setValue(model); 
                            modal.hide();                          
                        },
                    });
                    modal.setContent(report301Blank);
                    modal.show();
                });
                return button;
            },
        },

        {
            id: "СостояниеСтрокой",
            text: "Состояние",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
            type: "string",
            disabled: true,
        },
        {
            id: "GUID",
            text: "GUID",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
            isHidden: true, 
        },
    ];

    const TableEquipmentModels = blank.createTable({
        column_props: EquipmentModels,
        width: 100,
        key: "Позиции",
        class: "equipment-models-table",
        disableContextMenu: isROByStatus
    });

    let new_row_table_EquipmentModels = [
        {
            МестоУстановки: "",
            Модель: "",
            Статус: "",
            Кнопка: "",
        },
    ];

    let addRowEquipmentModels = html`<button
        class="add-button"
        type="button"
    ></button>`;
    addRowEquipmentModels.addEventListener("click", (e) => {
        if (isROByStatus()) 
        return;
        e.preventDefault();
        if (Account.getValue().docid) {
            TableEquipmentModels.createRows(new_row_table_EquipmentModels);
        }
    });

    //Подтаблица

    const LifeCycle = [
        {
            id: "ДатаСобытия",
            text: "Дата cобытия",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 210,
            type: "string",
            disabled: true,
        },
        {
            id: "Persona",
            text: "Исполнитель",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 300,
            reference: CardFileEmployee,
            disabled: true,
        },
        {
            id: "ОписаниеСобытия",
            text: "Описание события",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 300,
            type: "string",
            disabled: true,
        },
    ];

    const TableLifeCycle = blank.createTable({
        column_props: LifeCycle,
        width: 300,
        key: "ЖизненныйЦикл",
        disableContextMenu: isROByStatus,
    });

    let new_row_table_LifeCycle = [
        {
            ДатаСобытия: "",
            Persona: "",
            ОписаниеСобытия: "",
        },
    ];

    let addRowLifeCycle = html`<button
        class="add-button"
        type="button"
    ></button>`;
    addRowLifeCycle.addEventListener("click", (e) => {
        e.preventDefault();
        TableLifeCycle.createRows(new_row_table_LifeCycle);
    });


    //Загрузка файлов
    const filesUploadField = new FilesUploadField({
        onSaveFile: ({ name, data }) => {
            const targetClass = "C4C.Документы.СервисныйЗапрос";
            const additional = {targetClass, docid}; 
            return uploadFile({
                name,
                data,
                additional,
            }
            );
        },
        readOnly: isROByStatus,
        confirmUpload: false,
        onDeleteFile: deleteFile,
        addFileBtnText: "Добавить",
        uploadFilesBtnText: "Сохранить",
        title: "Файлы",
    });

    if (docid != null && docid > 0) {
        getFilesList({
            docid,
            targetClass: "C4C.Документы.СервисныйЗапрос",
        }).then((res) => {
            filesUploadField.setFiles(res.data.data);
        });
    }

    const fileElement = html` ${docid != null
        ? filesUploadField.render()
        : undefined}`;

    const dependentDocs = o([]);
    //console.log(dependentDocs);
    const tree = Tree({
        elements: dependentDocs,
        activeItem: docid,
        onCreateChild: createChild,
    });

    observe(blank);
    blank.addEventListener("connected", async () => {
        // Бланк при считывании. По сути в пропсах уже лежит record
        docid != null &&
            docid > 0 &&
            getDependenceDocument({
                targetClass: "C4C.Документы.СервисныйЗапрос",
                docid,
            }).then((result) => {
                if (!result.isOk) return console.error(result.error);
                dependentDocs(result.data ? [result.data] : []);
            });
        
        if(!docid)
        {
            const removeButton = html`<${Button}>Снятие<//>`;
            removeButton.addEventListener("click", async () => {
                const resType = await getRecord$1("C4C.Справочники.ТипСервисногоЗапроса",2);
                if (resType)
                    SRType.setValue(resType);
                modal.hide();            
            });
            const replaceButton = html`<${Button}>Замена<//>`;
            replaceButton.addEventListener("click", async () => {
                const resType = await getRecord$1("C4C.Справочники.ТипСервисногоЗапроса",4);
                if (resType)
                    SRType.setValue(resType);
                modal.hide();            
            });
            modal.setContent(html`
            <div class="sr-typeselect">
                <h2>Выберите тип:</h2>
                ${removeButton}${replaceButton}
            </div>            
            `);
            modal.show();
        }
    });

    const commentsActivity = CommentsActivity({
        targetClass: "C4C.Документы.СервисныйЗапрос",
        docid,
        comments: props?.Comments,
    });
    //Кнопка выбрать места установка
    const selectLocations = html`<${Button}>Выбрать оборудование<//>`;

    selectLocations.addEventListener("click", () => {
        if (isROByStatus()) 
        return;
        if (tradePoint.getValue().docid==undefined)
            return Message$1("Не выбрана точка","error");
            
        // if (serviceTerritory.getValue().docid == undefined)
        //     return Message("Не указана сервисная территория", "error");
        
        // if (distrib.getValue().docid == undefined)
        //     return Message("Не указана площадка партнера", "error");
            
        let report302Blank = Report302({
            selection: true,
            //filter: locFilter,
            tradepoint: tradePoint.getValue(),
            st: serviceTerritory.getValue(),
            onAccept: ({ data }) => {
                TableEquipmentModels.clearRows();
                TableEquipmentModels.createRows(data);
                serviceTerritory.setValue(data[0]?.СервиснаяТерритория);
                distrib.setValue(data[0]?.Площадка);
                modal.hide();
            },
        });
        modal.setContent(report302Blank);
        modal.show();
    });

    let headerRow = blank.createRow();
    headerRow.addItems([Номер, OperDate, SRType, Status, Responsible]);

    blank.addHeaderLeftItem(headerRow);

    let mainInfoItem = html`
        ${mainInfo$3({
            buttonsContainer,
            distrib,
            serviceTerritory,
            Account,
            Initiator,
            opportunity,
            datePlan,
            selectModel,
            fileElement,
            tradePoint,
            reasonForMovement,
            selectLocations,
            commentsActivity,
            tree,
            TableEquipmentModels,
            addRowEquipmentModels,                        
            ТипСЗName,
        })}
    `;


    if (!docid) {
        getRecord$1("BaseInt.Status", +6).then((result) => {
            Status.setValue(result);
        });

        getRecord$1("BaseInt.Справочники.Persona", +getUserId()).then(
            (result) => {
                Initiator.setValue(result);
                Responsible.setValue(result);
            }
        );

        OperDate.setValue(getCurrentDateTurbo());

        TableEquipmentModels.createRows(new_row_table_EquipmentModels);
    }

    let Tabs = html`<div class="blank-content"></div>`;
    let browseData = html`
        ${mainInfoItem}
    `;

    //Вкладки
    let BrowseTabContentO = o();
    let AdditionalInfoTabContentO = o();

    const hideAdditionalInfoTabContent = o(false);

    let BrowseTabContent = html`<div class="browse-tab-content">
        ${browseData}
    </div> `;
    BrowseTabContentO(BrowseTabContent);

    let AdditionalInfoTabContent = html`
        <div class="additionalinfo-tab-content">
            <div class="blank-row">${TableLifeCycle}</div>
        </div>
    `;
    AdditionalInfoTabContentO(AdditionalInfoTabContent);

    if (hideAdditionalInfoTabContent()) hideAdditionalInfoTabContent(false);

    const mainTabType = {
        Browse: { index: 0, name: "Обзор" },
        AdditionalInfo: { index: 0, name: "Доп. информация" },
    };

    let mainTabView = TabView();

    mainTabView.addTab(
        mainTabType.Browse.name,
        BrowseTabContentO
    );
    mainTabView.addTab(
        mainTabType.AdditionalInfo.name,
        AdditionalInfoTabContentO
    );

    mainTabView.style.overflow = "auto";
    mainTabView.getTab(0).isActive();
    Tabs.append(mainTabView);

    // const unsubscribe = subscribe(() => {
    //     if (hideAdditionalInfoTabContent()) {
    //         AdditionalInfoTab.hide();
    //         BrowseTab.isActive();
    //     } else {
    //         AdditionalInfoTab.show();
    //     }
    // });
    //blank.addItem(mainInfoItem);
    blank.addItem(Tabs);

    blank.style.maxWidth = "min-content";
    blank.style.height = 90 + "vh";
    blank.style.width = 76 + "vw";
    return blank;      

    function createChild() {
        if (!docid) return;
        const initialData = {
            //[projectField.getKey()]: projectField.getData(),
            //[subProjectField.getKey()]: subProjectField.getData(),
            //[parentTaskField.getKey()]: {
            //    docid,
            //    targetClass: settings.targetClass,
            //},
        };
        const ChildBlank = (data) => {
            Object.assign(data, { onActivityCreated });
            const blank = BlankActivity();
            blank.cancelButtonAction = () => {
                modal.hide();
                modal.setContent(null);
            };
            blank.refreshData = async () => {};
            return blank;
        };
        const childBlank = ChildBlank(initialData);
        modal.setContent(childBlank);
        modal.show();
        function onActivityCreated() {
            modal.hide();
            modal.setContent(null);
            //blank.refreshData?.(docid);
        }
    }
};

const mainInfo$3 = (fields) => {
    function renderFields() {
        if (fields.ТипСЗName.getValue() == "Снятие"){
            return html`
                <h3>Места снятия оборудования</h3>
                <div class="blank-row">
                    ${fields.TableEquipmentModels}
                </div>
            `;
        }else
        if (fields.ТипСЗName.getValue() == "Замена"){
            return html`
                <h3>Замена оборудования</h3>
                <div class="blank-row">
                    ${fields.TableEquipmentModels}${fields.addRowEquipmentModels}
                </div>
            `;
        }
        else
        return html`
        `;
    }
    return html`
        <div class="blank-basicInfo">
            <div class="blank-row">                
                ${fields.serviceTerritory}${fields.buttonsContainer}
            </div>
            <div class="blank-row">
                ${fields.Initiator}${fields.datePlan}
            </div>
            <div class="blank-row">
                ${fields.distrib} ${fields.Account}${fields.reasonForMovement}
            </div>
            <div class="blank-row">
                ${fields.tradePoint}${fields.selectLocations}
            </div>
            ${renderFields}
        </div>

        <div class="blank-row">${fields.fileElement}</div>
        <div class="blank-treecomments">
            ${fields.tree}${fields.commentsActivity}
        </div>
    `;
};


const ReportSelectInstalledEquipment$1 = ({data, onSelect}) => {

    let column_rep_select_equipment = [
        {
            id: "СервиснаяТерритория",
            text: "Сервисная территория",
            order: "СервиснаяТерритория",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 220,
        },
        {
            id: "Площадка",
            text: "Площадка",
            order: "Площадка",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 220,
        },

        {
            id: "Клиент",
            text: "Клиент",
            order: "Клиент",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 220,
        },

        {
            id: "Точка",
            text: "Точка",
            order: "Точка",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 220,
        },

        {
            id: "Место",
            text: "Место",
            order: "Место",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 220,
        },

        {
            id: "Модель",
            text: "Модель",
            order: "Модель",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 220,
        },
        {
            id: "Оборудование",
            text: "Номер производителя",
            order: "Оборудование",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 200,
        },
        {
            id: "Кнопка",
            text: "",
            order: "Оборудование",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 77,
            changeValue: (...params) => {
                const [, rowData] = params;
                const button = html`<${Button}>Выбрать<//>`;
                button.addEventListener("click", () => {
                    onSelect?.({data: rowData});
                });
                return button;
            },
        }
    ];

    const tableSelectEquipment = Table({
        column_props: column_rep_select_equipment,
        class: "table-report",
    });

    tableSelectEquipment.createRows(data);

    return html`
    <div class="modal-inputnumber">                
        <h3>Найдено несколько номеров производителя:</h3>
        <div class="scrollable">
            ${tableSelectEquipment}
        </div>
    </div>
    `;
};

const settings$e = {
    targetClass: "C4C.Документы.СервисныйЗапрос",
    rootName: "Сервисный запрос",
    urlPath: "ServiceRequest",
    __projectId__: 3296,
};

const CardServiceRequest = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "docid",
            text: "№",
            order: "docid",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 80,
        },
        
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 150,
        },
        {
            id: "Status",
            text: "Статус",
            order: "Status.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 140,

            callback: (data, rowData) => {
                const element = html`<span>${data}</span>`;
                const setColor = () => {
                    const tableCell = element.closest(".table-cell");
                    if (!tableCell) return;
                    tableCell.style.backgroundColor = rowData.StatusColor;
                };
                if (rowData.StatusColor) {
                    observe(element);
                    element.addEventListener("connected", setColor);
                    element.addEventListener("disconnected", () => {
                        element.removeEventListener("connected", setColor);
                        unobserve(element);
                    });
                }

                return element;
            },

        },
        {
            id: "ДатаПлан",
            text: "Дата план.",
            order: "ДатаПлан",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 130,
        },
        {
            id: "ТипСЗ",
            text: "Тип сервисного запроса",
            order: "ТипСЗ.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "Клиент",
            text: "Аккаунт",
            order: "Клиент.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
        {
            id: "Ответственный",
            text: "Ответственный",
            order: "Ответственный.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
        {
            id: "ПлощадкаПартнера",
            text: "Площадка партнера",
            order: "ПлощадкаПартнера.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },

        {
            id: "Точка",
            text: "Торговая точка",
            order: "Точка.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },
        {
            id: "Инициатор",
            text: "Инициатор",
            order: "Инициатор.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$e,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
        order: "CreateDate-",
    });

    cardFile.setBlank(BlankServiceRequest);

    cardFile.urlPath = settings$e.urlPath;


    return cardFile;
};

CardServiceRequest.settings = settings$e;

const settings$d = {
    targetClass: "C4C.Справочники.ФазаПродажи",
    rootName: "Фаза продажи",
    urlPath: "SalesPhase",
    __projectId__: 3302,
};

const CardSalesPhase = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$d,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankSalesPhase);

    cardFile.urlPath = settings$d.urlPath;


    return cardFile;
};

CardSalesPhase.settings = settings$d;

// base

const BlankOpportunity = (props, docid) => {
    const { cardFile } = props;
    if (docid != null) {
        getEnabledActionsForOpportunity(docid).then((res) => {
            const buttons = res.data.elements.map((element) => {
                const button = html`<div class="col-auto">
                    ${Button({ text: element.Name, title: element.Desc })}
                </div>`;
                button.addEventListener("click", () => {
                    checkBeforeAction(docid, element.Name);
                });

                return button;
            });

            buttonsActions(buttons);
        });
    }

    const buttonsActions = o([]);

    const modal = Modal();
    let Tabs = html`<div class="blank-content"></div>`;

    async function checkBeforeAction(docid, commandName) {
        if (
            commandName == "Отклонить" ||
            commandName == "Отправить на утверждение" ||
            commandName == "Вернуть на доработку" ||
            commandName == "Проиграно" ||
            commandName == "Выиграно" || 
            commandName == "Отправить на исправление"
        ) {
            let blTitle;
            let btnText;

            if (commandName == "Отклонить") {
                blTitle = "Укажите пожалуйста причину отклонения";
                btnText = "Отклонить";
            }

            if (commandName == "Проиграно") {
                blTitle = "Укажите пожалуйста причину проигрыша";
                btnText = "Проиграно";
            }

            if (commandName == "Выиграно") {
                blTitle = "Укажите пожалуйста причину выигрыша";
                btnText = "Выиграно";
            }            

            if (commandName == "Вернуть на доработку") {
                blTitle = "Укажите пожалуйста причину возврата";
                btnText = "Вернуть";
            }

            if (commandName == "Отправить на исправление") {
                blTitle = "Укажите пожалуйста, что необходимо исправить";
                btnText = "Вернуть";
            }
            

            if (commandName == "Выиграно") {

                const checkCanWinResult = await checkCanWin(
                    docid,
                );

                if (!checkCanWinResult.isOk) return;

            }

            if (commandName == "Отправить на утверждение") {
                blTitle = "Укажите ответственного";
                btnText = "Отправить";

                const tabledata = TableinstallLocations.getData();
                const models = tabledata.filter((m) => m.Модель?.docid);
                if (tabledata.length !== models.length) {
                    return Message$1(
                        "Не все модели в таблице заполнены",
                        "error"
                    );
                }
                const partners = tabledata.filter(
                    (m) => m.СервиснаяТерритория?.docid
                );
                if (tabledata.length !== partners.length) {
                    return Message$1(
                        "Не все сервисные территории в таблице заполнены",
                        "error"
                    );
                }
                const places = tabledata.filter((m) => m.МестоУстановкиСтрокой);
                if (tabledata.length !== places.length) {
                    return Message$1(
                        "Не все места установки в таблице заполнены",
                        "error"
                    );
                }
                const tradePoints = tabledata.filter((m) => m.Точка?.docid);
                if (tabledata.length !== tradePoints.length) {
                    return Message$1(
                        "Не все торговые точки в таблице заполнены",
                        "error"
                    );
                }
            }


            let requestCommentBlank = BlankRequestComment({
                rejectFieldWidth: 700,
                rejectFieldHeight: 200,
                command: commandName,
                docid: docid,
                blankTitle: blTitle,
                rejectButtonText: btnText,
                typeDoc : "Возможность",
            });

            requestCommentBlank.rejectButtonAction = (_) => {
                if (requestCommentBlank.getData() == undefined) {
                    return;
                }

                createOrUpdateRecord(
                    "C4C.Документы.Возможность",
                    blank.getData()
                ).then(() => {
                    executeActionForOpportunity(
                        docid,
                        commandName,
                        requestCommentBlank.getData()
                    ).then(async (res) => {
                        if (res.isOk) {
                            modal.hide();
                            if (blank.hide!=undefined && commandName == "Отправить на утверждение")
                            {    
                                blank.hide();
                                cardFile?.updateTable();
                            }
                            else
                                blank.refreshData?.(docid);
                        }
                    });
                });
            };

            requestCommentBlank.cancelButtonAction = () => modal.hide();
            modal.setContent(requestCommentBlank);
            modal.show();
            return;
        } else {
            if (commandName == "Контракт одобрен"){
                const tabledata = TableinstallLocations.getData();
                const plandate = tabledata.filter((m) => m.ЖелаемаяДата);
                if (tabledata.length !== plandate.length) {
                    return Message$1(
                        "Не заполнены желаемые даты",
                        "error"
                    );
                }
            }

            createOrUpdateRecord(
                "C4C.Документы.Возможность",
                blank.getData()
            ).then(() => {
                executeActionForOpportunity(docid, commandName).then(
                    async (res) => {
                        if (res.isOk) 
                        {
                            modal.hide();                            
                            if (blank.hide!=undefined && commandName == "Контракт одобрен")
                            {    
                                blank.hide();
                                cardFile?.updateTable();
                            }
                            else
                                blank.refreshData?.(docid);
                        }
                    }
                );
            });
        }
    }

    let blank = Blank({
        data: props,
        title: "Возможность:",
        docid,
        class: "blank-opportunity",
        [HELP_KEYS.PROJECT]: 3379,
    });
    let Status = blank.createField({
        title: "Статус",
        key: "Status",
        reference: CardStatus,
        width: 190,
        disabled: true,
    });
    const isROByStatus = computed(() => (Status.getValue()?.docid === 24));

    let docNumber = blank.createField({
        title: "",
        key: "NumberDoc",
        type: "string",
        width: 290,
        disabled: isROByStatus,
    });

    let id = blank.createField({
        title: "№",
        key: "docid",
        type: "string",
        width: 40,
        disabled: true,
    });

    let СтатусУтверждения = blank.createField({
        title: "Статус утверждения",
        key: "СтатусУтверждения",
        reference: CardStatus,
        width: 220,
        disabled: true,
    });

    let СтатусПроверки = blank.createField({
        title: "Статус проверки",
        key: "СтатусПроверки",
        reference: CardStatus,
        width: 220,
        disabled: true,
    });

    let Ответственный = blank.createField({
        title: "Ответственный",
        key: "Ответственный",
        reference: CardFileEmployee,
        width: 220,
        disabled: true,
    });

    //Основная информация
    let Категория = blank.createField({
        title: "Основная интересующая категория",
        key: "Категория",
        reference: CardCategory,
        width: 220,
        disabled: isROByStatus,
    });

    let Приоритет = blank.createField({
        title: "Приоритет",
        key: "Приоритет",
        reference: CardPriority,
        width: 220,
        disabled: isROByStatus,
    });

    let initiator = blank.createField({
        title: "Инициатор",
        key: "Инициатор",
        reference: CardFileEmployee,
        width: 220,
        disabled: true,
    });

    let account = blank.createField({
        title: "Клиент",
        key: "Клиент",
        reference: CardAccount,
        isHierarchycal: false,
        initTree: false,
        constFilter: "ТипКлиента.Name = 'Клиент'",
        width: 220,
        disabled: isROByStatus,
    });

    //Контактная информация
    let contactPerson = blank.createField({
        title: "Контактное лицо",
        key: "КонтактноеЛицо",
        reference: CardFileEmployee,
        width: 220,
        disabled: isROByStatus,
    });

    //Заметки
    let Notes = blank.createField({
        title: "Заметки",
        key: "Заметки",
        type: "textarea",
        placeholder: "Внесите необходимые заметки к возможности тут...",
        width: 1316.5,
        height: 70,
        disabled: isROByStatus,
    });

    //Данные о кампании

    let Campaign = blank.createField({
        key: "Кампания",
        title: "Кампания",
        reference: CardMA,
        width: 280,
        onChange: setCampaignInfo,
        disabled: isROByStatus,
    });

    let CMTCampaignDescription = blank.createField({
        title: "Описание кампании",
        key: "ОписаниеКампании",
        type: "string",
        width: 560,
        disabled: true,
    });

    let CMTCreationDate = blank.createField({
        title: "Дата создания кампании",
        key: "ДатаСозданияКампании",
        type: "string",
        width: 280,
        disabled: true,
    });

    let CMTCampaignID = blank.createField({
        title: "Ид. кампании",
        key: "CMTCampaignID",
        type: "string",
        width: 280,
        disabled: true,
    });

    let CampaignID = blank.createField({
        title: "Ид. кампании",
        key: "CampaignID",
        type: "integer",
        width: 280,
        disabled: true,
    });

    let phase = blank.createField({
        title: "Фаза продажи",
        key: "ФазаПродажи",
        reference: CardSalesPhase,
        width: 220,
        disabled: true,
    });

    let reasonForVictory = blank.createField({
        title: "Причина победы",
        key: "ПричинаПобеды",
        reference: CardReasonForVictory,
        width: 220,
        disabled: isROByStatus,
    });

    let reasonForVictoryDiscription = blank.createField({
        title: "Причина победы описание",
        key: "ПричинаПобедыОписание",
        type: "string",
        width: 220,
        disabled: isROByStatus,
    });

    let reasonForLosing = blank.createField({
        title: "Причина проигрыша",
        key: "ПричинаПроигрыша",
        reference: CardReasonForLosing,
        width: 220,
        disabled: isROByStatus,
    });

    let revenueStartDate = blank.createField({
        title: "Дата начала выручки",
        key: "ДатаНачалаВыручки",
        type: "date",
        width: 220,
        disabled: true,  
        // Ставится автоматом от первого наряда
    });

    let closeDate = blank.createField({
        title: "Дата закрытия",
        key: "ДатаЗакрытия",
        type: "date",
        width: 220,
        disabled: true,
        // Ставится автоматом когда нажимают выиграно или проиграно
    });

    function setCampaignInfo(params) {
        let id = params?.value?.docid;
        getRecord$1("Документы.МаркетинговаяКампания", id).then((result) => {
            CMTCampaignDescription.setValue(result.Описание);
            CMTCreationDate.setValue(result.CreateDate);
            CampaignID.setValue(result.docid);
            CMTCampaignID.setValue(result.docid);
        });
    }

    //Подтаблица

    const LifeCycle = [
        {
            id: "ДатаСобытия",
            text: "Дата cобытия",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 210,
            type: "string",
            disabled: true,
        },
        {
            id: "Persona",
            text: "Исполнитель",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 300,
            reference: CardFileEmployee,
            disabled: true,
        },
        {
            id: "ОписаниеСобытия",
            text: "Описание события",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 300,
            type: "string",
            disabled: true,
        },
    ];

    const TableLifeCycle = blank.createTable({
        column_props: LifeCycle,
        width: 300,
        key: "ЖизненныйЦикл",
        disableContextMenu: true,
    });

    let addRowLifeCycle = html`<button
        class="add-button"
        type="button"
    ></button>`;
    addRowLifeCycle.addEventListener("click", (e) => {
        e.preventDefault();
        TableLifeCycle.createEmptyRow();
    });

    //Подтаблица
    const installLocations = [
        {
            id: "СервиснаяТерритория",
            text: "Сервисная территория",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 190,
            reference: CardServiceTerritory,
            disabled: isROByStatus,
            // isHierarchycal: false,
            // initTree: false,
            // constFilter: () => {
            //     let filter = [];
            //     const accountValue = account.getValue();
            //     if (accountValue?.docid) {
            //         filter.push("ТипКлиента.Name = 'Площадка партнера'");
            //     }
            //     return filter.join(" and ");
            // },
            // onChange: ({ value, cells, columns_hash }) => {
            //     const cell = cells[columns_hash["МестоУстановки"]];
            //     cell.value.setConstFilter(
            //         `ТорговаяТочка.docid = ${value?.docid ?? 0}`
            //     );
            // },
        },
        {
            id: "Точка",
            text: "Точка",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 190,
            reference: CardAccount,
            isHierarchycal: false,
            initTree: false,
            constFilter: () => {
                let filter = [];
                const accountValue = account.getValue();
                if (accountValue?.docid) {
                    filter.push(`Контрагент.docid = ${accountValue.docid}`);
                }
                return filter.join(" and ");
            },
            disabled: isROByStatus,
        },
        {
            id: "МестоУстановкиСтрокой",
            text: "Место установки",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 190,
            type: "string",
            disabled: isROByStatus,
        },
        {
            id: "Модель",
            text: "Модель",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 190,
            reference: CardEquipmentModel,
            disabled: isROByStatus,
        },
        {
            id: "Кнопка",
            text: "",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 93,
            changeValue: (...params) => {
                const [, , , { cells, columns_hash }] = params;
                const modelCell = cells[columns_hash["Модель"]];
                //const distribCell = cells[columns_hash["ПлощадкаПартнера"]];
                const stCell = cells[columns_hash["СервиснаяТерритория"]];
                const button = html`<${Button}>из наличия<//>`;
                button.addEventListener("click", () => {
                    if (isROByStatus())
                        return;
                    if (stCell.value.getValue().docid == undefined)
                        return Message$1("Не указана сервисная территория", "error");
                    // const locFilter =
                    //     "ПлощадкаПартнера = {" +
                    //     distribCell.value.getValue().targetClass +
                    //     ":" +
                    //     distribCell.value.getValue().docid +
                    //     "}";
                    let report301Blank = Report301({
                        selection: true,
                        // filter: locFilter,
                        st: stCell.value.getValue(),
                        onMachineSelect: ({ model }) => {
                            modelCell.value.setValue(model);
                            // getRecord("C4C.Справочники.Оборудование",model.docid).then((result) => {
                            //     modelCell.value.setValue(result.МодельОборудования);
                            // });
                            modal.hide();
                        },
                    });
                    modal.setContent(report301Blank);
                    modal.show();
                });
                return button;
            },
        },

        {
            id: "Оборудование",
            text: "Номер производителя",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
            reference: CardEquipment,
            disabled: true,
        },
        {
            id: "СостояниеСтрокой",
            text: "Состояние",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 140,
            type: "string",
            disabled: true,
        },

        {
            id: "ЖелаемаяДата",
            text: "Желаемая дата",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 120,
            type: "date",
            disabled: isROByStatus,
        },
        {
            id: "Комментарий",
            text: "Комментарий",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 203,
            type: "string",
            disabled: isROByStatus,
        },
        {
            id: "Наряд",
            text: "Наряд",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 140,
            reference: CardWorkOrder,
            isHidden: true,
        },
        {
            id: "GUID",
            text: "GUID",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 203,
            type: "string",
            isHidden: true,
        },
        {
            id: "ФотоМашины",
            text: "Фото машины",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 100,
            isHidden: false,
            changeValue: (...params) => {
                const value = params[0];

                const handleUploadFile = async ({ name, data }) => {
                    // if (isROByStatus())
                    //     return;
                    const [, , , { cells, columns_hash }] = params;
                    const guidCell = cells[columns_hash["GUID"]];
                    const guid = guidCell.value.getValue();
                    const equipphoto = cells[columns_hash["ФотоМашины"]];

                    const result = await uploadFileToOpportunity({
                        name: name,
                        data: data,
                        additional: {
                            guid: guid,
                            fileType: 1,
                            docid: docid,
                        },
                    });
                    if (result.isOk) {
                        equipphoto.value.setValue(true);
                    }
                };

                const handleFilePreview = async () => {                   
                    const [, , , { cells, columns_hash }] = params;
                    const guidCell = cells[columns_hash["GUID"]];
                    const guid = guidCell.value.getValue();
                    const recdocid = docid;
                    const filePreviewModal = () => {
                        const fileuploadPreview = Field({
                            type: "files-upload",
                            key: "ФотоМашины",
                            value: [],
                            onSaveFile: ({ name, data }) => {
                                return;
                            },
                            onDeleteFile: (props) => {
                                // if (isROByStatus())
                                //     return Message("Возможность в статусе 'Только для чтения'", "error");
                                deleteFileOpportunity({
                                    ...props,
                                    recdocid,
                                    guid,
                                });
                                let equipphoto =
                                    cells[columns_hash["ФотоМашины"]];
                                equipphoto.value.setValue(false);
                                modal.hide();
                            },
                            title: "Фото машины на месте установки",
                            acceptFiles: "image/*",
                            FileItemComponent: ImagePreviewItem,
                            multiple: false,
                            uploadButton: {
                                content: Icon({ name: "floppy-disk" }),
                                class: "transparent",
                            },
                        });

                        getFilesListOpportunity({
                            docid,
                            targetClass: "C4C.Документы.Возможность",
                        }).then((res) => {
                            if (!res.isOk) return;
                            const photos = res.data.data?.filter(
                                (file) =>
                                    file.fileType_docid === 1 &&
                                    file.guid === guid
                            );
                            if (photos?.length > 0) {
                                fileuploadPreview.setValue([photos[0]]);
                            }
                        });
                        const backButton = html`<${Button}>Назад<//>`;
                        backButton.addEventListener("click", () => {
                            modal.hide();
                        });

                        let preview = html`
                            <div class="modal-opportunityfile">
                                <div class="buttons-container">
                                    ${backButton}
                                </div>
                                ${fileuploadPreview}
                            </div>
                        `;
                        return preview;
                    };

                    modal.setContent(filePreviewModal);
                    modal.show();
                };

                const uploadStatus = o(-1);

                const fetchStatus = async () => {
                    const [, , , { cells, columns_hash }] = params;
                    const woCell = cells[columns_hash["Наряд"]];
                    const workOrder = woCell.value.getValue().docid;
                    let woStatus;
                    if (workOrder != null) {
                        const result = await getRecord$1(
                            "C4C.Документы.Наряд",
                            workOrder
                        );
                        woStatus = result.Status?.docid;
                    }

                    if (value)
                        uploadStatus(1);
                    //else if (isROByStatus())
                    //    uploadStatus(-2);
                    else if (woStatus != 12)
                        uploadStatus(-1);
                    else
                        uploadStatus(0);

                };

                fetchStatus();

                return html`${() =>
                    FilesButton({
                        loaded: uploadStatus,
                        onUploadFile: handleUploadFile,
                        onFilePreview: handleFilePreview,
                    })}`;

                // return button;
            },
        },
        {
            id: "ФотоСерийногоНомера",
            text: "Фото S/N",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 100,
            isHidden: false,
            changeValue: (...params) => {
                const value = params[0];
                const uploadStatus = o(-1);

                const fetchStatus = async () => {
                    const [, , , { cells, columns_hash }] = params;
                    const woCell = cells[columns_hash["Наряд"]];
                    const workOrder = woCell.value.getValue().docid;
                    let woStatus;
                    if (workOrder != null) {
                        const result = await getRecord$1(
                            "C4C.Документы.Наряд",
                            workOrder
                        );
                        woStatus = result.Status?.docid;
                    }
                    if (value)
                        uploadStatus(1);
                    //else if (isROByStatus())
                    //    uploadStatus(-2);
                    else if (woStatus != 12)
                        uploadStatus(-1);
                    else
                        uploadStatus(0);
                };

                const handleUploadFile = async ({ name, data }) => {
                    // if (isROByStatus())
                    //     return;
                    const [, , , { cells, columns_hash }] = params;
                    const guidCell = cells[columns_hash["GUID"]];
                    const guid = guidCell.value.getValue();
                    const equipphoto = cells[columns_hash["ФотоСерийногоНомера"]];

                    const result = await uploadFileToOpportunity({
                        name: name,
                        data: data,
                        additional: {
                            guid: guid,
                            fileType: 2,
                            docid: docid,
                        },
                    });

                    if (result.isOk) {
                        equipphoto.value.setValue(true);
                    }
                };

                const handleFilePreview = async () => {
                    // открыть модалку с превью
                    const [, , , { cells, columns_hash }] = params;
                    const guidCell = cells[columns_hash["GUID"]];
                    const guid = guidCell.value.getValue();
                    const recdocid = docid;
                    const filePreviewModal = () => {
                        const fileuploadPreview = Field({
                            type: "files-upload",
                            key: "ФотоСерийногоНомера",
                            value: [],
                            onSaveFile: ({ name, data }) => {
                                return;
                            },
                            onDeleteFile: (props) => {
                                // if (isROByStatus())
                                //     return Message("Возможность в статусе 'Только для чтения'", "error");                                
                                deleteFileOpportunity({
                                    ...props,
                                    recdocid,
                                    guid,
                                });
                                let equipphoto =
                                    cells[columns_hash["ФотоСерийногоНомера"]];
                                equipphoto.value.setValue(false);
                                modal.hide();
                            },
                            title: "Фото серийного номера",
                            acceptFiles: "image/*",
                            FileItemComponent: ImagePreviewItem,
                            multiple: false,
                            uploadButton: {
                                content: Icon({ name: "floppy-disk" }),
                                class: "transparent",
                            },
                        });

                        getFilesListOpportunity({
                            docid,
                            targetClass: "C4C.Документы.Возможность",
                        }).then((res) => {
                            if (!res.isOk) return;
                            const photos = res.data.data?.filter(
                                (file) =>
                                    file.fileType_docid === 2 &&
                                    file.guid === guid
                            );
                            if (photos?.length > 0) {
                                fileuploadPreview.setValue([photos[0]]);
                            }
                        });
                        const backButton = html`<${Button}>Назад<//>`;
                        backButton.addEventListener("click", () => {
                            modal.hide();
                        });

                        let preview = html`
                            <div class="modal-opportunityfile">
                                <div class="buttons-container">
                                    ${backButton}
                                </div>
                                ${fileuploadPreview}
                            </div>
                        `;
                        return preview;
                    };

                    modal.setContent(filePreviewModal);
                    modal.show();
                };

                fetchStatus();
                return html`${() =>
                    FilesButton({
                        loaded: uploadStatus,
                        onUploadFile: handleUploadFile,
                        onFilePreview: handleFilePreview,
                    })}`;
            },
        },
    ];

    const TableinstallLocations = blank.createTable({
        column_props: installLocations,
        width: 100,
        key: "МестаУстановки",
        disableContextMenu: isROByStatus,
    });

    let addRowinstallLocations = html`<button
        class="add-button"
        type="button"
    ></button>`;
    addRowinstallLocations.addEventListener("click", (e) => {
        e.preventDefault();
        if (account.getValue().docid) {
            TableinstallLocations.createEmptyRow();
        }
    });

    //Показ фото с ТТ
    const pointsPhotoField = new FilesUploadField({
        title: "Фото торговых точек",
        readOnly: true,
    });

    if (docid != null && docid > 0) {
        getTradePointPhotos({
            docid,
        }).then((res) => {
            if (!res.isOk) return;
            pointsPhotoField.setValue(res.data.data);
        });
    }

    const pointsPhotoElement = html` ${docid != null
        ? pointsPhotoField.render()
        : undefined}`;
    let rowPointsPhoto = blank.createRow();
    rowPointsPhoto.addItems([pointsPhotoElement]);
    //

    //Показ актов
    const actsFilesField = new FilesUploadField({
        title: "Фото актов приема-передачи",
        readOnly: true,
    });

    if (docid != null && docid > 0) {
        getActsList({
            docid,
            targetClass: "C4C.Документы.Возможность",
        }).then((res) => {
            if (!res.isOk) return;
            const actPhotos = res.data.data?.filter(
                (file) => file.fileType_docid === 3
            );
            //filesUploadField.setFiles(res.data.data);
            if (actPhotos?.length > 0) {
                actsFilesField.setValue(actPhotos);
            }
        });
    }

    const actsFileElement = html` ${docid != null
        ? actsFilesField.render()
        : undefined}`;
    let rowActsFiles = blank.createRow();
    rowActsFiles.addItems([actsFileElement]);
    //
    //Загрузка файлов
    const filesUploadField = new FilesUploadField({
        onSaveFile: ({ name, data }) => {            
            return uploadFileToOpportunity({
                name,
                data,
                additional: {
                    fileType: 4,
                    docid: docid,
                },
            });
        },
        confirmUpload: false,
        onDeleteFile: deleteFile,
        addFileBtnText: "Добавить",
        uploadFilesBtnText: "Сохранить",
        title: "Файлы",
        readOnly: isROByStatus,
    });

    if (docid != null && docid > 0) {
        getFilesList({
            docid,
            targetClass: "C4C.Документы.Возможность",
        }).then((res) => {
            if (!res.isOk) return;
                const photos = res.data.data?.filter(
                    (file) =>
                    file.fileType_docid === 4                
                );
                if (photos?.length > 0) {
                    filesUploadField.setValue(photos);
                }
        });
    }

    const fileElement = html` ${docid != null
        ? filesUploadField.render()
        : undefined}`;
    let rowFilesUpload = blank.createRow();
    rowFilesUpload.addItems([fileElement]);
    //

    let headerRow = blank.createRow();
    headerRow.addItems([id, docNumber, Status]);

    blank.addHeaderLeftItem(headerRow);

    //Кнопка сохранить
    const saveButton = html`<${Button}>Сохранить<//>`;
    saveButton.addEventListener("click", async () => {
        const result = await createOrUpdateRecord(
            "C4C.Документы.Возможность",
            blank.getData()
        );
        if (!result.isOk) {
            console.error(result.data ?? result.error);
            return;
        }
        blank.refreshData(result.data.docid);
        cardFile?.updateTable();
    });

    blank.addHeaderRightItem(saveButton);

    const buttonsContainer = html`
        <div class="buttons-container">${buttonsActions}</div>
    `;

    const dependentDocs = o([]);

    const tree = Tree({
        elements: dependentDocs,
        activeItem: docid,
        onCreateChild: createChild,
        onBindToParent: bindToParent,
        onUnbindToParent: unbindToParent,
    });

    const commentsActivity = CommentsActivity({
        targetClass: "C4C.Документы.Возможность",
        docid,
        comments: props?.Comments,
    });

    let basicInfoItem = html`
        ${BasicInfo({
            Status,
            Категория,
            buttonsContainer,
            initiator,
            Ответственный, 
            Приоритет,
            account,
            contactPerson,
            phase,
            СтатусУтверждения,
            СтатусПроверки,
            reasonForVictory,
            reasonForVictoryDiscription,
            revenueStartDate,
            reasonForLosing,
            closeDate,
            Tabs,
        })}
    `;

    let TreeCommentsBlockItem = html`
        ${TreeCommentsBlock({ tree, commentsActivity })}
    `;

    let InstallLocInfoItem = html`
        ${InstallLocInfo({ TableinstallLocations, addRowinstallLocations })}
    `;

    let NotesItem = html` ${NotesInfo({ Notes })} `;

    blank.addItem(basicInfoItem);

    //blank.addItem(InstallLocInfoItem);

    //blank.addItem(NotesItem);

    //blank.addItem(rowFilesUpload);
    //blank.addItem(TreeCommentsBlockItem);

    //blank.addItem(Tabs);

    let browseData = html`
        <!-- ${basicInfoItem} -->
        ${InstallLocInfoItem} ${NotesItem} ${rowPointsPhoto} ${rowActsFiles} ${rowFilesUpload}
        ${TreeCommentsBlockItem}
    `;

    //Вкладки
    let BrowseTabContentO = o();
    let AdditionalInfoTabContentO = o();

    const hideAdditionalInfoTabContent = o(false);

    let BrowseTabContent = html`<div class="browse-tab-content">
        ${browseData}
    </div> `;
    BrowseTabContentO(BrowseTabContent);

    let AdditionalInfoTabContent = html`
        <div class="additionalinfo-tab-content">
            <!-- <div class="blank-row">
                ${reasonForVictory}${reasonForVictoryDiscription}${revenueStartDate}
            </div>
            <div class="blank-row">
                ${reasonForLosing}${closeDate}
            </div> -->
            <div class="blank-row">${TableLifeCycle}</div>
        </div>
    `;
    AdditionalInfoTabContentO(AdditionalInfoTabContent);

    if (hideAdditionalInfoTabContent()) hideAdditionalInfoTabContent(false);

    const mainTabType = {
        Browse: { index: 0, name: "Обзор" },
        AdditionalInfo: { index: 0, name: "Доп. информация" },
    };

    let mainTabView = TabView();

    const BrowseTab = mainTabView.addTab(
        mainTabType.Browse.name,
        BrowseTabContentO
    );
    const AdditionalInfoTab = mainTabView.addTab(
        mainTabType.AdditionalInfo.name,
        AdditionalInfoTabContentO
    );

    mainTabView.style.overflow = "auto";
    mainTabView.getTab(0).isActive();
    Tabs.append(mainTabView);

    subscribe$1(() => {
        if (hideAdditionalInfoTabContent()) {
            AdditionalInfoTab.hide();
            BrowseTab.isActive();
        } else {
            AdditionalInfoTab.show();
        }
    });
    //
    blank.addItem(Tabs);
    observe(blank);
    blank.addEventListener("connected", async () => {
        // Бланк при считывании. По сути в пропсах уже лежит record
        getRecord$1(
            "Документы.МаркетинговаяКампания",
            Campaign.getValue().docid
        ).then((result) => {
            CMTCampaignDescription.setValue(result.Описание);
            CMTCreationDate.setValue(result.CreateDate);
            CampaignID.setValue(result.docid);
            CMTCampaignID.setValue(result.docid);
        });
        docid != null &&
            docid > 0 &&
            getDependenceDocument({
                targetClass: "C4C.Документы.Возможность",
                docid,
            }).then((result) => {
                if (!result.isOk) return console.error(result.error);
                dependentDocs(result.data ? [result.data] : []);
            });
    });

    function createChild() {
        if (!docid) return;
        const initialData = {
            //[projectField.getKey()]: projectField.getData(),
            //[subProjectField.getKey()]: subProjectField.getData(),
            //[parentTaskField.getKey()]: {
            //    docid,
            //    targetClass: settings.targetClass,
            //},
        };
        const ChildBlank = (data) => {
            Object.assign(data, { onActivityCreated });
            const blank = BlankActivity();
            blank.cancelButtonAction = () => {
                modal.hide();
                modal.setContent(null);
            };
            blank.refreshData = async () => {};
            return blank;
        };
        const childBlank = ChildBlank(initialData);
        modal.setContent(childBlank);
        modal.show();
        function onActivityCreated() {
            modal.hide();
            modal.setContent(null);
            //blank.refreshData?.(docid);
        }
    }

    blank.style.maxWidth = 1500+"px";
    //blank.style.minWidth = 90 + "vw";
    blank.style.height = 90 + "vh";
    blank.style.width = 90 + "vw"; //80

    return blank;
};

//
const BasicInfo = (fields) => {
    function renderFields() {
        if (fields.Status.getValue().docid==24)
            return html`${fields.reasonForVictory}${fields.reasonForVictoryDiscription}`;
        else if (fields.Status.getValue().docid==16)
            return html`${fields.reasonForLosing}`;
        else
            return html``;
    }
    // reasonForVictory,
    // reasonForVictoryDiscription,
    // revenueStartDate,
    // reasonForLosing,
    // closeDate,
    return html`
        <div class="blank-basicInfo">
            <div class="blank-row"> 
                ${fields.initiator}${fields.Ответственный}${fields.Приоритет}
                ${fields.buttonsContainer}
            </div>
            <div class="blank-row">                
                ${fields.phase}${fields.СтатусУтверждения}${fields.СтатусПроверки}                    
            </div>
            <div class="blank-row">
                ${fields.Категория}${fields.account}${fields.contactPerson}
            </div>
            <div class="blank-row">
                ${renderFields}${fields.revenueStartDate}${fields.closeDate}
            </div>
        </div>
    `;
};

const TreeCommentsBlock = (fields) => {
    function renderFields() {
        return html` ${fields.tree}${fields.commentsActivity} `;
    }
    return html`<div class="blank-treecomments">${renderFields}</div>`;
};

function bindToParent() {}
function unbindToParent() {}

const InstallLocInfo = (fields) => {
    function renderFields() {
        return html`
            <div class="blank-row">
                <div class="scroll-table">
                    ${fields.TableinstallLocations}
                </div>
                ${fields.addRowinstallLocations}
            </div>
        `;
    }
    return html`<div class="blank-TradePointinfo">
        <h3>Информация о точках</h3>
        ${renderFields}
    </div>`;
};

const NotesInfo = (fields) => {
    function renderFields() {
        return html`        
            <div class="blank-row">${fields.Notes}</div>
        `;
    }
    return html`
        <h3></h3>
        ${renderFields}
    `;
};

//Прикрепление фото
const FilesButton = ({ loaded, onUploadFile, onFilePreview }) => {
    if (loaded() == 1) {
        return LoadedFileButton({ onClick: onFilePreview });
    } else if (loaded() == 0) {
        return AddFileButton({ onChange: onUploadFile });
    } else if (loaded() == -1) {
        return cantBeLoadedButton({
            onClick: () =>
                Message$1("Отстутсвтует наряд в статусе 'Завершено'", "error"),
        });
    } 
    // else if (loaded() == -2) {
    //     return cantBeLoadedButton({
    //         onClick: () =>
    //             Message("Возможность в статусе 'Только для чтения'", "error"),
    //     });
    // }
};

const LoadedFileButton = (props) => {
    return html`<${Button} ...${props} class="green">
        <${Icon} name="file" />
    <//>`;
};

const AddFileButton = (props) => {
    async function handleChange(ev) {
        const { target } = ev;
        const image = target.files[0];
        const fileData = await getFileData(image);
        props?.onChange?.({ name: image.name, data: fileData });
    }
    const element = html`<label class="add-file-button">
        <span class="button red"><${Icon} name="file" /></span>
        <input type="file" multiple=${false} accept="image/*" />
    </label>`;
    element.addEventListener("change", handleChange);
    return element;
};

const cantBeLoadedButton = (props) => {
    return html`<${Button} ...${props} class="red">
        <${Icon} name="file" />
    <//>`;
};

const settings$c = {
    targetClass: "C4C.Документы.Возможность",
    rootName: "Возможность",
    urlPath: "Opportunity",
    __projectId__: 3379,
};

const CardOpportunity = (props) => {
    let tableHelper = TableHelper();

    getUserId();
    const searchValue = o("");

    const fastFilters = new FastFilters({
        path: "Name",
        onSelect: handleFilterSelect,
        targetClass: settings$c.targetClass,
    });

    function handleFilterSelect() {
        cardFile.updateTable();
    }

    const getHierarchyLevelWithFastFilter = async (props, ...args) => {
        if (!("isHierarchycal" in props)) return getHierarchyLevel(props, ...args);

        await fastFilters.load({ initialFilterIndex: 0 });
        const fastFilter = fastFilters.getCurrentFastFilter();
        if (fastFilter) {
            props.fastFilter = fastFilter;
        }
        return getHierarchyLevel(props, ...args);
    };

    let column_props = [
        {
            id: "IsGroup",
            text: "",
            order: "IsGroup",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell:
                "display: flex; height: 100%; justify-content: center; align-items: center;",
            fixWidth: 25,
            callback: tableHelper.fileOrFolder,
        },
        {
            id: "docid",
            text: "№",
            order: "docid",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 40,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 150,
        },
        {
            id: "NumberDoc",
            text: "Наименование",
            order: "NumberDoc",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },
        {
            id: "Status",
            text: "Статус",
            order: "Status.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 120,
            reference: CardStatus,

            callback: (data, rowData) => {
                const element = html`<span>${data}</span>`;
                const setColor = () => {
                    const tableCell = element.closest(".table-cell");
                    if (!tableCell) return;
                    tableCell.style.backgroundColor = rowData.StatusColor;
                };
                if (rowData.StatusColor) {
                    observe(element);
                    element.addEventListener("connected", setColor);
                    element.addEventListener("disconnected", () => {
                        element.removeEventListener("connected", setColor);
                        unobserve(element);
                    });
                }

                return element;
            },

        },

        {
            id: "Клиент",
            text: "Клиент",
            order: "Клиент.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },

        {
            id: "Инициатор",
            text: "Инициатор",
            order: "Инициатор.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 150,
        },

        {
            id: "Ответственный",
            text: "Ответственный",
            order: "Ответственный.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 150,
            reference: CardFileEmployee,
        },
        
        {
            id: "Приоритет",
            text: "Приоритет",
            order: "Приоритет.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 120,
            reference: CardPriority,
        },


        {
            id: "СтатусУтверждения",
            text: "Статус утверждения",
            order: "СтатусУтверждения.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 120,
            reference: CardStatus,
        },

        {
            id: "СтатусПроверки",
            text: "Статус проверки",
            order: "СтатусПроверки.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 120,
            reference: CardStatus,
        },

        {
            id: "ДатаСледующегоЗвонка",
            text: "План. дата",
            order: "ДатаСледующегоЗвонка",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 92,
        },
        

        {
            id: "Категория",
            text: "Основная категория",
            order: "Категория.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
            reference: CardCategory,
        },
    ];

    const handleSearchChange = () => {
        const filter = ("МестаУстановки.Exists(Match(Точка.Name, '*"+searchValue()+"*')) or "+
                        "Match(NumberDoc,'*"+searchValue()+"*') or "+
                        "Match(Клиент.Name,'*"+searchValue()+"*')");
        if (searchValue()!="")
            cardFile.setIsHierarchycal(false);
        else
            cardFile.setIsHierarchycal(true);                        
        cardFile.setConstFilter(filter);
        cardFile.updateTable();
    };
    const handleSearchInput = (value) => searchValue(value);
    const handleSearchClear = () => {
        handleSearchInput("");
        handleSearchChange();
    };

    let cardFile = CardFile({
        ...settings$c,       
        cardWidth: 85,
        getCardFileRequest: getHierarchyLevelWithFastFilter, 
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
        order: "CreateDate-",
        customTools: html`
        ${fastFilters.render()}
        <div class="search-tools">                
            <${SearchField}
                value=${searchValue}
                onInput=${handleSearchInput}
                onChange=${handleSearchChange}
                onClear=${handleSearchClear}
                placeholder=${"Наименование, клиент, торговая точка"}
                showSearchButton=${false}
            />
        </div>
    `,
    class: "opportunity-card-file",
    ...props,
    });

    cardFile.setBlank(BlankOpportunity);

    cardFile.urlPath = settings$c.urlPath;


    return cardFile;
};

CardOpportunity.settings = settings$c;

//import { Message } from "Core/index.js";
//import { createOrUpdateRecord, getRecord } from "Core/api/index.js";
// import { getUserId } from "Core/utils/index";

const BlankStorageArea = (props, docid) => {
    let blankName = "Зона хранения:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-storagearea",
        [HELP_KEYS.PROJECT]: 3302,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 170,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);
    blank.addItem(row1);
    
    return blank;
};

const settings$b = {
    targetClass: "C4C.Справочники.ЗонаХранения",
    rootName: "Зона хранения",
    urlPath: "StorageArea",
    __projectId__: 3302,
};

const CardStorageArea = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$b,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankStorageArea);

    cardFile.urlPath = settings$b.urlPath;


    return cardFile;
};

CardStorageArea.settings = settings$b;

const Report01 = (props) => {

    let loader = Loader();

    let blank = Blank({ data: "", title: "" });

    let датаПо = blank.createField({
        title: "Дата по",
        key: "датаПо",
        type: "date",
        width: 125,
    });

    let distrib = blank.createField({
        title: "Площадка партнера",
        key: "ПлощадкаПартнера",
        reference: CardAccount,
        width: 200,
    });

    let serviceTerritory = blank.createField({
        title: "Сервисная территория",
        key: "СервиснаяТерритория",
        reference: CardServiceTerritory,
        width: 200,
    });

    let model = blank.createField({
        title: "Модель",
        key: "Модель",
        reference: CardEquipmentModel,
        width: 160,
    });

    let storageArea = blank.createField({
        title: "Зона хранения",
        key: "ЗонаХранения",
        reference: CardStorageArea,
        width: 160,
    });

    датаПо.setValue(getCurrentDateTurbo());

    function refreshReport() {
        if (датаПо.getValue() == null) return;     
        
        loader.show();
        GetReport01({ 
            doe: датаПо.getValue(),
            model: model.getValue(),    
            distrib: distrib.getValue(),
            st: serviceTerritory.getValue(),
            storagearea: storageArea.getValue(),          
        })
            .then((result) => {
                //console.log(result);
                repData(result.data ?? []);
            })
            .catch((error) => {
                console.log(error);
            })
            .finally(() => loader.hide());
    }


    const repData = o([]);

    let refreshButton = html`<${Button} style="margin-right: 10px"
        >Обновить<//
    >`;

    refreshButton.addEventListener("click", () => {
        if (датаПо.getValue() == null)
            return Message$1("Отсутствует дата", "error");

        refreshReport();
    });

    const toolBar = html`<div class="toolbar">
        <div class="filters">
            <h3>01 - Парк оборудования по площадкам</h3>
            ${датаПо}${distrib}${serviceTerritory}${model}${storageArea}
        </div>
        <div class="report-buttons"><${HelpLink} projectId=${3459}/>${refreshButton}</div>
    </div>`;

    const reportBody = html`<div class="report01">
        ${toolBar}
        <div class="scrollable">
            ${map(repData, (data) => ReportViewContaiter$7({ ...props, data }))}
        </div>
    </div>`;
    //console.log(reportBody);
    return reportBody;
};

const ReportViewContaiter$7 = (props) => {
    const repTable = ReportTable$7(props);
    const view = html`<div class="report-view-container">${repTable}</div> `;

    return view;
};

const ReportTable$7 = ({ data, selection, onMachineSelect }) => {
    if (!data) return;
    
    let column_totalRep = [
        {
            id: "Модель",
            text: "Модель",
            order: "Модель",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 200,
        },
    ];

    const columnsRep = data.Columns[0].body;

    columnsRep.forEach((element) => {
        column_totalRep.push({
            id: element.SplitValue,
            text: element.DisplayValue,
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: right;",
            fixWidth: 200,
        });
    });    

    if (selection)
    column_totalRep.push({
        id: "Кнопка",
        text: "",
        order: "Оборудование",
        style: "text-align: center; width: 100%; justify-content: center;",
        styleCell: "text-align: center;",
        fixWidth: 77,
        changeValue: (...params) => {
            const [, rowData] = params;
            const button = html`<${Button}>Выбрать<//>`;
            button.addEventListener("click", () => {
                onMachineSelect?.({
                    equipment: {
                        docid: rowData.Оборудование_DocId,
                        Name: rowData.Оборудование,
                    },
                });
            });
            return button;
        },
    });

    const tableTotalRep = Table({
        column_props: column_totalRep,
        class: "table-total",
    });

    data.Columns.map(({ body }) => body).forEach((columns, rowIndex) => {
        columns.forEach((column) => {
            //console.log(column)
            data.Rows[rowIndex][column.SplitValue] = column.Volume;
        });
    });

    tableTotalRep.createRows(data.Rows);

    const view = html`<div>${tableTotalRep}</div> `;

    return view;
};

const Report304 = (props) => {
    const { selection = false, distrib } = props;

    let loader = Loader();

    let blank = Blank({ data: "", title: "" });

    let датаПо = blank.createField({
        title: "Дата по",
        key: "датаПо",
        type: "date",
        width: 125,
    });

    датаПо.setValue(getCurrentDateTurbo());

    function refreshReport() {
        if (датаПо.getValue() == null) return;     
        
        // let locFilter=[];        
        // if (filter=="")
        // {
        //     if (distrib.getValue().docid) 
        //         locFilter.push( "ПлощадкаПартнера is {C4C.Справочники.Account:"+distrib.getValue().docid+"}");
        //     if (serviceTerritory.getValue().docid)
        //         locFilter.push( "СервиснаяТерритория is {C4C.Справочники.Account:"+serviceTerritory.getValue().docid+"}");
        //     if (model.getValue().docid)
        //         locFilter.push( "Оборудование.МодельОборудования is {C4C.Справочники.МодельОборудования:"+model.getValue().docid+"}");
        //     if (storageArea.getValue().docid)
        //         locFilter.push( "ЗонаХранения = {C4C.Справочники.ЗонаХранения:"+storageArea.getValue().docid+"}");
        //     locFilter=locFilter.join(" and ");
        // }else
        //     locFilter = filter;

        loader.show();
        GetReport304({ 
            doe: датаПо.getValue(),    
            distrib: distrib,          
        })
            .then((result) => {
                repData(result.data ?? []);
            })
            .catch((error) => {
                console.log(error);
            })
            .finally(() => loader.hide());
    }


    const repData = o([]);

    let refreshButton = html`<${Button} style="margin-right: 10px"
        >Обновить<//
    >`;

    refreshButton.addEventListener("click", () => {
        if (датаПо.getValue() == null)
            return Message$1("Отсутствует дата", "error");

        refreshReport();
    });

    const toolBar = html`<div class="toolbar">
        <div class="filters">
            <h3>304 - Выбор оборудования</h3>
            ${датаПо}
        </div>
        <div class="report-buttons"><${HelpLink} projectId=${3459}/>${refreshButton}</div>
    </div>`;

    const reportBody = html`<div class="report304">
        ${toolBar}
        <div class="scrollable">
            ${map(repData, (data) => ReportViewContaiter$6({ ...props, data }))}
        </div>
    </div>`;
    
    refreshReport();

    return reportBody;
};

const ReportViewContaiter$6 = (props) => {
    const repTable = ReportTable$6(props);
    const view = html`<div class="report-view-container">${repTable}</div> `;

    return view;
};

const ReportTable$6 = ({ data, selection, onMachineSelect }) => {
    if (!data) return;
    
    let column_totalRep = [
        {
            id: "Модель",
            text: "Модель",
            order: "Модель",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 300,
        },
        {
            id: "Оборудование",
            text: "Оборудование",
            order: "Оборудование",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 200,
        },
        {
            id: "Оборудование_DocId",
            text: "Оборудование_DocId",
            order: "Оборудование_DocId",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 200,
            isHidden: true,
        },
    ];

    const columnsRep = data.Columns[0].body;

    columnsRep.forEach((element) => {
        column_totalRep.push({
            id: element.SplitValue,
            text: element.DisplayValue,
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: right;",
            fixWidth: 200,
        });
    });    

    column_totalRep.push({
        id: "Кнопка",
        text: "",
        order: "Оборудование",
        style: "text-align: center; width: 100%; justify-content: center;",
        styleCell: "text-align: center;",
        fixWidth: 77,
        changeValue: (...params) => {
            const [, rowData] = params;
            const button = html`<${Button}>Выбрать<//>`;
            button.addEventListener("click", () => {
                onMachineSelect?.({
                    equipment: {
                        docid: rowData.Оборудование_DocId,
                        Name: rowData.Оборудование,
                    },
                });
            });
            return button;
        },
    });

    const tableTotalRep = Table({
        column_props: column_totalRep,
        class: "table-total",
    });

    data.Columns.map(({ body }) => body).forEach((columns, rowIndex) => {
        columns.forEach((column) => {
            //console.log(column)
            data.Rows[rowIndex][column.SplitValue] = column.Volume;
        });
    });

    tableTotalRep.createRows(data.Rows);

    const view = html`<div>${tableTotalRep}</div> `;

    return view;
};

const BlankWorkOrder = (props, docid) => {
    let blankName = "Наряд:";
    const modal = Modal();
    const { cardFile } = props;
    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-workorder",
        [HELP_KEYS.PROJECT]: 3406,
    });

    // if (docid != null) {
        getEnabledActionsForWorkOrder(docid).then((res) => {
            const buttons = res.data.elements.map((element) => {
                const button = html`<div class="col-auto">
                    ${Button({ text: element.Name, title: element.Desc })}
                </div>`;
                button.addEventListener("click", () => {
                    checkBeforeAction(docid, element.Name);
                });

                return button;
            });

            buttonsActions(buttons);
        });
    // }

    const buttonsActions = o([]);

    async function checkBeforeAction(docid, commandName) {
        if (commandName == "Отклонить") {
            let blTitle;
            let btnText;

            if (commandName == "Отклонить") {
                blTitle = "Укажите пожалуйста причину отклонения";
                btnText = "Отклонить";
            }
            let requestCommentBlank = BlankRequestComment({
                rejectFieldWidth: 700,
                rejectFieldHeight: 200,
                command: commandName,
                docid: docid,
                blankTitle: blTitle,
                rejectButtonText: btnText,
            });

            requestCommentBlank.rejectButtonAction = async (_) => {
                if (requestCommentBlank.getData() == undefined) {
                    return;
                }

                await createOrUpdateRecord(
                    "C4C.Документы.Наряд",
                    blank.getData()
                ).then((result) => {
                    docid =  result.data?.docid;
                    executeActionForWorkOrder(
                        docid,
                        commandName,
                        requestCommentBlank.getData()
                    ).then(async (res) => {
                        if (res.isOk) {
                            modal.hide();
                            blank.refreshData?.(docid);
                        }
                    });
                });
            };

            requestCommentBlank.cancelButtonAction = () => modal.hide();
            modal.setContent(requestCommentBlank);
            modal.show();
            return;
        } else {
            if (commandName == "Завершить") {
                if (reasonForMovement.getValue().docid==null)
                    return Message$1("Не указана причина движения","error");
                const tabledata = TablePositons.getData();
                // const models = tabledata.filter((m) => m.Модель?.docid);
                // if (tabledata.length !== models.length) {
                //     return Message(
                //         "Не все модели в таблице заполнены",
                //         "error"
                //     );
                // }
                const equipment = tabledata.filter(
                    (m) => m.Оборудование?.docid
                );
                if (tabledata.length !== equipment.length) {
                    return Message$1(
                        "Не все оборудование в таблице заполнено",
                        "error"
                    );
                }
                const places = tabledata.filter((m) => m.МестоУстановки);
                if (tabledata.length !== places.length) {
                    return Message$1(
                        "Не все места установки в таблице заполнены",
                        "error"
                    );
                }
            }
            await createOrUpdateRecord("C4C.Документы.Наряд", blank.getData()).then(
                (result) => {
                    docid =  result.data?.docid;
                    executeActionForWorkOrder(docid, commandName).then(
                        async (res) => {
                            if (res.isOk) {
                                modal.hide();
                                blank.refreshData?.(docid);
                            }
                        }
                    );
                }
            );
        }
    }

    const buttonsContainer = html`
        <div class="buttons-container">${buttonsActions}</div>
    `;

    let Status = blank.createField({
        title: "Статус",
        key: "Status",
        reference: CardStatus,
        width: 158,
        disabled: false,
    });
    const isROByStatus = computed(() => Status.getValue()?.docid === 12);

    let Номер = blank.createField({
        title: "", //Номер
        key: "docid",
        type: "string",
        width: 70,
        disabled: true,
    });
    let OperDate = blank.createField({
        title: "Дата наряда",
        key: "OperDate",
        type: "date",
        width: 120,
        disabled: true,
    });

    let Responsible = blank.createField({
        title: "Ответственный",
        key: "Ответственный",
        reference: CardFileEmployee,
        width: 140,
        disabled: isROByStatus,
    });    

    let distrib = blank.createField({
        title: "Площадка партнера",
        key: "ПлощадкаПартнера",
        reference: CardAccount,
        isHierarchycal: false,
        initTree: false,
        width: 200,
        disabled: true,
        // constFilter: ()=>{
        //     if (serviceTerritory.getValue().docid!=null)
        //         return "СервиснаяТерритория = {C4C.Справочники.Account:"+serviceTerritory.getValue().docid+"} and ТипКлиента.Name = 'Площадка партнера'";            
        //     return "ТипКлиента.Name = 'Площадка партнера'";
        // },
        // onChange: async (params)=>{
        //     if (!params.value?.docid || serviceTerritory.getValue().docid!=null)
        //         return;
        //     const result = await getRecord(
        //         "C4C.Справочники.Account",
        //         params.value.docid);
        //     if (!(result instanceof Error)) {
        //         if (result.СервиснаяТерритория.docid)
        //             serviceTerritory.setValue(result.СервиснаяТерритория);            
        //     }
        // }
    });

    let serviceTerritory = blank.createField({
        title: "Сервисная территория",
        key: "СервиснаяТерритория",
        reference: CardServiceTerritory,
        isHierarchycal: false,
        initTree: false,
        width: 407,
        disabled: isROByStatus,
        // onChange: async (params)=>{            
        //     if (!params.value?.docid)
        //         return;
        //     distrib.setValue(null);
        //     const st = params.value.docid;
        //     const result = await getHierarchyLevel({
        //         targetClass: "C4C.Справочники.Account",
        //         filter: "СервиснаяТерритория = {C4C.Справочники.Account:"+st+"} and ТипКлиента.Name = 'Площадка партнера'",
        //         isHierarchycal: false,
        //     });            
        //     if (!(result instanceof Error)) {
        //         if (Object.keys(result).length==1)
        //             if (!distrib.getValue().docid)
        //                 distrib.setValue(result[0]);            
        //     }
        // }
    });

    let Account = blank.createField({
        title: "Клиент",
        key: "Клиент",
        reference: CardAccount,
        isHierarchycal: false,
        initTree: false,
        constFilter: "ТипКлиента.Name = 'Клиент'",
        width: 200,
        disabled: true,
    });

    let Initiator = blank.createField({
        title: "Инициатор",
        key: "Инициатор",
        reference: CardFileEmployee,
        width: 200,
        disabled: isROByStatus,
    });
    let baseDocument = blank.createField({
        title: "Док. Основание",
        key: "ДокументОснование",
        reference: CardOpportunity,
        width: 200,
        disabled: true,
    });
    let SRType = blank.createField({
        title: "Тип",
        key: "ТипСЗ",
        reference: CardServiceRequestType,
        width: 167,
        disabled: true,//docid,                     
        constFilter: "Name = 'Установка' or Name = 'Снятие'",
        // onChange: ({value}) => {
        //     const name = value?.Name;
        //     ["Кнопка"].forEach(key => {
        //         let hiddenColumn = TablePositons.getHiddenColumnByKey(key);
        //         if (!hiddenColumn) return;
        //         TablePositons.showColumn(hiddenColumn);
        //     })
        //     if ( name == "Снятие"){
        //         ["Кнопка"].forEach(key => {
        //             let hiddenColumn = TablePositons.getHiddenColumnByKey(key);
        //             if (hiddenColumn) return;
        //             console.log(TablePositons);
        //             const column = TablePositons.getColumnByKey(key);
        //             TablePositons.hideColumn(column);
        //         })
        //     }         
        // }
    });

    let datePlan = blank.createField({
        title: "Плановая дата",
        key: "ДатаПлан",
        type: "date",
        width: 125,
        disabled: isROByStatus,
    });
    let dateFact = blank.createField({
        title: "Дата завершения",
        key: "ДатаФакт",
        type: "date",
        width: 125,
        disabled: true,
    });
    let actDate = blank.createField({
        title: "Дата акта",
        key: "ДатаАкта",
        type: "date",
        width: 125,
        disabled: isROByStatus,
    });
    let TradePoint = blank.createField({
        title: "Точка",
        key: "Точка",
        reference: CardAccount,
        isHierarchycal: false,
        initTree: false,
        searchKeys: ["Name", "ЮрНаименование"],
        constFilter: ()=>{
            let filter = [];
            filter.push("ТипКлиента.docid = 2");
            const locST = serviceTerritory.getValue().docid;
            if (locST)
                filter.push("СервиснаяТерритория = {C4C.Справочники.Account:"+locST+"}");                    
            return filter.join(" and ");    
        },  
        width: 407,
        disabled: isROByStatus,
        // onChange: (...props)=>{
        //     // if ((!Account.getValue().docid)||(!distrib.getValue().docid))
        //     //     getRecord("C4C.Справочники.Account", +(props[0].value.docid)).then((result) => {
        //     //         if (!Account.getValue().docid) Account.setValue(result.Контрагент);
        //     //         if (!serviceTerritory.getValue().docid) serviceTerritory.setValue(result.СервиснаяТерритория);
        //     //     });
        //     getRecord("C4C.Справочники.Account", +(props[0].value.docid)).then((result) => {
        //         if (result.Контрагент.docid) Account.setValue(result.Контрагент);
        //         if (result.СервиснаяТерритория.docid) serviceTerritory.setValue(result.СервиснаяТерритория);
        //     });
        //},

    });
    const disableInstallLoc = computed(() => (TradePoint.getValue().docid==undefined || Status.getValue()?.docid === 12));
    
    let InstallationLocation = blank.createField({
        title: "Место установки",
        key: "МестоУстановки",
        reference: CardInstallationLocation,
        isHierarchycal: false,
        initTree: false,
        constFilter: () => {
            let filter = [];
            const tradePointValue = TradePoint.getValue();
            if (tradePointValue?.docid) {
                filter.push(`ТорговаяТочка.docid = ${tradePointValue.docid}`);
            }
            return filter.join(" and ");
        },
        width: 200,
        disable: isROByStatus,
    });
    let EquipmentModel = blank.createField({
        title: "Модель",
        key: "Модель",
        reference: CardEquipmentModel,
        width: 200,
        disabled: true,
    });

    let syncSAPStatus = blank.createField({
        title: "Статус синхронизации SAP",
        key: "СтатусСинхронизацииSAP",
        reference: CardStatus,
        width: 200,//313
        disabled: true,
    });

    let srTypeName = blank.createField({
        title: "",
        key: "ТипСЗ.Name",
        type: "string",
        width: 180,
        disabled: true,
    });
    let reasonForMovement = blank.createField({
        title: "Причина движения",
        key: "ПричинаДвижения",
        reference: CardReasonForMovement,
        constFilter: ()=>
        {
            if (srTypeName.getValue()!="")
                return "ПрименимДля = '"+srTypeName.getValue()+"'";
            else
                return "";
        },
        width: 200,
        disabled: isROByStatus,
    });


    const selectModel = html`<${Button}>Выбрать из доступных<//>`;

    selectModel.addEventListener("click", () => {
        if (isROByStatus()) 
        return;
        let report01Blank = Report01({
            selection: true,
            onMachineSelect: ({ equipment }) => {
                Equipment.setValue(equipment);
                modal.hide();
            },
        });
        modal.setContent(report01Blank);
        modal.show();
    });

    //Подтаблица
    const positionsProps = [
        {
            id: "МестоУстановки",
            text: "Место",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
            reference: CardInstallationLocation,
            isHierarchycal: false,
            initTree: false,
            constFilter: () => {
                let filter = [];
                const tradePointValue = TradePoint.getValue();
                if (tradePointValue?.docid) {
                    filter.push(
                        `ТорговаяТочка.docid = ${tradePointValue.docid}`
                    );
                }
                return filter.join(" and ");
            },
            disabled: disableInstallLoc
        },
        {
            id: "Модель",
            text: "Модель",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 206,
            reference: CardEquipmentModel,
            disabled: true,
        },
        {
            id: "Оборудование",
            text: "Номер производителя",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center; display: flex; align-items: center;",
            fixWidth: 208,
            changeValue: (value, ...rest) => {
                const [,,{cells, columns_hash}] = rest;
                const  handleChange = (ev) => {
                    // ev - event; беру его значение из таргета 
                    ev.target.value;
                    
                    if (srTypeName.getValue() == "Установка") {
                        findEquipmentByNumber( SRType.getValue() , serviceTerritory.getValue() , TradePoint.getValue() , ev.target.value).then(async (res) => {
                            if (res.CountRecords == 1) {
                                serviceTerritory.setValue(res.ST);
                                distrib.setValue(res.Площадка);
                                cells[columns_hash['Модель']]?.value.setValue(res.Модель);
                                cells[columns_hash['Оборудование']]?.value.setValue(res.Оборудование);
                                cells[columns_hash['счетСписания']]?.value.setValue(res.счетСписания);
                            }
    
                            if (res.CountRecords > 1) {
                                modal.setContent(ReportSelectEquipment$1({data: res.data, onSelect: ({data}) => {
                                    serviceTerritory.setValue({docid: data.СервиснаяТерритория_ID , Name: data.СервиснаяТерритория});
                                    distrib.setValue({docid: data.Площадка_ID , Name: data.Площадка});
                                    cells[columns_hash['Модель']]?.value.setValue({docid: data.Модель_ID , Name: data.Модель});
                                    cells[columns_hash['Оборудование']]?.value.setValue({docid: data.Оборудование_ID , Name: data.Оборудование});
                                    cells[columns_hash['счетСписания']]?.value.setValue(data.счетСписания);
                                    
                                    modal.hide();
                                }}));
                                modal.show();
                            }
        
                            if (res.CountRecords == 0) {
                                ev.target.blur();
                                return Message$1("Не найдено ни одного совпадения по серийному номеру или нет свободного остатка","error"); 
                            }
        
                        });
                    }

                    if (srTypeName.getValue() == "Снятие") {
                        findEquipmentByNumber( SRType.getValue() , serviceTerritory.getValue() , TradePoint.getValue() , ev.target.value).then(async (res) => {
                            if (res.CountRecords == 1) {
                                serviceTerritory.setValue(res.ST);
                                distrib.setValue(res.Площадка);
                                Account.setValue(res.Клиент);
                                TradePoint.setValue(res.Точка);
                                cells[columns_hash['МестоУстановки']]?.value.setValue(res.Место);
                                cells[columns_hash['Модель']]?.value.setValue(res.Модель);
                                cells[columns_hash['Оборудование']]?.value.setValue(res.Оборудование);
                            }
    
                            if (res.CountRecords > 1) {
                                modal.setContent(ReportSelectInstalledEquipment({data: res.data, onSelect: ({data}) => {
                                     serviceTerritory.setValue({docid: data.СервиснаяТерритория_ID , Name: data.СервиснаяТерритория});
                                     distrib.setValue({docid: data.Площадка_ID , Name: data.Площадка});
                                     if (data.Клиент_ID != 0 ) {
                                        Account.setValue({docid: data.Клиент_ID , Name: data.Клиент});
                                     }
                                     TradePoint.setValue({docid: data.Точка_ID , Name: data.Точка});
                                     cells[columns_hash['МестоУстановки']]?.value.setValue({docid: data.Место_ID , Name: data.Место});
                                     cells[columns_hash['Модель']]?.value.setValue({docid: data.Модель_ID , Name: data.Модель});
                                     cells[columns_hash['Оборудование']]?.value.setValue({docid: data.Оборудование_ID , Name: data.Оборудование});
                                     modal.hide();
                                }}));
                                modal.show();
                            }
        
                            if (res.CountRecords == 0) {
                                ev.target.blur();
                                return Message$1("Не найдено ни одного совпадения по серийному номеру или нет свободного остатка","error"); 
                            }
        
                        });
                    }
                    // выход из ячейки
                    ev.target.blur();
                    //console.log(ev.target.value);
                };

                const inputSN = html`<input value=${value?.Name} onchange=${handleChange}/>`;

                return inputSN;
            }
        },
        {
            id: "GUID",
            text: "GUID",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
            isHidden: true, 
        },

        {
            id: "счетСписания",
            text: "счетСписания",
            order: "счетСписания",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 200,
            isHidden: true,
        },

    ];

    const TablePositons = blank.createTable({
        column_props: positionsProps,
        width: 100,
        key: "Позиции",
        class: "positions-table",
        disableContextMenu: isROByStatus
    });

    let new_row_table_positions = [
        {
            Точка: "",
            Модель: "",
            Оборудование: "",
            Кнопка: "",
        },
    ];

    let addRowPositions = html`<button
        class="add-button"
        type="button"
    ></button>`;
    addRowPositions.addEventListener("click", (e) => {
        if (isROByStatus()) 
        return;
        e.preventDefault();
        //if (Account.getValue().docid) {
            TablePositons.createRows(new_row_table_positions);
        //}
    });

    //Загрузка файлов
    Field({
        type: "files-upload",
        key: "ФотоМашины",
        value: [],
        onSaveFile: ({ name, data }) => {
            const targetClass = "C4C.Документы.Наряд";
            const fileType = 1;
            const additional = { targetClass, docid, fileType };
            return uploadFile({
                name,
                data,
                additional,
            });
        },
        onDeleteFile: deleteFile,
        title: "Фото машины на месте установки",
        acceptFiles: "image/*",
        FileItemComponent: ImagePreviewItem,
        // onChange: () => {
        //     updateRecord();
        // },
        multiple: false,
        uploadButton: {
            content: Icon({ name: "floppy-disk" }),
            class: "transparent",
        },
        addButton: {
            content: Icon({ name: "plus" }),
            class: "transparent",
        },
    });

    Field({
        type: "files-upload",
        key: "ФотоСерийногоНомера",
        value: [],
        onSaveFile: ({ name, data }) => {
            const targetClass = "C4C.Документы.Наряд";
            const fileType = 2;
            const additional = { targetClass, docid, fileType };
            return uploadFile({
                name,
                data,
                additional,
            });
        },
        onDeleteFile: deleteFile,
        title: "Фото серийного номера",
        acceptFiles: "image/*",
        FileItemComponent: ImagePreviewItem,
        // onChange: () => {
        //     updateRecord();
        // },
        multiple: false,
        uploadButton: {
            content: Icon({ name: "floppy-disk" }),
            class: "transparent",
        },
        addButton: {
            content: Icon({ name: "plus" }),
            class: "transparent",
        },
    });

    const actPhotoField = Field({
        type: "files-upload",
        //key: "ФотоАктаПриема",
        //value: [],
              
        onSaveFile: async ({ name, data }) => {
            await createOrUpdateRecord(
                "C4C.Документы.Наряд",
                blank.getData()
            ).then((res)=>{
                if (!docid) 
                    docid = res.data.docid;
                blank.refreshData(docid);
                cardFile?.updateTable();
            });
            const targetClass = "C4C.Документы.Наряд";
            const fileType = 3;
            const additional = { targetClass, docid, fileType };
            return uploadFile({
                name,
                data,
                additional,
            });
        },
        //readOnly: isROByStatus,
        onDeleteFile: deleteFile,
        confirmUpload: false,
        title: "Акт приёма оборудования",
        acceptFiles: "image/*",
        //FileItemComponent: ImagePreviewItem,
        // onChange: () => {
        //     updateRecord();
        // },
        multiple: true,//false
        uploadButton: {
            content: Icon({ name: "floppy-disk" }),
            class: "transparent",
        },
        // addButton: {
        //     content: Icon({ name: "plus" }),
        //     class: "transparent",
        // },
    });

    // if (docid != null && docid > 0) {
    getFilesList({
        docid,
        targetClass: "C4C.Документы.Наряд",
    }).then((res) => {
        if (!res.isOk) return;
            // machinePhotoField.setFiles(res.data.data);
            // const machinePhotos = res.data.data?.filter(file=>file.fileType_docid === 1);
            // const serialNumberPhotos = res.data.data?.filter(file => file.fileType_docid === 2);
        const actPhotos = res.data.data?.filter(
            (file) => file.fileType_docid === 3
        );

            // if (machinePhotos?.length > 0) {
            //     machinePhotoField.setValue([machinePhotos[0]]);
            // }
            // if (serialNumberPhotos?.length > 0) {
            //     numberPhotoField.setValue([serialNumberPhotos[0]]);
            // }
        if (actPhotos?.length > 0) {
            actPhotoField.setValue(actPhotos);
        }
    });
    // }   

    const renderFilesUpload = () => {
        // if (docid == null)
        //     return null;        
        return html`<div class="files-upload-field">${actPhotoField}</div>`;
    };

    const dependentDocs = o([]);
    const tree = Tree({
        elements: dependentDocs,
        activeItem: docid,
        onCreateChild: createChild,
        onBindToParent: bindToParent,
        onUnbindToParent: unbindToParent,
        hideButtons: (getCurrentRole()!=1),
    });

    const commentsActivity = CommentsActivity({
        targetClass: "C4C.Документы.Наряд",
        docid,
        comments: props?.Comments,
    });

    //Кнопка выбрать места установка
    const selectLocations = html`<${Button}>Выбрать оборудование<//>`;

    selectLocations.addEventListener("click", () => {
        if (isROByStatus()) 
        return;
        if (TradePoint.getValue().docid==undefined)
            return Message$1("Не выбрана точка","error");
        let report302Blank = Report302({
            selection: true,
            tradepoint: TradePoint.getValue(),
            onAccept: ({ data }) => {
                TablePositons.clearRows();
                TablePositons.createRows(data);
                serviceTerritory.setValue(data[0]?.СервиснаяТерритория);
                distrib.setValue(data[0]?.Площадка);
                modal.hide();
            },
        });
        modal.setContent(report302Blank);
        modal.show();
    });

    //Кнопка добавить новую точку
    const addPointButton = html`<${Button}>Добавить новую точку<//>`;
    addPointButton.addEventListener("click", async () => {
        const addPointBlank = BlankAddTradePoint(
            {
                ТипКлиента: 2,               
                cancelButtonAction: ()=>{
                    modal.hide();
                },      
                inModal:(resRecord)=>{
                    TradePoint.setValue(resRecord);
                    modal.hide();
                }                     
            });              
        modal.setContent(addPointBlank);
        modal.show();
    });

    //Кнопка сохранить
    const saveButton = html`<${Button}>Сохранить<//>`;
    saveButton.addEventListener("click", async () => {
        const result = await createOrUpdateRecord(
            "C4C.Документы.Наряд",
            blank.getData()
        );
        if (!result.isOk) {
            console.error(result.data ?? result.error);
            return;
        }
        blank.refreshData(result.data.docid);
        cardFile?.updateTable();
    });

    blank.addHeaderRightItem(saveButton);


    let headerRow = blank.createRow();
    headerRow.addItems([Номер, OperDate, SRType, Status, Responsible]);

    blank.addHeaderLeftItem(headerRow);

    let mainInfoItem = mainInfo$2({
        buttonsContainer,
        serviceTerritory,
        TablePositons,
        addRowPositions,
        srTypeName,
        distrib,
        Account,
        Initiator,
        baseDocument,
        datePlan,
        dateFact,
        actDate,
        selectModel,
        TradePoint,
        addPointButton,
        reasonForMovement,
        selectLocations,
        syncSAPStatus,
        InstallationLocation,
        EquipmentModel,
        fileElement: renderFilesUpload,
        commentsActivity,
        tree,
    });

    blank.addItem(mainInfoItem);

    observe(blank);
    
    blank.addEventListener("connected", async () => {
        // Бланк при считывании. По сути в пропсах уже лежит record
        docid != null &&
            docid > 0 &&
            getDependenceDocument({
                targetClass: "C4C.Документы.Наряд",
                docid,
            }).then((result) => {
                if (!result.isOk) return console.error(result.error);
                dependentDocs(result.data ? [result.data] : []);
            });

        if(!docid)
        {
            const removeButton = html`<${Button}>Снятие<//>`;
            removeButton.addEventListener("click", async () => {
                const resType = await getRecord$1("C4C.Справочники.ТипСервисногоЗапроса",2);
                if (resType)
                    SRType.setValue(resType);
                modal.hide();            
            });
            const installButton = html`<${Button}>Установка<//>`;
            installButton.addEventListener("click", async () => {
                const resType = await getRecord$1("C4C.Справочники.ТипСервисногоЗапроса",1);
                if (resType)
                    SRType.setValue(resType);
                modal.hide();            
            });
            modal.setContent(html`
                <div class="wo-typeselect">
                    <h2>Выберите тип:</h2>
                    ${installButton}${removeButton}
                </div>            
                `);
            modal.show();
            }    
        });

    blank.applyButtonAction = () => {
        if(TradePoint.getValue().docid == undefined)
            return Message$1("Не указана точка","error");        
        if(SRType.getValue().docid == undefined && !docid)        
            return Message$1("Не указан тип наряда","error");        

        createOrUpdateRecord(
            "C4C.Документы.Наряд",
            blank.getData()
        ).then(async (res) => {
            if (res.isOk) {
                cardFile?.hideBlank();
                cardFile?.updateTable();                
            }
        });            
    };

    blank.style.maxWidth = "min-content";
    blank.style.height = 90 + "vh";
    blank.style.width = 76 + "vw";


    if (!docid) {
        // Значения при создании 
        getRecord$1("BaseInt.Status", +6).then((result) => {
            Status.setValue(result);
        });

        getRecord$1("BaseInt.Status", +19).then((result) => {
            syncSAPStatus.setValue(result);
        });

        OperDate.setValue(getCurrentDateTurbo());

        getRecord$1("BaseInt.Справочники.Persona", +getUserId()).then(
            (result) => {
                Initiator.setValue(result);
                Responsible.setValue(result);
            }
        );

        TablePositons.createRows(new_row_table_positions);
    }


    return blank;

    function createChild() {
        if (!docid) return;
        const initialData = {
            //[projectField.getKey()]: projectField.getData(),
            //[subProjectField.getKey()]: subProjectField.getData(),
            //[parentTaskField.getKey()]: {
            //    docid,
            //    targetClass: settings.targetClass,
            //},
        };
        const ChildBlank = (data) => {
            Object.assign(data, { onActivityCreated });
            const blank = BlankActivity();
            blank.cancelButtonAction = () => {
                modal.hide();
                modal.setContent(null);
            };
            blank.refreshData = async () => {};
            return blank;
        };
        const childBlank = ChildBlank(initialData);
        modal.setContent(childBlank);
        modal.show();
        function onActivityCreated() {
            modal.hide();
            modal.setContent(null);
            //blank.refreshData?.(docid);
        }
    }
    function bindToParent() {}
    function unbindToParent() {}
};


const mainInfo$2 = (fields) => {
    function renderFields() {
        if (fields.srTypeName.getValue() == "Снятие") {
            return html`
                <div class="blank-row">${fields.TradePoint}${fields.selectLocations} </div>
                <div class="blank-row">
                    ${fields.TablePositons}${fields.addRowPositions}
                </div>
            `;
        }
        return html`
            <div class="blank-row">${fields.TradePoint}${fields.addPointButton}</div>
            <div class="blank-row">
                    ${fields.TablePositons}${fields.addRowPositions}
            </div>
        `;
    }
    return html`
        <div class="blank-basicInfo">
            <div class="blank-row">
                ${fields.serviceTerritory} ${fields.datePlan} ${fields.buttonsContainer}
            </div>
            <div class="blank-row">
                ${fields.Initiator} ${fields.baseDocument}${fields.actDate} ${fields.reasonForMovement}
            </div>
            <div class="blank-row">
                ${fields.distrib} ${fields.Account}${fields.dateFact} 
            </div>
            ${renderFields}
        </div>
        <div class="blank-row">${fields.fileElement}</div>
        <div class="blank-treecomments">
            ${fields.tree}${fields.commentsActivity}
        </div>
    `;
};


const ReportSelectEquipment$1 = ({data, onSelect}) => {

    let column_rep_select_equipment = [
        {
            id: "СервиснаяТерритория",
            text: "Сервисная территория",
            order: "СервиснаяТерритория",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 220,
        },
        {
            id: "Площадка",
            text: "Площадка",
            order: "Площадка",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 220,
        },
        {
            id: "Модель",
            text: "Модель",
            order: "Модель",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 220,
        },
        {
            id: "Оборудование",
            text: "Номер производителя",
            order: "Оборудование",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 200,
        },

        {
            id: "счетСписания",
            text: "счетСписания",
            order: "счетСписания",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 200,
            isHidden: false,
        },
        
        
        {
            id: "Кнопка",
            text: "",
            order: "Оборудование",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 77,
            changeValue: (...params) => {
                const [, rowData] = params;
                const button = html`<${Button}>Выбрать<//>`;
                button.addEventListener("click", () => {
                    onSelect?.({data: rowData});
                });
                return button;
            },
        }
    ];

    const tableSelectEquipment = Table({
        column_props: column_rep_select_equipment,
        class: "table-report",
    });

    tableSelectEquipment.createRows(data);

    return html`
    <div class="modal-inputnumber">                
        <h3>Найдено несколько номеров производителя:</h3>
        <div>${tableSelectEquipment}</div>
    </div>
    `;
}; 


const ReportSelectInstalledEquipment = ({data, onSelect}) => {
    // Показывает то что уже установлено
    let column_rep_select_equipment = [
        {
            id: "СервиснаяТерритория",
            text: "Сервисная территория",
            order: "СервиснаяТерритория",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 220,
        },
        {
            id: "Площадка",
            text: "Площадка",
            order: "Площадка",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 220,
        },

        {
            id: "Клиент",
            text: "Клиент",
            order: "Клиент",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 220,
        },

        {
            id: "Точка",
            text: "Точка",
            order: "Точка",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 220,
        },

        {
            id: "Место",
            text: "Место",
            order: "Место",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 220,
        },

        {
            id: "Модель",
            text: "Модель",
            order: "Модель",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 220,
        },
        {
            id: "Оборудование",
            text: "Номер производителя",
            order: "Оборудование",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 200,
        },
        {
            id: "Кнопка",
            text: "",
            order: "Оборудование",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 77,
            changeValue: (...params) => {
                const [, rowData] = params;
                const button = html`<${Button}>Выбрать<//>`;
                button.addEventListener("click", () => {
                    onSelect?.({data: rowData});
                });
                return button;
            },
        }
    ];

    const tableSelectEquipment = Table({
        column_props: column_rep_select_equipment,
        class: "table-report",
    });

    tableSelectEquipment.createRows(data);

    return html`
    <div class="modal-inputnumber">                
        <h3>Найдено несколько номеров производителя:</h3>
        <div class="scrollable">
            ${tableSelectEquipment}
        </div>
    </div>
    `;
};

const settings$a = {
    targetClass: "C4C.Документы.Наряд",
    rootName: "Наряд",
    urlPath: "WorkOrder",
    __projectId__: 3406,
};

const CardWorkOrder = (props) => {

    getUserId();
    const searchValue = o("");

    const fastFilters = new FastFilters({
        path: "Name",
        onSelect: handleFilterSelect,
        targetClass: settings$a.targetClass,
    });

    function handleFilterSelect() {
        cardFile.updateTable();
    }

    const getHierarchyLevelWithFastFilter = async (props, ...args) => {
        if (!("isHierarchycal" in props))
            return getHierarchyLevel(props, ...args);

        await fastFilters.load({ initialFilterIndex: 0 });
        const fastFilter = fastFilters.getCurrentFastFilter();
        if (fastFilter) {
            props.fastFilter = fastFilter;
        }
        return getHierarchyLevel(props, ...args);
    };

    let column_props = [
        
        {
            id: "docid",
            text: "№",
            order: "docid",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 80,
        },

        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 150,
        },
        {
            id: "Status",
            text: "Статус",
            order: "Status.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 120,

            callback: (data, rowData) => {
                const element = html`<span>${data}</span>`;
                const setColor = () => {
                    const tableCell = element.closest(".table-cell");
                    if (!tableCell) return;
                    tableCell.style.backgroundColor = rowData.StatusColor;
                };
                if (rowData.StatusColor) {
                    observe(element);
                    element.addEventListener("connected", setColor);
                    element.addEventListener("disconnected", () => {
                        element.removeEventListener("connected", setColor);
                        unobserve(element);
                    });
                }

                return element;
            },
        },

        {
            id: "ТипСЗ",
            text: "Тип наряда",
            order: "ТипСЗ.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 150,
        },

        {
            id: "ПричинаДвижения",
            text: "Причина движения",
            order: "ПричинаДвижения.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 150,
        },
        
        {
            id: "Клиент",
            text: "Клиент",
            order: "Владелец.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
        {
            id: "Точка",
            text: "Точка",
            order: "Точка.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },
        {
            id: "ДатаПлан",
            text: "Дата план",
            order: "ДатаПлан",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 120,
        },
        {
            id: "ДатаФакт",
            text: "Дата факт",
            order: "ДатаФакт",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 120,
        },
        {
            id: "ПлощадкаПартнера",
            text: "Площадка партнера",
            order: "ПлощадкаПартнера.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
        {
            id: "ДокументОснование",
            text: "Документ основание",
            order: "ДокументОснование.NumberDoc",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },

        {
            id: "Инициатор",
            text: "Инициатор",
            order: "Инициатор.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },

        {
            id: "СтатусСинхронизацииSAP",
            text: "Статус синхронизации SAP",
            order: "СтатусСинхронизацииSAP",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },

        {
            id: "СтатусПодтвержденияДокументов",
            text: "Статус подтверждения документов",
            order: "СтатусПодтвержденияДокументов",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
    ];

    const handleSearchChange = () => {
        const filter = ("Позиции.Exists(Match(Оборудование.ManufacturerNumber, '*"+searchValue()+"*')) or "+
                        "Match(Точка.Name,'*"+searchValue()+"*') or "+
                        "Match(Точка.Адрес,'*"+searchValue()+"*') or "+
                        "Match(Точка.ЮрНаименование,'*"+searchValue()+"*') or "+
                        "Match(Клиент.Name,'*"+searchValue()+"*')");

        if (searchValue()!="")
            cardFile.setIsHierarchycal(false);
        else
            cardFile.setIsHierarchycal(true);                        
        cardFile.setConstFilter(filter);
        cardFile.updateTable();
    };
    const handleSearchInput = (value) => searchValue(value);
    const handleSearchClear = () => {
        handleSearchInput("");
        handleSearchChange();
    };

    let cardFile = CardFile({
        ...settings$a,
        cardWidth: 85,
        getCardFileRequest: getHierarchyLevelWithFastFilter,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
        order: "CreateDate-",
        customTools: html`
            ${fastFilters.render()}
            <div class="search-tools">                
                <${SearchField}
                    value=${searchValue}
                    onInput=${handleSearchInput}
                    onChange=${handleSearchChange}
                    onClear=${handleSearchClear}
                    placeholder=${"Серийный номер, точка, адрес, клиент"}
                    showSearchButton=${false}
                />
            </div>
        `,
        class: "work-order-card-file",
        ...props,
    });

    cardFile.setBlank(BlankWorkOrder);

    cardFile.urlPath = settings$a.urlPath;

    return cardFile;
};

CardWorkOrder.settings = settings$a;

const BlankMovementType = (props, docid) => {
    let blankName = "Тип перемещения:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-movementtype",
        [HELP_KEYS.PROJECT]: 3398,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 220,
    });
    let description = blank.createField({
        title: "Описание",
        key: "Описание",
        type: "string",
        width: 550,
    });
 
    let row1 = blank.createRow();
    let row2 = blank.createRow();

    row1.addItems([name]);
    row2.addItems([description]);

    blank.addItem(row1);
    blank.addItem(row2);

    return blank;
};

const settings$9 = {
    targetClass: "C4C.Справочники.ТипПеремещения",
    rootName: "Тип перемещения",
    urlPath: "MovementType",
    __projectId__: 3398,
};

const CardMovementType = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },
        {
            id: "Описание",
            text: "Описание",
            order: "Описание",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 550,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$9,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankMovementType);

    cardFile.urlPath = settings$9.urlPath;


    return cardFile;
};

CardMovementType.settings = settings$9;

const BlankReceptionEquipment = (props, docid) => {
    let blankName = "Перемещение оборудования:";
    const { cardFile } = props;

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-receptionequipment",
        [HELP_KEYS.PROJECT]: 3458,
    });

    let documentId = blank.createField({
        title: "",
        key: "docid",
        type: "string",
        width: 40,
        disabled: true,
    });
    let movementType = blank.createField({
        title: "Тип перемещения",
        key: "ТипПеремещения",
        reference: CardMovementType,
        width: 340,
        onChange: ({ value }) => {
            const typeId = value?.docid;
                if (typeId == 1) {
                    getRecord$1("C4C.Справочники.Account", +77415).then((result) => {
                        Customer.setValue(result);
                    });
                
                    getRecord$1("C4C.Справочники.Account", +90963).then((result) => {
                        СервиснаяТерритория.setValue(result);
                    });
                } else {
                    Customer.setValue(null);
                }
        }

    });
           

    let Customer = blank.createField({
        title: "Площадка партнера",
        key: "ПлощадкаПартнера",
        reference: CardAccount,
        width: 200,
        disabled: () => {
            return movementType.getValue().docid == 1;
        },
        isHierarchycal: false,
        initTree: false,
        constFilter: "ТипКлиента.Name = 'Площадка партнера'",
    });

    let ПлощадкаОткуда = blank.createField({
        title: "Площадка откуда ",
        key: "ПлощадкаПартнераОткуда",
        reference: CardAccount,
        width: 200,
        disabled: () => {
            return movementType.getValue().docid == 1;
        },
        isHierarchycal: false,
        initTree: false,
        constFilter: "ТипКлиента.Name = 'Площадка партнера'",
    });

    let СервиснаяТерритория = blank.createField({
        title: "Сервисная территория",
        key: "СервиснаяТерритория",
        reference: CardServiceTerritory,
        width: 200,
        disabled: () => {
            return movementType.getValue().docid == 1;
        },
        isHierarchycal: false,
        initTree: false,
    });

    let СервиснаяТерриторияОткуда = blank.createField({
        title: "Сервисная территория откуда",
        key: "СервиснаяТерриторияОткуда",
        reference: CardServiceTerritory,
        width: 200,
        isHierarchycal: false,
        initTree: false,
    });


    let tradePoint = blank.createField({
        title: "Точка",
        key: "Точка",
        reference: CardAccount,
        isHierarchycal: false,
        initTree: false,
       // disabled: isROByStatus,
        constFilter: () => {
            let filter = [];
            // const accountValue = Account.getValue();
            // if (accountValue?.docid) {
            //     filter.push(`Контрагент.docid = ${accountValue.docid}`);
            // }
            filter.push(`ТипКлиента = {C4C.Справочники.ТипКлиента:2}`);
            return filter.join(" and ");
        },
        // onChange: (...props)=>{
        //     if ((!Account.getValue().docid)||(!distrib.getValue().docid))
        //         getRecord("C4C.Справочники.Account", +(props[0].value.docid)).then((result) => {
        //             if (!Account.getValue().docid) Account.setValue(result.Контрагент);
        //             if (!serviceTerritory.getValue().docid) serviceTerritory.setValue(result.СервиснаяТерритория);
        //         });
        // },
        width: 200,
    });

    const EquipmentField = ({value: reference, onChange,  ...rest}) => {
        const value = computed(() => reference()?.Name);

        const handleChange = ({value, key}) => {
            

             checkByManufectererNumberInExternalMovement( movementType  ,serviceTerritory.getValue() , areaFrom.getValue() , ev.target.value).then(async (res) => {
    //             if (res.CountRecords == 1) {

    //                 console.log(value);
    // //                 serviceTerritory.setValue(res.ST);
    // //                 distributor.setValue(res.Площадка);
    // //                 areaFrom.setValue(res.ЗонаХранения);
    // //    //             cells[columns_hash['Модель']]?.value.setValue(res.Модель);
    // //                 cells[columns_hash['Оборудование']]?.value.setValue(res.Оборудование);
    // //                 cells[columns_hash['счетСписания']]?.value.setValue(res.счетСписания);
    //             }
             });
            
            


            //
            onChange({key, value: {Name: value, docid: 100}});
        };
        return Field({...rest, value, onChange: handleChange, type: "text"})
    };

    let Equipment = blank.createComponent({
        key: "Оборудование",
        width: 200,
        Component: EquipmentField
    });

    // let Equipment = blank.createField({
    //     title: "Оборудование",
    //     key: "Оборудование",
    //     type: "string",
    //     width: 200,

    //     onChange:({value}) => {
            
    //         console.log(value);
            
    //     }

    // });

    let МестоУстановки = blank.createField({
        title: "Место Установки",
        key: "МестоУстановки",
        reference: CardInstallationLocation,
        width: 200,

        constFilter: () => {
            let filter = [];
            const tradePointValue = tradePoint.getValue();
            if (tradePointValue?.docid) {
                filter.push(
                    `ТорговаяТочка.docid = ${tradePointValue.docid}`
                );
            }
            return filter.join(" and ");
        },

    });
    // let Amount = blank.createField({
    //     title: "Количество",
    //     key: "Колво",
    //     type: "integer",
    //     width: 200,
    // });
    let OperDate = blank.createField({
        title: "Дата проведения",
        key: "OperDate",
        type: "date",
        width: 200,
    });

    if (!docid) {
        OperDate.setValue(getCurrentDateTurbo());
    }

    blank.applyButtonAction = () => {
        if (movementType.getValue().docid == undefined) {
            return Message$1("Не указан тип перемещения", "error");
        }
        createOrUpdateRecord(
            "C4C.Документы.ПеремещениеОборудования",
            blank.getData()
        ).then(async (res) => {
            if (res.isOk) {
                cardFile?.hideBlank();
                cardFile?.updateTable();
            }
        });
    };

    let headerRow = blank.createRow();
    headerRow.addItems([documentId]);
    blank.addHeaderLeftItem(headerRow);
 
    let row1 = blank.createRow();
    let row2 = blank.createRow();
    let row3from =  blank.createRow();
    let row4 = blank.createRow();

    


    row1.addItems([OperDate,movementType]);
    row2.addItems([Customer,СервиснаяТерритория , Equipment]);
    row3from.addItems([ПлощадкаОткуда, СервиснаяТерриторияОткуда, tradePoint]);
    row4.addItems([МестоУстановки]);

    blank.addItem(row1);
    blank.addItem(row2);
    blank.addItem(row3from);
    blank.addItem(row4);
    return blank;
};

const settings$8 = {
    targetClass: "C4C.Документы.ПеремещениеОборудования",
    rootName: "Перемещение оборудования",
    urlPath: "MovingEquipment",
    __projectId__: 3458,
};

const CardReceptionEquipment = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [
        {
            id: "docid",
            text: "№",
            order: "docid",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 50,
        },
        {
            id: "ТипПеремещения",
            text: "Тип перемещения",
            order: "ТипПеремещения.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },
        {
            id: "ПлощадкаПартнера",
            text: "Площадка партнера",
            order: "ПлощадкаПартнера.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },

        {
            id: "СервиснаяТерритория",
            text: "Сервисная территория",
            order: "ПлощадкаПартнера.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },

        {
            id: "Точка",
            text: "Точка",
            order: "Точка.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },

        {
            id: "Оборудование",
            text: "Оборудование",
            order: "Оборудование.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },
        {
            id: "OperDate",
            text: "Дата проведения",
            order: "OperDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$8,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankReceptionEquipment);

    cardFile.urlPath = settings$8.urlPath;


    return cardFile;
};

CardReceptionEquipment.settings = settings$8;

const settings$7 = {
    targetClass: "BaseInt.Справочники.Persona",
    rootName: "Контактные лица",
    urlPath: "ContactPerson",
    __projectId__: 3433,
};

const CardContactPerson = (props) => {
    const searchValue = o("");

    let tableHelper = TableHelper();

    let column_props = [
        {
            id: "IsGroup",
            text: "",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell:
                "display: flex; height: 100%; justify-content: center; align-items: center;",
            order: "IsGroup",
            fixWidth: 25,
            callback: tableHelper.fileOrFolder,
        }, //TODO
        {
            id: "Name",
            text: "Фамилия инициалы",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            // order: "name",
            width: 15,
        },
        {
            id: "Телефон",
            text: "Телефон",
            order: "Телефон",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 8,
        },
        {
            id: "Email",
            text: "Email",
            order: "Email",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 11,
        },
        {
            id: "Status",
            text: "Статус",
            order: "Status",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 9,
        },
        {
            id: "C4CUserId",
            text: "C4C user id",
            order: "C4CUserId",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 10,
        },
        {
            id: "Имя",
            text: "Имя",
            order: "Имя",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 15,
        },
        {
            id: "Фамилия",
            text: "Фамилия",
            order: "Фамилия",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 8,
            isHidden: true,
        },
        {
            id: "Отчество",
            text: "Отчество",
            order: "Отчество",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 8,
            isHidden: true,
        },
        {
            id: "Login",
            text: "Логин",
            order: "Login",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 8,
        },
        {
            id: "Password",
            text: "Пароль",
            order: "Password",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 8,
        },
        {
            id: "Пол",
            text: "Пол",
            order: "Пол",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            width: 5,
            callback: tableHelper.sexGender,
        },
    ];

    const handleSearchChange = () => {
        const filter = ("( Match(Фамилия,'*"+searchValue()+"*') or " +
                        "Match(Имя,'*"+searchValue()+"*') or "+
                        "Match(Отчество,'*"+searchValue()+"*') or " +
                        "Match(Email,'*"+searchValue()+"*') or " +
                        "Match(Name,'*"+searchValue()+"*') )" +
                        " and (isEmployee = false)"
                        );
        if (searchValue()!="")
            cardFile.setIsHierarchycal(false);
        else
            cardFile.setIsHierarchycal(true);
        cardFile.setConstFilter(filter);
        cardFile.updateTable();
    };
    const handleSearchInput = (value) => searchValue(value);
    const handleSearchClear = () => {
        handleSearchInput("");
        handleSearchChange();
    };

    let cardFile = CardFile({
        ...props,
        ...settings$7,
        cardWidth: 85,
        column_props: column_props,
        customTools: html`
            <div class="search-tools">
                <${SearchField}
                    value=${searchValue}
                    onInput=${handleSearchInput}
                    onChange=${handleSearchChange}
                    onClear=${handleSearchClear}
                    placeholder=${"Фамилия, имя, отчетство, EMail"}
                    showSearchButton=${false}
                />
            </div>
        `,
    class: "contact-person-card-file",
    ...props,
    });
    cardFile.setBlank(BlankEmployee); // set your blank on cardFile

    cardFile.setConstFilter("isEmployee = false");

    cardFile.urlPath = settings$7.urlPath;

    return cardFile;
};

CardContactPerson.settings = settings$7;

const BlankNotificationVariable = (props, docid) => {
    let blankName = docid ? "Язык:" : "Новый язык:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-language",
        [HELP_KEYS.PROJECT]: 3370,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "Name",
        type: "string",
        width: 200,
    });
 
    let row1 = blank.createRow();

    row1.addItems([name]);

    blank.addItem(row1);

    return blank;
};

const settings$6 = {
    targetClass: "Notification.Notification.Variable",
    rootName: "Переменные нотификаций",
    urlPath: "notificationVariable",
    __projectId__: 3302,
};

const CardFileVariable = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [

        {
            id: "Name",
            text: "Наименование",
            order: "Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 180,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$6,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankNotificationVariable);

    cardFile.urlPath = settings$6.urlPath;


    return cardFile;
};

CardFileVariable.settings = settings$6;

const BlankNotificationTemplate = (props, docid) => {

    let templateType = [{ value: "", text: " " },
    { value: 0, text: "Email" },
    { value: 1, text: "СМС" }];

    let copyes = [{ value: "", text: " " },
    { value: 0, text: "Получатель" },
    { value: 1, text: "Копия" },
    { value: 2, text: "Скрытая копия" }];

    let blankName = docid ? "Шаблон уведомления: " + props.Code : "Новый шаблон";
    let blank = Blank({ data: props, title: blankName, docid });
    let code = blank.createField({ title: "Код", key: "Code", type: "string", width: 650 });
    let name = blank.createField({ title: "Наименование", key: "Name", type: "string", width: 750 });
    let delay = blank.createField({ title: 'Задержка', key: "Delay", type: "checkbox", width: 150 });
    let subject = blank.createField({ title: "Тема письма", key: "Subject", type: "string", width: 920 });
    let body = blank.createField({ title: "Текст письма", key: "Body", type: "textarea", width: 920 });
    let type = blank.createField({ title: "Тип шаблона", key: "Type", type: "select", options: templateType, width: 250 });


    let InternalSubject = blank.createField({ title: "Тема внутреннего оповещения", key: "InternalSubject", type: "string", width: 750 });

    let internalMessage = blank.createField({ title: 'Внутреннее оповещение', key: "InternalMessage", type: "checkbox", width: 160 });

    let column_props = [
        { id: "Receiver", text: "Получатель", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "display: flex; height: 100%; justify-content: center; align-items: center;", width: 35, reference: CardFileVariable, placeHolder: "Выбрать", displayValue: "Name", searchKeys: ["Name"], },
        { id: "CC", text: "Копия", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center; color: #A9A9A9;", order: "extid", width: 25, type: "select", options: copyes },
        { id: "Comment", text: "Комментарий", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center; color: #A9A9A9;", order: "extid", width: 40, type: "input", placeHolder: "Введите значение" },
    ];

    let new_row_recipients_table = [
        {
            Receiver: "",
            CC: "",
            Comment: "",
        }
    ];

    let recipientsTable = blank.createTable({ column_props, tableWidth: 47, key: "Recipients" });

    let addRowPositions = html`<button class="add-button"></button>`;
    addRowPositions.addEventListener("click", e => {
        e.preventDefault();
        recipientsTable.createRows(new_row_recipients_table);
    });

    let tableWidthAddButton = html`
        <div style="display: flex; margin-bottom: 10px;">
            ${recipientsTable}
            ${addRowPositions}
        </div>
    `;

    let headerRow = blank.createRow();
    let centerRow = blank.createRow();
    let subjectRow = blank.createRow();
    let bodyRow = blank.createRow();
    let internalRow = blank.createRow();

    internalRow.addItems([internalMessage, InternalSubject]);

    headerRow.addItems([code, type]);
    centerRow.addItems([name, delay]);
    subjectRow.addItems([subject]);
    bodyRow.addItems([body]);

    blank.addItem(headerRow);
    blank.addItem(centerRow);
    blank.addItem(subjectRow);
    blank.addItem(bodyRow);
    blank.addItem(internalRow);
    blank.addItem(tableWidthAddButton);


    return blank;
};

const CardFileNotificationTemplate = props => {
                
    const filter = '(' + (settings$5?.filter || 'true') + ') and (' + (props?.filter || 'true') + ')';
    const order = (settings$5?.order || '') + ((!!settings$5?.order && !!props?.order) ? ';' : '') + (props?.order || '');

    let tableHelper = TableHelper();

    let column_props = [
        { id: "IsGroup", text: "", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "display: flex; height: 100%; justify-content: center; align-items: center;", order: "type", fixWidth: 25, callback: tableHelper.fileOrFolder }, //TODO
        { id: "Code", text: "Код", order: "Code", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", width: 7 },
        { id: "Name", text: "Наименование", order: "Name", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", width: 15 },
        { id: "Delay", text: "Задержка", order: "Delay", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", width: 10, callback: tableHelper.checkBox },
        { id: "Subject", text: "Тема письма", order: "Subject", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", width: 25 },
        { id: "Body", text: "Текст письма", order: "Body", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", width: 25 },
        { id: "Type", text: "Тип шаблона", order: "Type", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", width: 10, callback: tableHelper.templateType },
        { id: "InternalMessage", text: "Внутреннее", order: "Delay", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", width: 12, callback: tableHelper.checkBox },

        { id: "docid", text: "DOCID", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", order: "docid", width: 5, isHidden: true },
        { id: "CreateDate", text: "Дата создания", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", order: "CreateDate", width: 12, isHidden: true },
        { id: "CreateUser", text: "Кто создал", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", order: "CreateUser", width: 15, isHidden: true },
        { id: "UpdateDate", text: "Дата изменения", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", order: "UpdateDate", width: 12, isHidden: true },
        { id: "UpdateUser", text: "Кто изменил", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", order: "UpdateUser", width: 15, isHidden: true },
    ];

    let cardFile = CardFile({ ...props, ...settings$5, cardWidth: 80, column_props: column_props, inModal: props?.inModal, callBackElement: props?.callBackElement });

    cardFile.setBlank(BlankNotificationTemplate); // set your blank on cardFile

    cardFile.setConstFilter(filter);
    cardFile.setConstOrder(order);

    cardFile.urlPath = settings$5.urlPath;

    return cardFile;
};

const settings$5 = {
    targetClass: "Notification.Notification.Template",
    rootName: "Шаблоны уведомлений",
    urlPath: "notificationTemplates",
    filter: "", 
    order: "",
    recordDescription: "Name",
};

CardFileNotificationTemplate.settings = settings$5;

let templateType = [{ value: "", text: " " },
{ value: 0, text: "Email" },
{ value: 1, text: "СМС" }];

let copyes = [{ value: "", text: " " },
{ value: 0, text: "Получатель" },
{ value: 1, text: "Копия" },
{ value: 2, text: "Скрытая копия" }];

const BlankMessage = (props, docid) => {
    let blankName = docid ? "Уведомление: " + props.Subject : "Новое уведомление";
    let blank = Blank({ data: props, title: blankName, docid });
    let template = blank.createField({ title: "Шаблон письма", key: "Template", reference: CardFileNotificationTemplate, width: 830 });
    let delay = blank.createField({ title: "Задержка", key: "Delay", type: "checkbox", width: 200 });
    let subject = blank.createField({ title: 'Тема письма', key: "Subject", type: "string", width: 650 });
    let error = blank.createField({ title: "Текст ошибки", key: "Error", type: "string", width: 650 });
    let type = blank.createField({ title: "Тип шаблона", key: "Type", type: "select", options: templateType, width: 250 });

    let previewMessage = html`<div class="message-preview hide"></div>`;
    previewMessage.isHidden = () => previewMessage.classList.contains("hide");

    const changeMessage = () => {
        if (previewMessage.isHidden()) return;
        // берем все части сообщения, соединяем и отображаем
        const newHtml = bodyTable
            ?.getData()
            ?.map(({ Text }) => Text)
            ?.reduce((acc, str) => (acc += str), "");
        previewMessage.innerHTML = newHtml ? newHtml : "";
    };

    const messageChange = (cellValue, data) => {
        let elem = html`<input value="${cellValue}" placeholder="Введите значение" />`;
        elem.addEventListener("input", ({ target }) => {
            // меняем данные в data, чтобы по нажатию кнопки принять уходили исправенные данные
            data["Text"] = target.value;
            changeMessage();
        });
        return elem;
    };

    let column_props = [
        { id: "Text", text: "Часть текста письма", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center; color: #A9A9A9;", order: "extid", width: 100, changeValue: messageChange },
    ];

    let newRowBodyTable = [
        {
            Text: "",
        }
    ];

    let bodyTable = blank.createTable({ column_props, tableWidth: 20, key: "Body" });

    let addRowBody = html`<button class="add-button"></button>`;
    // кнопка отображения\скрытия предпросмотра сообщения
    let showPreviewBtn = html`<button class="visibility-button"></button>`;

    const togglePreview = (e) => {
        e.preventDefault();
        showPreviewBtn.classList.toggle("is-active");
        previewMessage.classList.toggle("hide");
        changeMessage();
    };

    showPreviewBtn.addEventListener("click", togglePreview);

    addRowBody.addEventListener("click", (e) => {
        e.preventDefault();
        bodyTable.createRows(newRowBodyTable);
    });

    let tableBody = html`
        <div style="display: flex; margin-bottom: 10px;">
            ${bodyTable}
            <div>${addRowBody} ${showPreviewBtn}</div>
        </div>
    `;

    column_props = [
        { id: "Address", text: "Email или номер телефона", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center; color: #A9A9A9;", order: "extid", width: 35, type: "input", placeHolder: "Введите значение" },
        { id: "CC", text: "Копия", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center; color: #A9A9A9;", order: "extid", width: 25, type: "select", options: copyes },
        { id: "Commnent", text: "Комментарий", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center; color: #A9A9A9;", order: "extid", width: 40, type: "input", placeHolder: "Введите значение" },
    ];

    let newRowRecipientsTable = [
        {
            Address: "",
            CC: "",
            Commnent: "",
        }
    ];

    let recipientsTable = blank.createTable({ column_props, tableWidth: 30, key: "Recipients" });

    let addRowRecipients = html`<button class="add-button"></button>`;
    addRowRecipients.addEventListener("click", e => {
        e.preventDefault();
        recipientsTable.createRows(newRowRecipientsTable);
    });

    let tableRecipients = html`
        <div style="display: flex; margin: 0 20px 10px;">
            ${recipientsTable}
            ${addRowRecipients}
        </div>
    `;

    column_props = [
        { id: "Filename", text: "Вложенные файлы", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center; color: #A9A9A9;", order: "extid", width: 100, type: "input", placeHolder: "Выберите файл" },
    ];

    let newRowAttachmantsTable = [
        {
            Filename: "",
        }
    ];

    let attachmantsTable = blank.createTable({ column_props, tableWidth: 15, key: "Attachments" });

    let addRowAttachmants = html`<button class="add-button"></button>`;
    addRowAttachmants.addEventListener("click", e => {
        e.preventDefault();
        attachmantsTable.createRows(newRowAttachmantsTable);
    });

    let tableAttachmants = html`
        <div style="display: flex; margin-bottom: 10px;">
            ${attachmantsTable}
            ${addRowAttachmants}
        </div>
    `;

    let tablePanel = html`
        <div style="display: flex">
            <div>${tableBody}</div>
            <div>${tableRecipients}</div>
            <div>${tableAttachmants}</div>
        </div>
    `;

    let headerRow = blank.createRow();
    let centerRow = blank.createRow();
    let bottomRow = blank.createRow();
    let previewRow = blank.createRow();

    headerRow.addItems([template, delay, type]);
    centerRow.addItems([subject, error]);
    bottomRow.addItems([tablePanel]);
    previewRow.addItem(previewMessage);

    blank.addItem(headerRow);
    blank.addItem(centerRow);
    blank.addItem(bottomRow);
    blank.addItem(previewRow);
    return blank;
};

const CardFileMessage = props => {
        
    const filter = '(' + (settings$4?.filter || 'true') + ') and (' + (props?.filter || 'true') + ')';
    const order = (settings$4?.order || '') + ((!!settings$4?.order && !!props?.order) ? ';' : '') + (props?.order || '');

    let tableHelper = TableHelper();

    let column_props = [
        //{ id: "IsGroup", text: "", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "display: flex; height: 100%; justify-content: center; align-items: center;", order: "type", fixWidth: 25, callback: tableHelper.fileOrFolder }, //TODO
        { id: "Template", text: "Шаблон письма", order: "Template.Name", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", width: 20 },
        { id: "Delay", text: "Задержка", order: "Delay", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", width: 15, callback: tableHelper.checkBox },
        { id: "Subject", text: "Тема письма", order: "Subject", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", width: 25 },
        { id: "Error", text: "Текст ошибки", order: "Error", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", width: 25 },
        { id: "Type", text: "Тип сообщения", order: "Type", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", width: 12, callback: tableHelper.templateType },

        { id: "docid", text: "DOCID", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", order: "docid", width: 5, isHidden: true },
        { id: "CreateDate", text: "Дата создания", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", order: "CreateDate", width: 12, isHidden: true },
        { id: "CreateUser", text: "Кто создал", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", order: "CreateUser", width: 15, isHidden: true },
        { id: "UpdateDate", text: "Дата изменения", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", order: "UpdateDate", width: 12, isHidden: true },
        { id: "UpdateUser", text: "Кто изменил", style: 'text-align: center; width: 100%; justify-content: center;', styleCell: "text-align: center;", order: "UpdateUser", width: 15, isHidden: true },
    ];

    let cardFile = CardFile({
        ...props, 
        ...settings$4,
        cardWidth: 80,
        column_props: column_props,
        inModal: props?.inModal, 
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankMessage); // set your blank on cardFile

    cardFile.setConstFilter(filter);
    cardFile.setConstOrder(order);

    cardFile.urlPath = settings$4.urlPath;

    return cardFile;
};

const settings$4 = {
    targetClass: "Notification.Notification.Message",
    rootName: "Уведомления",
    urlPath: "messages",
    filter: "", 
    order: "",
    recordDescription: "Subject",
};

CardFileMessage.settings = settings$4;

const Report303 = (props) => {
    const { selection = false, filter = "", onAccept, st, distrib, storagearea } = props;
    const repData = o();
    const tableRef = new Ref();

    let loader = Loader();

    let blank = Blank({ data: "", title: "" });

    let датаПо = blank.createField({
        title: "Дата по",
        key: "датаПо",
        type: "date",
        width: 160,
        value: getCurrentDateJS(),
    });

    function handleAcceptBtnClick() {
        let data = tableRef.current.getData();
        data = data.filter((rowData) => rowData.Кнопка);
        const keys = [
            { src: "Оборудование", dest: "Оборудование"},
            { src: "Площадка", dest: "Площадка"},
        ];

        const selectdata = data.map((rowData) => {
            return keys.reduce((acc, { src, dest }) => {
                const result = {...acc, [dest]: {
                    Name: rowData[src],
                    docid: rowData[`${src}_DocId`],
                    targetClass: rowData[`${src}_targetClass`],
                }};
                result["счетСписания"]=rowData["счетСписания"];
                result["Комментарий"]="";
                return result;
            }, {});
        });
        onAccept?.({ data: selectdata });
    }
    const confirmButton = html`<${Button} onClick=${handleAcceptBtnClick}>
        Принять
    <//>`;

    function refreshReport() {
        if (датаПо.getValue() == null) return;
        loader.show();
        GetReport303({ doe: датаПо.getValue(), st, distrib, storagearea })
            .then((result) => {
                repData(result.data);
            })
            .catch((error) => {
                console.log(error);
            })
            .finally(() => loader.hide());
    }

    let refreshButton = html`<${Button} style="margin-right: 10px">
        Обновить
    <//>`;

    refreshButton.addEventListener("click", () => {
        if (датаПо.getValue() == null)
            return Message$1("Отсутствует дата", "error");

        refreshReport();
    });

    const toolBar = html`<div class="toolbar">
        <div class="filters">
            <h3>303 - Выбор оборудования</h3>
        </div>
        <div class="report-buttons"><${HelpLink} projectId=${3413}/>${refreshButton}${confirmButton}</div>
    </div>`;

    // const tableObservable = o();
    const renderTable = on(
        repData,
        () => ReportViewContaiter$5({ ...props, data: repData, ref: tableRef }),
        null,
        true
    );

    const reportBody = html`<div class="report303">
        ${toolBar}
        <div class="scrollable">
            ${renderTable}
        </div>
    </div>`;

    refreshReport();

    //console.log(reportBody);
    return reportBody;
};

const ReportViewContaiter$5 = (props) => {
    const repTable = ReportTable$5(props);
    const view = html`<div class="report-view-container">${repTable}</div>`;
    return view;
};

const ReportTable$5 = ({ data, selection = false, onSelect, ref }) => {
    if (!data()) return;

    let column_totalRep = [
        {
            id: "Модель",
            text: "Модель",
            order: "Модель",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
        },
        {
            id: "Оборудование",
            text: "Оборудование",
            order: "Оборудование",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
        },
        {
            id: "Оборудование_DocId",
            text: "Оборудование",
            order: "Оборудование",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
            isHidden: true,
        },
        {
            id: "Оборудование_targetClass",
            text: "Оборудование",
            order: "Оборудование",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
            isHidden: true,
        },
        {
            id: "счетСписания",
            text: "счетСписания",
            order: "счетСписания",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
            //isHidden: true,
        },
        {
            id: "Площадка",
            text: "Площадка",
            order: "Площадка",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
            //isHidden: true,
        },
        {
            id: "Площадка_DocId",
            text: "Площадка_DocId",
            order: "Площадка_DocId",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
            //isHidden: true,
        },
        

    ];

    // const columnsRep = data().Columns[0].body;

    // columnsRep.forEach((element) => {
    //     column_totalRep.push({
    //         id: element.SplitValue,
    //         text: "Кол-во",
    //         style: "text-align: center; width: 100%; justify-content: center;",
    //         styleCell: "text-align: right;",
    //         fixWidth: 100,
    //     });
    // });

    if (selection)
        column_totalRep.push({
            id: "Кнопка",
            text: "",
            order: "Кнопка",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 24,
            type: "checkbox",
        });

    const tableTotalRep = Table({
        column_props: column_totalRep,
        class: "table-total",
    });

    ref.current = tableTotalRep;

    // data()
    //     .Columns.map(({ body }) => body)
    //     .forEach((columns, rowIndex) => {
    //         columns.forEach((column) => {
    //             //console.log(column)
    //             data().Rows[rowIndex][column.SplitValue] = column.Volume;
    //         });
    //     });

    console.log(data());
    tableTotalRep.createRows(data());

    return tableTotalRep;
};

const BlankInternalMovement = (props, docid) => {
    let blankName = "Внутреннее перемещение:";

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-internalmovement",
        [HELP_KEYS.PROJECT]: 3195,
    });

    const modal = Modal();

    let id = blank.createField({
        title: "",
        key: "docid",
        type: "string",
        disabled: true,
        width: 30,
    });
    blank.createField({
        title: "Наименование",
        key: "NumberDoc",
        type: "string",
        width: 200,
    });
    let status = blank.createField({
        title: "Статус",
        key: "Status",
        reference: CardStatus,
        disabled: true,
        width: 140,
    });
    let initiator = blank.createField({
        title: "Инициатор",
        key: "Инициатор",
        reference: CardFileEmployee,
        width: 140,
        disabled: true,
    });
    let responsible = blank.createField({
        title: "Ответственный",
        key: "Ответственный",
        reference: CardFileEmployee,
        width: 140,
    });
    let dateFact = blank.createField({
        title: "Дата факт.",
        key: "ДатаФакт",
        type: "date",
        width: 125,
        disabled: true,
    });
    let distributor = blank.createField({
        title: "Площадка партнера",
        key: "ПлощадкаПартнера",
        reference: CardAccount,
        isHierarchycal: false,
        initTree: false,
        constFilter: "ТипКлиента.Name = 'Площадка партнера'",
        width: 407,
        disabled: true,
    });
    let serviceTerritory = blank.createField({
        title: "Сервисная территория",
        key: "СервиснаяТерритория",
        reference: CardServiceTerritory,
        isHierarchycal: false,
        initTree: false,
        width: 407,
    });
    let areaFrom = blank.createField({
        title: "Зона откуда",
        key: "ЗонаОткуда",
        reference: CardStorageArea,
        constFilter: "Name <> 'Установлено'",
        width: 200,
    });
    let areaTo = blank.createField({
        title: "Зона куда",
        key: "ЗонаКуда",
        reference: CardStorageArea,
        constFilter: "Name <> 'Установлено'",
        width: 200,
    });

    //Подтаблица
    const positionsProps = [
        {
            id: "Оборудование",
            text: "Номер производителя",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 202.5,
            // reference: CardEquipment,
            // displayValue: "ManufacturerNumber",
            // searchKeys: ["ManufacturerNumber"],
            changeValue: (value, ...rest) => {
                const [,,{cells, columns_hash}] = rest;
                const  handleChange = (ev) => {
                    // ev - event; беру его значение из таргета 
                    ev.target.value;
                               
                    checkByManufectererNumberInInternalMovement(serviceTerritory.getValue() , areaFrom.getValue() , ev.target.value).then(async (res) => {
                             if (res.CountRecords == 1) {
                                 serviceTerritory.setValue(res.ST);
                                 distributor.setValue(res.Площадка);
                                 areaFrom.setValue(res.ЗонаХранения);
                    //             cells[columns_hash['Модель']]?.value.setValue(res.Модель);
                                 cells[columns_hash['Оборудование']]?.value.setValue(res.Оборудование);
                                 cells[columns_hash['счетСписания']]?.value.setValue(res.счетСписания);
                             }
    
                            if (res.CountRecords > 1) {
                                modal.setContent(ReportSelectEquipment({data: res.data, onSelect: ({data}) => {
                                    serviceTerritory.setValue({docid: data.СервиснаяТерритория_ID , Name: data.СервиснаяТерритория});
                                    distributor.setValue({docid: data.Площадка_ID , Name: data.Площадка});
                                    areaFrom.setValue({docid: data.ЗонаХранения_ID , Name: data.ЗонаХранения});
                                 //   cells[columns_hash['Модель']]?.value.setValue({docid: data.Модель_ID , Name: data.Модель});
                                    cells[columns_hash['Оборудование']]?.value.setValue({docid: data.Оборудование_ID , Name: data.Оборудование});
                                    cells[columns_hash['счетСписания']]?.value.setValue(data.счетСписания);
                                    
                                    modal.hide();
                                }}));
                                modal.show();
                            }
        
                            if (res.CountRecords == 0) {
                                ev.target.blur();
                                return Message$1("Не найдено ни одного совпадения по серийному номеру или нет свободного остатка","error"); 
                            }
                    });

                    // выход из ячейки
                    ev.target.blur();
                    //console.log(ev.target.value);
                };

                const inputSN = html`<input value=${value?.Name} onchange=${handleChange}/>`;

                return inputSN;
            }
        },

        {
            id: "Комментарий",
            text: "Комментарий",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 202.5,
            type: "string",
        },    
        {
            id: "счетСписания",
            text: "счетСписания",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 202.5,
            type: "string",
        },    

    ];
    
    const tablePositons = blank.createTable({
        column_props: positionsProps,
        width: 100,
        key: "Позиции",
        class: "positions-table",
    });
    
    let addRowPositions = html`<button
        class="add-button"
        type="button"
    ></button>`;
    addRowPositions.addEventListener("click", (e) => {
        e.preventDefault();
        tablePositons.createEmptyRow();
    });

    //Подтаблица Жизненный цикл
    const lifeCycle = [
        {
            id: "ДатаСобытия",
            text: "Дата cобытия",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 210,
            type: "string",
            disabled: true,
        },
        {
            id: "Persona",
            text: "Исполнитель",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 300,
            reference: CardFileEmployee,
            disabled: true,
        },
        {
            id: "ОписаниеСобытия",
            text: "Описание события",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 300,
            type: "string",
            disabled: true,
        },
    ];

    const tableLifeCycle = blank.createTable({
        column_props: lifeCycle,
        width: 300,
        key: "ЖизненныйЦикл",
    });

    let addRowLifeCycle = html`<button
        class="add-button"
        type="button"
    ></button>`;
    addRowLifeCycle.addEventListener("click", (e) => {
        e.preventDefault();
        tableLifeCycle.createEmptyRow();
    }); 
    //Кнопки действий
    if (docid != null) {
        getEnabledActionsForInternalMovement(docid).then((res) => {
            const buttons = res.data.elements.map((element) => {
                const button = html`<div class="col-auto">
                    ${Button({ text: element.Name, title: element.Desc })}
                </div>`;
                button.addEventListener("click", () => {
                    checkBeforeAction(docid, element.Name);
                });

                return button;
            });

            buttonsActions(buttons);
        });
    }

    const buttonsActions = o([]);

    function checkBeforeAction(docid, commandName) {
        if (
            commandName == "Отклонить" 
        ) {
            let blTitle;
            let btnText;

            let requestCommentBlank = BlankRequestComment({
                rejectFieldWidth: 700,
                rejectFieldHeight: 200,
                command: commandName,
                docid: docid,
                blankTitle: blTitle,
                rejectButtonText: btnText,
            });

            requestCommentBlank.rejectButtonAction = (_) => {
                if (requestCommentBlank.getData() == undefined) {
                    return;
                }

                createOrUpdateRecord(
                    "C4C.Документы.ВнутреннееПеремещение",
                    blank.getData()
                ).then(() => {
                    executeActionForInternalMovement(
                        docid,
                        commandName,
                        requestCommentBlank.getData()
                    ).then(async (res) => {
                        if (res.isOk) {
                            modal.hide();
                            blank.refreshData?.(docid);
                        }
                    });
                });
            };

            requestCommentBlank.cancelButtonAction = () => modal.hide();
            modal.setContent(requestCommentBlank);
            modal.show();
            return;
        } else {
            createOrUpdateRecord(
                "C4C.Документы.ВнутреннееПеремещение",
                blank.getData()
            ).then(() => {
                executeActionForInternalMovement(docid, commandName).then(
                    async (res) => {
                        if (res.isOk) {
                            modal.hide();
                            blank.refreshData?.(docid);
                        }
                    }
                );
            });
        }
    }
    //Заполнение статуса и инициатора при создании
    if (!docid) {
        getRecord$1("BaseInt.Status", +2).then((result) => {
            status.setValue(result);
        });
        getRecord$1("BaseInt.Справочники.Persona", +getUserId()).then(
            (result) => {
                initiator.setValue(result);
                responsible.setValue(result);
            }
        );
        // и сразу пустую строку
        tablePositons.createEmptyRow();

    }
    //Кнопка выбрать оборудование
    const selectEquipment = html`<${Button}>Выбрать оборудование<//>`;

    selectEquipment.addEventListener("click", () => {
        if (!serviceTerritory.getValue().docid)
            return Message$1("Не выбрана сервисная территория","error");
        // if (!distributor.getValue().docid)
        //     return Message("Не выбрана площадка партнера","error");   
        if (!areaFrom.getValue().docid)
            return Message$1("Не выбрана зона хранения откуда","error");        
        let report303Blank = Report303({
            selection: true,
            st: serviceTerritory.getValue(),
            distrib: distributor.getValue(),
            storagearea: areaFrom.getValue(),
            onAccept: ({ data }) => {
                tablePositons.clearRows();
                tablePositons.createRows(data);
                distributor.setValue(data[0]?.Площадка);
                modal.hide();
            },
        });
        modal.setContent(report303Blank);
        modal.show();
    });
    //
    let headerRow = blank.createRow();
    headerRow.addItems([id,responsible,initiator,status ]);

    blank.addHeaderLeftItem(headerRow);

    let mainInfoItem = mainInfo$1({
        dateFact,
        distributor,
        serviceTerritory,
        areaFrom,
        areaTo,
        selectEquipment,

        tablePositons,
        addRowPositions,
    });

    //Вкладки

    let tabs = html`<div class="blank-content"></div>`;
    let tabsWithButtons = html`<div class="blank-tabswithbuttons">${tabs}${buttonsActions}</div>`;
    let browseData = html`
        ${mainInfoItem}
    `;


    let browseTabContentO = o();
    let additionalInfoTabContentO = o();

    const hideAdditionalInfoTabContent = o(false);

    let browseTabContent = html`<div class="browse-tab-content">
        ${browseData}
    </div> `;
    browseTabContentO(browseTabContent);

    let additionalInfoTabContent = html`
        <div class="additionalinfo-tab-content">
            <div class="blank-row">${tableLifeCycle}</div>
        </div>
    `;
    additionalInfoTabContentO(additionalInfoTabContent);

    if (hideAdditionalInfoTabContent()) hideAdditionalInfoTabContent(false);

    const mainTabType = {
        browse: { index: 0, name: "Обзор" },
        additionalInfo: { index: 0, name: "Доп. информация" },
    };

    let mainTabView = TabView();

    mainTabView.addTab(
        mainTabType.browse.name,
        browseTabContentO
    );
    mainTabView.addTab(
        mainTabType.additionalInfo.name,
        additionalInfoTabContentO
    );

    mainTabView.style.overflow = "auto";
    mainTabView.getTab(0).isActive();
    tabs.append(mainTabView);

    blank.addItem(tabsWithButtons);
    //

    blank.style.maxWidth = "min-content";
    blank.style.height = 90 + "vh";
    blank.style.width = 76 + "vw";

    return blank;
};


const mainInfo$1 = (fields) => {
    function renderFields() {
        return html`
            <div class="blank-row">${fields.serviceTerritory}${fields.dateFact}</div>   
            <div class="blank-row"> ${fields.distributor}</div>      
            <div class="blank-row">${fields.areaFrom}${fields.areaTo}</div> 
            <div class="blank-row">${fields.tablePositons}</div>
        `;
    }
    return html`
        <div class="blank-basicInfo">
            ${renderFields}
        </div>
    `;
};



const ReportSelectEquipment = ({data, onSelect}) => {

    let column_rep_select_equipment = [
        {
            id: "СервиснаяТерритория",
            text: "Сервисная территория",
            order: "СервиснаяТерритория",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 220,
        },
        {
            id: "Площадка",
            text: "Площадка",
            order: "Площадка",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 220,
        },
        {
            id: "Модель",
            text: "Модель",
            order: "Модель",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 220,
        },
        {
            id: "Оборудование",
            text: "Номер производителя",
            order: "Оборудование",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 200,
        },

        {
            id: "счетСписания",
            text: "счетСписания",
            order: "счетСписания",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 200,
            isHidden: true,
        },
        
        
        {
            id: "Кнопка",
            text: "",
            order: "Оборудование",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 77,
            changeValue: (...params) => {
                const [, rowData] = params;
                const button = html`<${Button}>Выбрать<//>`;
                button.addEventListener("click", () => {
                    onSelect?.({data: rowData});
                });
                return button;
            },
        }
    ];

    const tableSelectEquipment = Table({
        column_props: column_rep_select_equipment,
        class: "table-report",
    });

    tableSelectEquipment.createRows(data);

    return html`
    <div class="modal-inputnumber">                
        <h3>Найдено несколько номеров производителя:</h3>
        <div>${tableSelectEquipment}</div>
    </div>
    `;
};

const settings$3 = {
    targetClass: "C4C.Документы.ВнутреннееПеремещение",
    rootName: "Внутреннее перемещение",
    urlPath: "InternalMovement",
    __projectId__: 3195,
};

const CardInternalMovement = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [


        {
            id: "docid",
            text: "№",
            order: "docid",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 35,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
        {
            id: "Инициатор",
            text: "Инициатор",
            order: "Инициатор.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
        {
            id: "ДатаФакт",
            text: "Дата факт",
            order: "ДатаФакт",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 110,
        },
        {
            id: "ПлощадкаПартнера",
            text: "Площадка партнера",
            order: "ПлощадкаПартнера.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
        {
            id: "СервиснаяТерритория",
            text: "Сервисная территория",
            order: "СервиснаяТерритория.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
        {
            id: "Status",
            text: "Статус",
            order: "Status.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 120,
            reference: CardStatus,

            callback: (data, rowData) => {
                const element = html`<span>${data}</span>`;
                const setColor = () => {
                    const tableCell = element.closest(".table-cell");
                    if (!tableCell) return;
                    tableCell.style.backgroundColor = rowData.StatusColor;
                };
                if (rowData.StatusColor) {
                    observe(element);
                    element.addEventListener("connected", setColor);
                    element.addEventListener("disconnected", () => {
                        element.removeEventListener("connected", setColor);
                        unobserve(element);
                    });
                }

                return element;
            },

        },
        {
            id: "ЗонаОткуда",
            text: "Зона откуда",
            order: "ЗонаОткуда.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
        {
            id: "ЗонаКуда",
            text: "Зона куда",
            order: "ЗонаКуда.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },

        
    ];

    let cardFile = CardFile({
        ...settings$3,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankInternalMovement);

    cardFile.urlPath = settings$3.urlPath;


    return cardFile;
};

CardInternalMovement.settings = settings$3;

const BlankVisitRoute = (props, docid) => {
    let blankName = "Маршрут:";
    const { cardFile } = props;

    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-visitroute",
        [HELP_KEYS.PROJECT]: 3529,
    });
    let name = blank.createField({
        title: "Наименование",
        key: "NumberDoc",
        type: "string",
        width: 200,
    });
    let status = blank.createField({
        title: "Статус",
        key: "Status",
        reference: CardStatus,
        width: 150,
    });
    let responsible = blank.createField({
        title: "Ответственный",
        key: "Ответственный",
        reference: CardFileEmployee,
        width: 150,
    });
    let operDate = blank.createField({
        title: "Дата начала",
        key: "OperDate",
        type: "dateTime",
        width: 150,
    });

    let типВизитаПоУмолчанию = blank.createField({
        title: "Тип визита по умолчанию",
        key: "ТипВизита",
        reference: CardActivityType,
        width: 300,
    });

    let ВремяНаДорогу = blank.createField({
        title: "Время на дорогу",
        key: "ВремяНаДорогу",
        type: "numeric",
        width: 140,
    });
    

    let ПродолжительностьПоУмолчанию = blank.createField({
        title: "Продолжительность",
        key: "Продолжительность",
        type: "numeric",
        width: 140,
    });
    

    


    //Подтаблица
    const positionsProps = [
        {
            id: "ДатаПлан",
            text: "Дата план",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
            type: "dateTime",
            createFullCellColor: ({id,data,rowData}) => {
                if (rowData.Визит?.docid)
                    return "#ffff9e";
            }
        },

        {
            id: "Продолжительность",
            text: "Продолжительность",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 140,
            type: "numeric",
            createFullCellColor: ({id,data,rowData}) => {
                if (rowData.Визит?.docid)
                    return "#ffff9e";
            }
        },

        {
            id: "ДатаОкончания",
            text: "Дата окончания",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
            type: "dateTime",
            createFullCellColor: ({id,data,rowData}) => {
                if (rowData.Визит?.docid)
                    return "#ffff9e";
            }
        },

        {
            id: "Точка",
            text: "Точка",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 320,
            reference: CardAccount,
            createFullCellColor: ({id,data,rowData}) => {
                if (rowData.Визит?.docid)
                    return "#ffff9e";
            }
        },

        {
            id: "ТипВизита",
            text: "Тип визита",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 150,
            reference: CardActivityType,
            createFullCellColor: ({id,data,rowData}) => {
                if (rowData.Визит?.docid)
                    return "#ffff9e";
            }
        },

        // {
        //     id: "ВремяНаДорогу",
        //     text: "Время на дорогу",
        //     style: "text-align: center; width: 100%; justify-content: center;",
        //     styleCell: "text-align: center;",
        //     fixWidth: 100,
        //     type: "integer",
        // },


        {
            id: "Визит",
            text: "Визит",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 100,
            reference: CardActivity,
            displayValue: "docid",
            searchKeys: ["docid"],
            createFullCellColor: ({id,data,rowData}) => {
                if (rowData.Визит?.docid)
                    return "#ffff9e";
            }
        },

    ];

    const positionsTable = blank.createTable({
        column_props: positionsProps,
        width: 300,
        key: "Позиции",
    });

    let addRowPositions = html`<button
        class="add-button"
        type="button"
    ></button>`;
    addRowPositions.addEventListener("click", (e) => {
        e.preventDefault();
        positionsTable.createEmptyRow();
    });
    //


    if (!docid) {
        getRecord$1("BaseInt.Status", +6).then((result) => {
            status.setValue(result);
        });

        getRecord$1("BaseInt.Справочники.Persona", +getUserId()).then(
            (result) => {
                responsible.setValue(result);
            }
        );

    }

    const sortButton = html`<${Button}>Запланировать<//>`;
    sortButton.addEventListener("click", async () => {

        createOrUpdateRecord(
            "C4C.Документы.Маршрут",
            blank.getData()
        ).then((res) => {
            planningVisits(res.data.docid).then(() => {
                blank.refreshData?.(res.data.docid);
                //const tabledata = positionsTable.getData();
                //const filteredData = tabledata.filter((m) => m.Визит?.docid);
            });
        });
    });

    const createVisitsButton = html`<${Button}>Сформировать визиты<//>`;
    createVisitsButton.addEventListener("click", () => {
        createOrUpdateRecord(
            "C4C.Документы.Маршрут",
            blank.getData()
        ).then(() => {
            createVisits(docid).then(() => {
                blank.hide();
                location.href="https://np360.nestle.ru/#visits";
            });
        });
     });

    //Кнопка сохранить
    const saveButton = html`<${Button}>Сохранить<//>`;
    saveButton.addEventListener("click", async () => {
        const result = await createOrUpdateRecord(
            "C4C.Документы.Маршрут",
            blank.getData()
        );
        if (!result.isOk) {
            console.error(result.data ?? result.error);
            return;
        }
        blank.refreshData(result.data.docid);
        cardFile?.updateTable();
    }); 
    
    //Элементы
    let headerRow = blank.createRow();
    headerRow.addItems([name, responsible, status]);
    blank.addHeaderLeftItem(headerRow);
    blank.addHeaderRightItem(saveButton);

    let mainInfoItem = mainInfo({
        operDate,
        типВизитаПоУмолчанию,
        ВремяНаДорогу,
        ПродолжительностьПоУмолчанию,
        sortButton,
        createVisitsButton,
        positionsTable,
        addRowPositions,

    });

    blank.addItem(mainInfoItem);

    blank.style.maxWidth = "min-content";
    blank.style.height = 90 + "vh";
    blank.style.width = 80 + "vw";

    return blank;
};

const mainInfo = (fields) => {
    return html`
        <div class="blank-row">
            ${fields.operDate} ${fields.endDate} ${fields.рабочееВремяЧасыС}${fields.рабочееВремяМинутыС}${fields.РабочееВремяЧасыПо}${fields.РабочееВремяМинутыПо}
        </div>
        <div class="blank-row">
            ${fields.типВизитаПоУмолчанию}${fields.ВремяНаДорогу}${fields.ПродолжительностьПоУмолчанию}
        </div>
        <div class="blank-row">
            ${fields.sortButton}${fields.createVisitsButton}
        </div>
        
        <div class="blank-basicInfo">
            <div class="blank-row">${fields.positionsTable}${fields.addRowPositions}</div>
        </div>
    `;
};

const settings$2 = {
    targetClass: "C4C.Документы.Маршрут",
    rootName: "Маршрут",
    urlPath: "VisitRoute",
    // __projectId__: 3193,
};

const CardVisitRoute = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [
        {
            id: "docid",
            text: "№",
            order: "docid",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 40,
        },
        {
            id: "NumberDoc",
            text: "Наименование",
            order: "NumberDoc",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },
        {
            id: "Status",
            text: "Статус",
            order: "Status.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 120,
            reference: CardStatus,
            callback: (data, rowData) => {
                const element = html`<span>${data}</span>`;
                const setColor = () => {
                    const tableCell = element.closest(".table-cell");
                    if (!tableCell) return;
                    tableCell.style.backgroundColor = rowData.StatusColor;
                };
                if (rowData.StatusColor) {
                    observe(element);
                    element.addEventListener("connected", setColor);
                    element.addEventListener("disconnected", () => {
                        element.removeEventListener("connected", setColor);
                        unobserve(element);
                    });
                }
                return element;
            },
        },
        {
            id: "Ответственный",
            text: "Ответственный",
            order: "Ответственный.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
        {
            id: "OperDate",
            text: "Дата начала",
            order: "OperDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
    ];

    let cardFile = CardFile({
        ...settings$2,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
    });

    cardFile.setBlank(BlankVisitRoute);

    cardFile.urlPath = settings$2.urlPath;


    return cardFile;
};

CardVisitRoute.settings = settings$2;

const BlankAppeals = (props, docid) => {
    let blankName = "Обращение: ";
    let blank = Blank({
        data: props,
        title: blankName,
        docid,
        class: "blank-appeals",
        [HELP_KEYS.PROJECT]: 3487,
    });

    Modal();

    //Поля
    let name = blank.createField({
        title: "Наименование",
        key: "NumberDoc",
        type: "string",
        width: 150,
    });
    let status = blank.createField({
        title: "Статус",
        key: "Status",
        reference: CardStatus,
        width: 150,
    });
    let responsible = blank.createField({
        title: "Ответственный",
        key: "Ответственный",
        reference: CardFileEmployee,
        width: 150,
    });
    let initiator = blank.createField({
        title: "Инициатор",
        key: "Инициатор",
        reference: CardFileEmployee,
        width: 190,
        disabled: true,
    });
    let baseDoc = blank.createField({
        title: "Основание",
        key: "Основание",
        type: "string",
        width: 190,
        disabled: true,
    });
    let serviceTerritory = blank.createField({
        title: "Сервисная территория",
        key: "СервиснаяТерритория",
        reference: CardServiceTerritory,
        width: 387,//407,
    });
    let client = blank.createField({
        title: "Клиент",
        key: "Клиент",
        reference: CardAccount,
        width: 190,
        isHierarchycal: false,
        initTree: false,
        constFilter: "ТипКлиента.Name = 'Клиент'",
    });
    let point = blank.createField({
        title: "Точка",
        key: "Точка",
        reference: CardAccount,
        width: 387,//382,//407,
        isHierarchycal: false,
        initTree: false,
        constFilter: "ТипКлиента.Name = 'Торговая точка'",
    });
    let description = blank.createField({
        title: "Описание",
        key: "Описание",
        type: "textarea",
        width: 780,//407,
        height: 75,
    });

    //Комментарии
    const commentsActivity = CommentsActivity({
        targetClass: "C4C.Документы.Обращение",
        docid,
        comments: props?.Comments,
    });

    //Подтаблица
    const lifeCycle = [
        {
            id: "ДатаСобытия",
            text: "Дата cобытия",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 255,
            type: "string",
            disabled: true,
        },
        {
            id: "Persona",
            text: "Исполнитель",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 255,
            reference: CardFileEmployee,
            disabled: true,
        },
        {
            id: "ОписаниеСобытия",
            text: "Описание события",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 269,//319,
            type: "string",
            disabled: true,
        },
    ];

    const tableLifeCycle = blank.createTable({
        column_props: lifeCycle,
        width: 300,
        key: "ЖизненныйЦикл",
        disableContextMenu: true,
    });

    let addRowLifeCycle = html`<button
        class="add-button"
        type="button"
    ></button>`;
    addRowLifeCycle.addEventListener("click", (e) => {
        e.preventDefault();
        tableLifeCycle.createEmptyRow();
    });

    //Загрузка файлов
    const filesUploadField = new FilesUploadField({
        onSaveFile: ({ name, data }) => {
            const targetClass = "C4C.Документы.Обращения";
            const additional = {targetClass, docid}; 
            return uploadFile({
                name,
                data,
                additional,
            }
            );
        },
        confirmUpload: false,
        onDeleteFile: deleteFile,
        addFileBtnText: "Добавить",
        uploadFilesBtnText: "Сохранить",
        title: "Файлы",
    });

    if (docid != null && docid > 0) {
        getFilesList({
            docid,
            targetClass: "C4C.Документы.Обращения",
        }).then((res) => {
            filesUploadField.setFiles(res.data.data);
        });
    }

    const fileElement = html` ${docid != null
        ? filesUploadField.render()
        : undefined}`;


    //Вкладки
    let mainDataItem = mainData({
        baseDoc,
        initiator,
        serviceTerritory,
        client,
        point,
        description,
        fileElement,
        commentsActivity,
    });

    let tabs = html`
    <div class="blank-tabcontent"></div>
    `;
    
    let browseTabContentO = o();
    let additionalInfoTabContentO = o();

    const hideAdditionalInfoTabContent = o(false);
    let browseTabContent = html`
        ${mainDataItem}
    `;
    browseTabContentO(browseTabContent);
    let additionalInfoTabContent = html`
        ${tableLifeCycle}
    `;
    additionalInfoTabContentO(additionalInfoTabContent);
    if (hideAdditionalInfoTabContent()) hideAdditionalInfoTabContent(false);
    const mainTabType = {
        browse: { index: 0, name: "Обзор" },
        additionalInfo: { index: 0, name: "Доп. информация" },
    };
    let mainTabView = TabView();

    mainTabView.addTab(
        mainTabType.browse.name,
        browseTabContentO
    );
    mainTabView.addTab(
        mainTabType.additionalInfo.name,
        additionalInfoTabContentO
    );

    mainTabView.style.overflow = "auto";
    mainTabView.getTab(0).isActive();
    tabs.append(mainTabView);

    //Элементы
    let headerRow = blank.createRow();
    headerRow.addItems([name, status, responsible,]);
    blank.addHeaderLeftItem(headerRow);
    blank.addItems([tabs]);

    //При считывании бланка
    blank.addEventListener("connected", async () => {
        if (!docid)
        {
            const recStatus = await getRecord$1("BaseInt.Status",6);
            if (recStatus)
                status.setValue(recStatus);
            const recUser = await getRecord$1("BaseInt.Справочники.Persona",getUserId());
            if (recUser){
                initiator.setValue(recUser);
                responsible.setValue(recUser);
            }
        }
    });

    return blank;
};

const mainData = (fields) => {
    return html`
        <div class="blank-basicdata">
            <div class="blank-row">
                ${fields.baseDoc}
                ${fields.initiator}
                ${fields.client}
            </div>
            <div class="blank-row">
                ${fields.serviceTerritory} ${fields.point}
            </div>
            <div class="blank-row">
               
            </div>
            <div class="blank-row">
                ${fields.description}
            </div>
            <div class="blank-row">
                ${fields.fileElement}
            </div>
            <div class="blank-row">
                ${fields.commentsActivity}
            </div>
        </div>
    `;
};

const settings$1 = {
    targetClass: "C4C.Документы.Обращения",
    rootName: "Обращения",
    urlPath: "Appeals",
    __projectId__: 3487,
};

const CardAppeals = (props) => {
  //  let tableHelper = TableHelper();

    getUserId();

    let column_props = [
        {
            id: "CreateDate",
            text: "Дата создания",
            order: "CreateDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },
        {
            id: "NumberDoc",
            text: "Наименование",
            order: "NumberDoc",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },
        {
            id: "Описание",
            text: "Описание",
            order: "Описание",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },
        {
            id: "Status",
            text: "Статус",
            order: "Status.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 120,
            reference: CardStatus,
            callback: (data, rowData) => {
                const element = html`<span>${data}</span>`;
                const setColor = () => {
                    const tableCell = element.closest(".table-cell");
                    if (!tableCell) return;
                    tableCell.style.backgroundColor = rowData.StatusColor;
                };
                if (rowData.StatusColor) {
                    observe(element);
                    element.addEventListener("connected", setColor);
                    element.addEventListener("disconnected", () => {
                        element.removeEventListener("connected", setColor);
                        unobserve(element);
                    });
                }
                return element;
            },
        },
        {
            id: "Ответственный",
            text: "Ответственный",
            order: "Ответственный",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },
        {
            id: "Клиент",
            text: "Клиент",
            order: "Клиент.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },
        {
            id: "Точка",
            text: "Точка",
            order: "Точка.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },
        {
            id: "СервиснаяТерритория",
            text: "Сервисная территория",
            order: "СервиснаяТерритория.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },
        {
            id: "Инициатор",
            text: "Инициатор",
            order: "Инициатор.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 200,
        },
        {
            id: "OperDate",
            text: "Дата обращения",
            order: "OperDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 160,
        },

    ];

    let cardFile = CardFile({
        ...settings$1,
        ...props,
        cardWidth: 85,
        column_props: column_props,
        inModal: props?.inModal,
        callBackElement: props?.callBackElement,
        order: "CreateDate-",
    });

    cardFile.setBlank(BlankAppeals);

    cardFile.urlPath = settings$1.urlPath;


    return cardFile;
};

CardAppeals.settings = settings$1;

const routes$4 = {
    members: new CardFileRoute({
        cardfile: "members",
        element: CardFileEmployee,
        header: "Участники",
    }),
    [CardStatus.settings.urlPath]: new CardFileRoute({
        cardfile: CardStatus.settings.urlPath,
        element: CardStatus,
        header: "Статусы",
    }),
    roles: new CardFileRoute({
        cardfile: "roles",
        element: CardRoles,
        header: "Роли",
    }),
    ControlCommand: new CardFileRoute({
        cardfile: "ControlCommand",
        element: CardFileControlCommand,
        header: "Команды управления",
    }),
    InterfacePanel: new CardFileRoute({
        cardfile: "InterfacePanel",
        element: CardFileInterfacePanel,
        header: "Интерфейсная панель",
    }),
    commonFile: new CardFileRoute({
        cardfile: "commonFile",
        element: CardCommonFile,
        header: "Общие  файлы",
    }),
    attachmentType: new CardFileRoute({
        cardfile: "attachmentType",
        element: CardFileAttachmentType,
        header: "Тип прикладываемого файла",
    }),
    files: new CardFileRoute({
        cardfile: "files",
        element: CardFileArchive,
        header: "Файлы",
    }),
    DataStructure: new CardFileRoute({
        cardfile: "DataStructure",
        element: CardDataStructure,
        header: "Структура данных",
    }),
 
    // C4C
    [CardSource.settings.urlPath]: new CardFileRoute({
        element: CardSource,
    }),
    [CardCategory.settings.urlPath]: new CardFileRoute({
        element: CardCategory,
    }),
    [CardRegion.settings.urlPath]: new CardFileRoute({
        element: CardRegion,
    }),
    [CardCustomerCategory.settings.urlPath]: new CardFileRoute({
        element: CardCustomerCategory,
    }),
    [CardCustomerSegment.settings.urlPath]: new CardFileRoute({
        element: CardCustomerSegment,
    }),
    [CardMA.settings.urlPath]: new CardFileRoute({
        element: CardMA,
    }),
    [CardLead.settings.urlPath]: new CardFileRoute({
        element: CardLead,
    }),
    [CardContactRole.settings.urlPath]: new CardFileRoute({
        element: CardContactRole,
    }),
    [CardContactFunction.settings.urlPath]: new CardFileRoute({
        element: CardContactFunction,
    }),
    [CardCommunicationMethod.settings.urlPath]: new CardFileRoute({
        element: CardCommunicationMethod,
    }),
    [CardPriority.settings.urlPath]: new CardFileRoute({
        element: CardPriority,
    }),
    [CardLanguage.settings.urlPath]: new CardFileRoute({
        element: CardLanguage,
    }),
    [CardContactType.settings.urlPath]: new CardFileRoute({
        element: CardContactType,
    }),
    [CardDepartament.settings.urlPath]: new CardFileRoute({
        element: CardDepartament,
    }),
    [CardContactTitle.settings.urlPath]: new CardFileRoute({
        element: CardContactTitle,
    }),
    [CardAccountType.settings.urlPath]: new CardFileRoute({
        element: CardAccountType,
    }),
    [CardRouteToMarketType.settings.urlPath]: new CardFileRoute({
        element: CardRouteToMarketType,
    }),
    [CardPOCMetric.settings.urlPath]: new CardFileRoute({
        element: CardPOCMetric,
    }),
    [CardSalesMetric.settings.urlPath]: new CardFileRoute({
        element: CardSalesMetric,
    }),
    [CardSalesMetricNumber.settings.urlPath]: new CardFileRoute({
        element: CardSalesMetricNumber,
    }),
    [CardOperatingDaysPerWeek.settings.urlPath]: new CardFileRoute({
        element: CardOperatingDaysPerWeek,
    }),
    [CardPrimaryConsumers.settings.urlPath]: new CardFileRoute({
        element: CardPrimaryConsumers,
    }),
    [CardExistingBeverageMachines.settings.urlPath]: new CardFileRoute({
        element: CardExistingBeverageMachines,
    }),
    [CardBeverageNeeds.settings.urlPath]: new CardFileRoute({
        element: CardBeverageNeeds,
    }),
    [CardAccountClassification.settings.urlPath]: new CardFileRoute({
        element: CardAccountClassification,
    }),
    [CardIndustry.settings.urlPath]: new CardFileRoute({
        element: CardIndustry,
    }),
    [CardBrandedMenu.settings.urlPath]: new CardFileRoute({
        element: CardBrandedMenu,
    }),
    [CardSelfService.settings.urlPath]: new CardFileRoute({
        element: CardSelfService,
    }),
    [CardCoffeeToBeGivenAway.settings.urlPath]: new CardFileRoute({
        element: CardCoffeeToBeGivenAway,
    }),
    [CardExpectedValueCurrency.settings.urlPath]: new CardFileRoute({
        element: CardExpectedValueCurrency,
    }),
    [CardLikelyPurchaseDate.settings.urlPath]: new CardFileRoute({
        element: CardLikelyPurchaseDate, 
    }),
    [CardSalesOrganization.settings.urlPath]: new CardFileRoute({
        element: CardSalesOrganization,
    }),
    [CardDistributionChannel.settings.urlPath]: new CardFileRoute({
        element: CardDistributionChannel,
    }),
    [CardDivision.settings.urlPath]: new CardFileRoute({
        element: CardDivision,
    }),
    [CardSalesUnit.settings.urlPath]: new CardFileRoute({
        element: CardSalesUnit,
    }),
    [CardOwner.settings.urlPath]: new CardFileRoute({
        element: CardOwner,
    }),
    [CardSalesTeam.settings.urlPath]: new CardFileRoute({
        element: CardSalesTeam,
    }),
    [CardLeadAssignTo.settings.urlPath]: new CardFileRoute({
        element: CardLeadAssignTo,
    }),
    [CardAccount.settings.urlPath]: new CardFileRoute({
        element: CardAccount,
    }),
    [CardActivity.settings.urlPath]: new CardFileRoute({
        element: CardActivity,
    }),
    [CardActivityType.settings.urlPath]: new CardFileRoute({
        element: CardActivityType,
    }),
    [CardReasonForDeviation.settings.urlPath]: new CardFileRoute({
        element: CardReasonForDeviation,
    }),
    [CardServiceRequestType.settings.urlPath]: new CardFileRoute({
        element: CardServiceRequestType,
    }),
    [CardServiceRequest.settings.urlPath]: new CardFileRoute({
        element: CardServiceRequest,
    }),
    [CardClientType.settings.urlPath]: new CardFileRoute({
        element: CardClientType,
    }),
    [CardInstallationLocation.settings.urlPath]: new CardFileRoute({
        element: CardInstallationLocation,
    }),
    [CardEquipmentModel.settings.urlPath]: new CardFileRoute({
        element: CardEquipmentModel,
    }),
    [CardWorkOrder.settings.urlPath]: new CardFileRoute({
        element: CardWorkOrder,
    }),
    [CardEquipment.settings.urlPath]: new CardFileRoute({
        element: CardEquipment,
    }),
    [CardOpportunity.settings.urlPath]: new CardFileRoute({
        element: CardOpportunity,
    }),
    [CardReceptionEquipment.settings.urlPath]: new CardFileRoute({
        element: CardReceptionEquipment,
    }),
    [CardMovementType.settings.urlPath]: new CardFileRoute({
        element: CardMovementType,
    }),
    [CardContactPerson.settings.urlPath]: new CardFileRoute({
        element: CardContactPerson,
    }),
    [CardSalesPhase.settings.urlPath]: new CardFileRoute({
        element: CardSalesPhase,
    }),
    [CardFileMessage.settings.urlPath]: new CardFileRoute({
        element: CardFileMessage,
    }),
    [CardFileNotificationTemplate.settings.urlPath]: new CardFileRoute({
        element: CardFileNotificationTemplate,
    }),
    [CardEquipCategory.settings.urlPath]: new CardFileRoute({
        element: CardEquipCategory,
    }),
    [CardEquipmentPosition.settings.urlPath]: new CardFileRoute({
        element: CardEquipmentPosition,
    }),
    [CardReasonForVictory.settings.urlPath]: new CardFileRoute({
        element: CardReasonForVictory,
    }),
    [CardReasonForLosing.settings.urlPath]: new CardFileRoute({
        element: CardReasonForLosing,
    }),
    [CardParameter.settings.urlPath]: new CardFileRoute({
        element: CardParameter,
    }),
    [CardReasonForMovement.settings.urlPath]: new CardFileRoute({
        element: CardReasonForMovement,
    }),
    [CardStorageArea.settings.urlPath]: new CardFileRoute({
        element: CardStorageArea,
    }),
    [CardInternalMovement.settings.urlPath]: new CardFileRoute({
        element: CardInternalMovement,
    }),
    [CardServiceTerritory.settings.urlPath]: new CardFileRoute({
        element: CardServiceTerritory,
    }),
    [CardStatusEquipment.settings.urlPath]: new CardFileRoute({
        element: CardStatusEquipment,
    }),
    [CardFileType.settings.urlPath]: new CardFileRoute({
        element: CardFileType,
    }),
    [CardLegalType.settings.urlPath]: new CardFileRoute({
        element: CardLegalType,
    }),
    [CardVisitRoute.settings.urlPath]: new CardFileRoute({
        element: CardVisitRoute,
    }),
    [CardAppeals.settings.urlPath]: new CardFileRoute({
        element: CardAppeals,
    }),
    [CardHolding.settings.urlPath]: new CardFileRoute({
        element: CardHolding,
    }),

};

window.cardFilesList = routes$4;

const pageAdditionalTitle = o();

// import style

const CardFiles = () => {
    const cardFile = o(undefined);
    const header = o(undefined);
    let lastView = new View$4();

    const onRouteChange = ({ component, match, key }) => {
        const currentView = new View$4(key, match?.groups?.params);
        if (lastView.isEqual(currentView)) return;

        if (!lastView.pathIsEqual(currentView)) {
            cardFile(component({ cardFilesList: routes$4 }));
            header(routes$4[key].header);
        }
        lastView = currentView;
        const params = getSearchParams(currentView.params);

        if (params.id) {
            const docid = Number(params.id);
            if (isNaN(docid) || !docid) return;
            cardFile()?.viewRecord?.({ docid });
        } else if (
            params.projectId &&
            currentView.path?.toLowerCase() === "openTickets".toLowerCase()
        ) {
            createNewTask(params);
        } else {
            cardFile()?.hideBlank?.();
        }

        pageAdditionalTitle(routes$4[key].title);
    };

    // output element architecture
    const element = html$1`<${Router} routes=${routes$4} onChange=${onRouteChange}>
        <div class="card-file-view">
            <h1 style="display:none">${header}</h1>
            ${cardFile}
        </div>
    <//>`;

    return element;
};

//import { Report01 } from "../components/C4C/Reports/Rep01";

const routes$3 = {
    // consumption: new ServiceRoute({
    //     service: "consumption",
    //     element: consumption,
    //     //header: "125 - Контроль рабочего времени сотрудника",
    // }),
    
    // report01: new ServiceRoute({
    //     service: "report01",
    //     element: Report01,    
    // }),

};

const Services = () => {
    const serviceElement = o();
    const title = o();
    let lastView = new View$4();
    const onRouteChange = ({ component, match, key }) => {
        const currentView = new View$4(key, match?.groups?.params);
        if (lastView.isEqual(currentView)) return;
        lastView = currentView;
        const params = getSearchParams(currentView.params);
        serviceElement(component(params));
        if (key != "projectKanban") {
            title(routes$3[key].title);
        }
        pageAdditionalTitle(routes$3[key].title);
    };

    const element = html`<${Router} routes=${routes$3} onChange=${onRouteChange}>
        <div class="service-view">
            ${serviceElement}
        </div>
    <//>`;

    return element;
};

async function getRecord(targetClass, docid, signal, options = {}) {
    let body = {
        targetClass,
        docid,
    };
    return executeQuery("GetRecord", { body, signal, ...options })
        .then((res) => res.json())
        .catch((error) => {
            return error;
        });
}

const Home = () => {
    const state = {
        messages: o([]),
        onlyNew: o(false),
        searchString: o(""),
    };


    const SearchField = () => {
        /**@type {HTMLElement} */
        const element = html`<label
            class="field-v2 search-field"
        >
        <input
            class="field-v2-input"
            onchange=${initialize}
            oninput=${(ev) => state.searchString(ev.target.value)}
        />

        </label>`;
    
        return element;
    };

   
    const renderList = () => {
        if (state.messages().length === 0) {
            return html` 
            <span>Сообщений нет</span>`;
        }

        return html`<div class="messages-list scrollable">
            ${map(state.messages, Message)}
        </div> `;
    };

    function onFilterBtnClick() {
        state.onlyNew(!state.onlyNew());
        initialize();

    }

    const dashboard = html`<div class="dashboard">
        <!-- // сначала показываем строку для поиска и быстрого фильтра по новым сообщения -->
        <div style="display: flex; flex-direction: column; overflow: hidden;">
            <div class="filter-control">
                ${SearchField}
                <${Button} class="circle filter-btn${() => state.onlyNew() ? "" : " transparent" }" onClick=${onFilterBtnClick}>
                    <${Icon} name="angles-down"/>
                <//>
            </div>
            ${renderList}
        </div>
        
    </div>`;
    observe(dashboard);

    dashboard.addEventListener("connected", initialize);

    async function initialize() {
        const [messagesResult] = await Promise.all([getInternalMessage(state.searchString() , state.onlyNew())]);
        if (!(messagesResult instanceof Error)) {
            state.messages(Object.values(messagesResult));
        }
    }

    return dashboard;
};

const Message = (data) => {
    const status = o(data.Status);

    const loader = Loader();
    const modal = Modal();

    const message = html`
        <div class="message" data-id=${data.docid}>
            <div class="message-status${() => status() === false ? ' new' : ''}"/>
            <div class="message-content"> 
                <div class=${() => status() === false ? 'message-subject-newMessage' : 'message-subject'}>${html(data.Subject ?? "")}</div>
                <div class=${() => status() === false ? 'message-text' : 'message-text'}>${html(data.BodyInternalMessage ?? "")}</div>
                <div class=${() => status() === false ? 'message-time' : 'message-time'}>${html(data.CreateDate ?? "")}</div>
            </div>
        </div>
    `;

    async function openBlank(id, type) {
        loader.show();
        try {
            let dataDoc;
            let blank;
            switch (type) {
                case "Документы.Lead":
                    dataDoc = await getRecord("C4C.Документы.Lead",id);
                    blank = BlankLead(Object.assign(dataDoc),id);
                    break;
                case "Документы.Возможность":
                    dataDoc = await getRecord("C4C.Документы.Возможность",id);
                    blank = BlankOpportunity(Object.assign(dataDoc),id);
                    break;
                case "Документы.Наряд":
                    dataDoc = await getRecord("C4C.Документы.Наряд",id);
                    blank = BlankWorkOrder(Object.assign(dataDoc),id);
                    break;
                case "Документы.СервисныйЗапрос":
                    dataDoc = await getRecord("C4C.Документы.СервисныйЗапрос",id);
                    blank = BlankServiceRequest(Object.assign(dataDoc),id);
                    break;
                case "Документы.Активность":
                    dataDoc = await getRecord("C4C.Документы.Активность",id);
                    blank = BlankActivity(Object.assign(dataDoc),id);
                    break;                                   
            }
            modal.setContent(blank);
            modal.show();

            blank.cancelButtonAction = () => modal.hide();
            blank.applyButtonAction = () => {
                    createOrUpdateRecord(
                    "C4C."+type,
                    blank.getData()
                ).then(async (res) => {
                    if (res.isOk) {
                        modal.hide();               
                    }
                });            
            };
            blank.refreshData = (id) => {
                openBlank(id, type);
            };
        } catch (error) {
            console.error(error);
        } finally {
            loader.hide();
        }
    }

    message.addEventListener("click", (ev) => {
        // При первом клике, мы должны пометить сообщение как прочитанное.
        // Если не прочитано, отправим запрос на сервер
        if (data.Status === false) {
            setInternalMessageRead(data.docid).then((result) => {
                status(true);
            });
        }
    });

    message.addEventListener("dblclick", (ev) => {
        openBlank(data.IdDoc , data.base);
    });


    return message;
};

function noop() { }
const identity = x => x;
function assign$1(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
function is_empty(obj) {
    return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
    if (store == null) {
        return noop;
    }
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
    let value;
    subscribe(store, _ => value = _)();
    return value;
}
function component_subscribe(component, store, callback) {
    component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
    }
}
function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn
        ? assign$1($$scope.ctx.slice(), definition[1](fn(ctx)))
        : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty === undefined) {
            return lets;
        }
        if (typeof lets === 'object') {
            const merged = [];
            const len = Math.max($$scope.dirty.length, lets.length);
            for (let i = 0; i < len; i += 1) {
                merged[i] = $$scope.dirty[i] | lets[i];
            }
            return merged;
        }
        return $$scope.dirty | lets;
    }
    return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
    if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
    }
}
function get_all_dirty_from_scope($$scope) {
    if ($$scope.ctx.length > 32) {
        const dirty = [];
        const length = $$scope.ctx.length / 32;
        for (let i = 0; i < length; i++) {
            dirty[i] = -1;
        }
        return dirty;
    }
    return -1;
}
function set_store_value(store, ret, value) {
    store.set(value);
    return ret;
}
function action_destroyer(action_result) {
    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

const globals = (typeof window !== 'undefined'
    ? window
    : typeof globalThis !== 'undefined'
        ? globalThis
        : global);
function append(target, node) {
    target.appendChild(node);
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function detach(node) {
    if (node.parentNode) {
        node.parentNode.removeChild(node);
    }
}
function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
            iterations[i].d(detaching);
    }
}
function element(name) {
    return document.createElement(name);
}
function text(data) {
    return document.createTextNode(data);
}
function space() {
    return text(' ');
}
function empty() {
    return text('');
}
function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
}
function stop_propagation(fn) {
    return function (event) {
        event.stopPropagation();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function children(element) {
    return Array.from(element.childNodes);
}
function set_data(text, data) {
    data = '' + data;
    if (text.data === data)
        return;
    text.data = data;
}
function set_style(node, key, value, important) {
    if (value == null) {
        node.style.removeProperty(key);
    }
    else {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, bubbles, cancelable, detail);
    return e;
}
function construct_svelte_component(component, props) {
    return new component(props);
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error('Function called outside component initialization');
    return current_component;
}
/**
 * Schedules a callback to run immediately before the component is updated after any state change.
 *
 * The first time the callback runs will be before the initial `onMount`
 *
 * https://svelte.dev/docs#run-time-svelte-beforeupdate
 */
function beforeUpdate(fn) {
    get_current_component().$$.before_update.push(fn);
}
/**
 * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
 * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
 * it can be called from an external module).
 *
 * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).
 *
 * https://svelte.dev/docs#run-time-svelte-onmount
 */
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}
/**
 * Schedules a callback to run immediately after the component has been updated.
 *
 * The first time the callback runs will be after the initial `onMount`
 */
function afterUpdate(fn) {
    get_current_component().$$.after_update.push(fn);
}
/**
 * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).
 * Event dispatchers are functions that can take two arguments: `name` and `detail`.
 *
 * Component events created with `createEventDispatcher` create a
 * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
 * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
 * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
 * property and can contain any type of data.
 *
 * https://svelte.dev/docs#run-time-svelte-createeventdispatcher
 */
function createEventDispatcher() {
    const component = get_current_component();
    return (type, detail, { cancelable = false } = {}) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
            // TODO are there situations where events could be dispatched
            // in a server (non-DOM) environment?
            const event = custom_event(type, detail, { cancelable });
            callbacks.slice().forEach(fn => {
                fn.call(component, event);
            });
            return !event.defaultPrevented;
        }
        return true;
    };
}
/**
 * Associates an arbitrary `context` object with the current component and the specified `key`
 * and returns that object. The context is then available to children of the component
 * (including slotted content) with `getContext`.
 *
 * Like lifecycle functions, this must be called during component initialisation.
 *
 * https://svelte.dev/docs#run-time-svelte-setcontext
 */
function setContext(key, context) {
    get_current_component().$$.context.set(key, context);
    return context;
}
/**
 * Retrieves the context that belongs to the closest parent component with the specified `key`.
 * Must be called during component initialisation.
 *
 * https://svelte.dev/docs#run-time-svelte-getcontext
 */
function getContext(key) {
    return get_current_component().$$.context.get(key);
}
// TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism
function bubble(component, event) {
    const callbacks = component.$$.callbacks[event.type];
    if (callbacks) {
        // @ts-ignore
        callbacks.slice().forEach(fn => fn.call(this, event));
    }
}

const dirty_components = [];
const binding_callbacks = [];
let render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = /* @__PURE__ */ Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function tick() {
    schedule_update();
    return resolved_promise;
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
// flush() calls callbacks in this order:
// 1. All beforeUpdate callbacks, in order: parents before children
// 2. All bind:this callbacks, in reverse order: children before parents.
// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
//    for afterUpdates called during the initial onMount, which are called in
//    reverse order: children before parents.
// Since callbacks might update component values, which could trigger another
// call to flush(), the following steps guard against this:
// 1. During beforeUpdate, any updated components will be added to the
//    dirty_components array and will cause a reentrant call to flush(). Because
//    the flush index is kept outside the function, the reentrant call will pick
//    up where the earlier call left off and go through all dirty components. The
//    current_component value is saved and restored so that the reentrant call will
//    not interfere with the "parent" flush() call.
// 2. bind:this callbacks cannot trigger new flush() calls.
// 3. During afterUpdate, any updated components will NOT have their afterUpdate
//    callback called a second time; the seen_callbacks set, outside the flush()
//    function, guarantees this behavior.
const seen_callbacks = new Set();
let flushidx = 0; // Do *not* move this inside the flush() function
function flush() {
    // Do not reenter flush while dirty components are updated, as this can
    // result in an infinite loop. Instead, let the inner flush handle it.
    // Reentrancy is ok afterwards for bindings etc.
    if (flushidx !== 0) {
        return;
    }
    const saved_component = current_component;
    do {
        // first, call beforeUpdate functions
        // and update components
        try {
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update(component.$$);
            }
        }
        catch (e) {
            // reset dirty state to not end up in a deadlocked state and then rethrow
            dirty_components.length = 0;
            flushidx = 0;
            throw e;
        }
        set_current_component(null);
        dirty_components.length = 0;
        flushidx = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    seen_callbacks.clear();
    set_current_component(saved_component);
}
function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}
/**
 * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.
 */
function flush_render_callbacks(fns) {
    const filtered = [];
    const targets = [];
    render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
    targets.forEach((c) => c());
    render_callbacks = filtered;
}
const outroing = new Set();
let outros;
function group_outros() {
    outros = {
        r: 0,
        c: [],
        p: outros // parent group
    };
}
function check_outros() {
    if (!outros.r) {
        run_all(outros.c);
    }
    outros = outros.p;
}
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function transition_out(block, local, detach, callback) {
    if (block && block.o) {
        if (outroing.has(block))
            return;
        outroing.add(block);
        outros.c.push(() => {
            outroing.delete(block);
            if (callback) {
                if (detach)
                    block.d(1);
                callback();
            }
        });
        block.o(local);
    }
    else if (callback) {
        callback();
    }
}
function outro_and_destroy_block(block, lookup) {
    transition_out(block, 1, 1, () => {
        lookup.delete(block.key);
    });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
    let o = old_blocks.length;
    let n = list.length;
    let i = o;
    const old_indexes = {};
    while (i--)
        old_indexes[old_blocks[i].key] = i;
    const new_blocks = [];
    const new_lookup = new Map();
    const deltas = new Map();
    const updates = [];
    i = n;
    while (i--) {
        const child_ctx = get_context(ctx, list, i);
        const key = get_key(child_ctx);
        let block = lookup.get(key);
        if (!block) {
            block = create_each_block(key, child_ctx);
            block.c();
        }
        else if (dynamic) {
            // defer updates until all the DOM shuffling is done
            updates.push(() => block.p(child_ctx, dirty));
        }
        new_lookup.set(key, new_blocks[i] = block);
        if (key in old_indexes)
            deltas.set(key, Math.abs(i - old_indexes[key]));
    }
    const will_move = new Set();
    const did_move = new Set();
    function insert(block) {
        transition_in(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n--;
    }
    while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;
        if (new_block === old_block) {
            // do nothing
            next = new_block.first;
            o--;
            n--;
        }
        else if (!new_lookup.has(old_key)) {
            // remove old block
            destroy(old_block, lookup);
            o--;
        }
        else if (!lookup.has(new_key) || will_move.has(new_key)) {
            insert(new_block);
        }
        else if (did_move.has(old_key)) {
            o--;
        }
        else if (deltas.get(new_key) > deltas.get(old_key)) {
            did_move.add(new_key);
            insert(new_block);
        }
        else {
            will_move.add(old_key);
            o--;
        }
    }
    while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key))
            destroy(old_block, lookup);
    }
    while (n)
        insert(new_blocks[n - 1]);
    run_all(updates);
    return new_blocks;
}
function create_component(block) {
    block && block.c();
}
function mount_component(component, target, anchor, customElement) {
    const { fragment, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    if (!customElement) {
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
            // if the component was destroyed immediately
            // it will update the `$$.on_destroy` reference to `null`.
            // the destructured on_destroy may still reference to the old array
            if (component.$$.on_destroy) {
                component.$$.on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
    }
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        flush_render_callbacks($$.after_update);
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
        fragment: null,
        ctx: [],
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false,
        root: options.target || parent_component.$$.root
    };
    append_styles && append_styles($$.root);
    let ready = false;
    $$.ctx = instance
        ? instance(component, options.props || {}, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor, options.customElement);
        flush();
    }
    set_current_component(parent_component);
}
/**
 * Base class for Svelte components. Used when dev=false.
 */
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        if (!is_function(callback)) {
            return noop;
        }
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

const subscriber_queue = [];
/**
 * Creates a `Readable` store that allows reading by subscription.
 * @param value initial value
 * @param {StartStopNotifier} [start]
 */
function readable(value, start) {
    return {
        subscribe: writable(value, start).subscribe
    };
}
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=} start
 */
function writable(value, start = noop) {
    let stop;
    const subscribers = new Set();
    function set(new_value) {
        if (safe_not_equal(value, new_value)) {
            value = new_value;
            if (stop) { // store is ready
                const run_queue = !subscriber_queue.length;
                for (const subscriber of subscribers) {
                    subscriber[1]();
                    subscriber_queue.push(subscriber, value);
                }
                if (run_queue) {
                    for (let i = 0; i < subscriber_queue.length; i += 2) {
                        subscriber_queue[i][0](subscriber_queue[i + 1]);
                    }
                    subscriber_queue.length = 0;
                }
            }
        }
    }
    function update(fn) {
        set(fn(value));
    }
    function subscribe(run, invalidate = noop) {
        const subscriber = [run, invalidate];
        subscribers.add(subscriber);
        if (subscribers.size === 1) {
            stop = start(set) || noop;
        }
        run(value);
        return () => {
            subscribers.delete(subscriber);
            if (subscribers.size === 0 && stop) {
                stop();
                stop = null;
            }
        };
    }
    return { set, update, subscribe };
}
function derived(stores, fn, initial_value) {
    const single = !Array.isArray(stores);
    const stores_array = single
        ? [stores]
        : stores;
    const auto = fn.length < 2;
    return readable(initial_value, (set) => {
        let started = false;
        const values = [];
        let pending = 0;
        let cleanup = noop;
        const sync = () => {
            if (pending) {
                return;
            }
            cleanup();
            const result = fn(single ? values[0] : values, set);
            if (auto) {
                set(result);
            }
            else {
                cleanup = is_function(result) ? result : noop;
            }
        };
        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
            values[i] = value;
            pending &= ~(1 << i);
            if (started) {
                sync();
            }
        }, () => {
            pending |= (1 << i);
        }));
        started = true;
        sync();
        return function stop() {
            run_all(unsubscribers);
            cleanup();
            // We need to set this to false because callbacks can still happen despite having unsubscribed:
            // Callbacks might already be placed in the queue which doesn't know it should no longer
            // invoke this derived store.
            started = false;
        };
    });
}

function assign(...args) {
    return Object.assign(...args);
}

function isObject$1(test) {
    return typeof test === 'object' && test !== null;
}

function symbol() {
    return Symbol('ec');
}

function setContent$1(node, content) {
    let actions = {
        update(content) {
            while (node.firstChild) {
                node.removeChild(node.lastChild);
            }
            if (!isObject$1(content)) {
                node.innerText = content;
            } else if (content.domNodes) {
                for (let child of content.domNodes) {
                    node.appendChild(child);
                }
            } else if (content.html) {
                node.innerHTML = content.html;
            }
        }
    };
    actions.update(content);

    return actions;
}

/** Dispatch event occurred outside of node */
function outsideEvent(node, type) {

    const handlePointerDown = jsEvent => {
        if (node && !node.contains(jsEvent.target)) {
            node.dispatchEvent(
                new CustomEvent(type + 'outside', {detail: {jsEvent}})
            );
        }
    };

    document.addEventListener(type, handlePointerDown, true);

    return {
        destroy() {
            document.removeEventListener(type, handlePointerDown, true);
        }
    };
}

const DAY_IN_SECONDS = 86400;

function createDate(input) {
    if (input !== undefined) {
        return input instanceof Date ? _fromLocalDate(input) : _fromISOString(input);
    }

    return _fromLocalDate(new Date());
}

function createDuration(input) {
    if (typeof input === 'number') {
        input = {seconds: input};
    } else if (typeof input === 'string') {
        // Expected format hh[:mm[:ss]]
        let seconds = 0, exp = 2;
        for (let part of input.split(':', 3)) {
            seconds += parseInt(part, 10) * Math.pow(60, exp--);
        }
        input = {seconds};
    } else if (input instanceof Date) {
        input = {hours: input.getUTCHours(), minutes: input.getUTCMinutes(), seconds: input.getUTCSeconds()};
    }

    let weeks = input.weeks || input.week || 0;

    return {
        years: input.years || input.year || 0,
        months: input.months || input.month || 0,
        days: weeks * 7 + (input.days || input.day || 0),
        seconds: (input.hours || input.hour || 0) * 60 * 60 +
            (input.minutes || input.minute || 0) * 60 +
            (input.seconds || input.second || 0),
        inWeeks: !!weeks
    };
}

function cloneDate(date) {
    return new Date(date.getTime());
}

function addDuration(date, duration, x) {
    if (x === undefined) {
        x = 1;
    }
    date.setUTCFullYear(date.getUTCFullYear() + x * duration.years);
    let month = date.getUTCMonth() + x * duration.months;
    date.setUTCMonth(month);
    month %= 12;
    if (month < 0) {
        month += 12;
    }
    while (date.getUTCMonth() !== month) {
        subtractDay(date);
    }
    date.setUTCDate(date.getUTCDate() + x * duration.days);
    date.setUTCSeconds(date.getUTCSeconds() + x * duration.seconds);

    return date;
}

function subtractDuration(date, duration, x) {
    return addDuration(date, duration, x === undefined ? -1 : -x);
}

function addDay(date, x) {
    date.setUTCDate(date.getUTCDate() + (x === undefined ? 1 : x));

    return date;
}

function subtractDay(date, x) {
    return addDay(date, x === undefined ? -1 : -x);
}

function setMidnight(date) {
    date.setUTCHours(0, 0, 0, 0);

    return date;
}

function toLocalDate$1(date) {
    return new Date(
        date.getUTCFullYear(),
        date.getUTCMonth(),
        date.getUTCDate(),
        date.getUTCHours(),
        date.getUTCMinutes(),
        date.getUTCSeconds()
    );
}

function toISOString(date) {
    return date.toISOString().substring(0, 19);
}

function formatRange(start, end, intl) {
    if (start.getFullYear() !== end.getFullYear()) {
        return intl.format(start) + ' - ' + intl.format(end);
    }

    let diff = [];
    if (start.getMonth() !== end.getMonth()) {
        diff.push('month');
    }
    if (start.getDate() !== end.getDate()) {
        diff.push('day');
    }

    if (!diff.length) {
        return intl.format(start);
    }

    let opts1 = intl.resolvedOptions();
    let opts2 = {};
    for (let key of diff) {
        opts2[key] = opts1[key];
    }
    let intl2 = new Intl.DateTimeFormat(opts1.locale, opts2);

    let full1 = intl.format(start);
    let full2 = intl.format(end);
    let part1 = intl2.format(start);
    let part2 = intl2.format(end);

    let common = _commonChunks(full1, part1, full2, part2);
    if (common) {
        return common.head + part1 + ' - ' + part2 + common.tail;
    }

    return full1 + ' - ' + full2;
}

function datesEqual(date1, ...dates2) {
    return dates2.every(date2 => date1.getTime() === date2.getTime());
}

function nextClosestDay(date, day) {
    let diff = day - date.getUTCDay();
    date.setUTCDate(date.getUTCDate() + (diff >= 0 ? diff : diff + 7));
    return date;
}

function prevClosestDay(date, day) {
    let diff = day - date.getUTCDay();
    date.setUTCDate(date.getUTCDate() + (diff <= 0 ? diff : diff - 7));
    return date;
}

/**
 * Check whether given date is string which contains no time part
  */
function noTimePart(date) {
    return typeof date === 'string' && date.length <= 10;
}

/**
 * Private functions
 */

function _fromLocalDate(date) {
    return new Date(Date.UTC(
        date.getFullYear(),
        date.getMonth(),
        date.getDate(),
        date.getHours(),
        date.getMinutes(),
        date.getSeconds()
    ));
}

function _fromISOString(str) {
    const parts = str.match(/\d+/g);
    return new Date(Date.UTC(
        Number(parts[0]),
        Number(parts[1]) - 1,
        Number(parts[2]),
        Number(parts[3] || 0),
        Number(parts[4] || 0),
        Number(parts[5] || 0)
    ));
}

function _commonChunks(str1, substr1, str2, substr2) {
    let i = 0;
    while (i < str1.length) {
        let res1;
        [i, res1] = _cut(str1, substr1, i);
        if (!res1) {
            break;
        }

        let j = 0;
        while (j < str2.length) {
            let res2;
            [j, res2] = _cut(str2, substr2, j);
            if (!res2) {
                break;
            }

            if (res1.head === res2.head && res1.tail === res2.tail) {
                return res1;
            }
        }
    }

    return null
}

function _cut(str, substr, from) {
    let start = str.indexOf(substr, from);
    if (start >= 0) {
        let end = start + substr.length;

        return [end, {
            head: str.substr(0, start),
            tail: str.substr(end)
        }];
    }

    return [-1, null];
}

function debounce(fn, handle, queueStore) {
    queueStore.update(queue => queue.set(handle, fn));
}

function flushDebounce(queue) {
    run_all(queue);
    queue.clear();
}

function createElement(tag, className, html, text) {
    let el = document.createElement(tag);
    el.className = className;
    if (html) {
        el.innerHTML = html;
    } else if (text) {
        el.innerText = text;
    }
    return el;
}

function hasYScroll(el) {
    return el.scrollHeight > el.clientHeight;
}

function rect(el) {
    return el.getBoundingClientRect();
}

function ancestor(el, up) {
    while (up--) {
        el = el.parentElement;
    }
    return el;
}

function height(el) {
    return rect(el).height;
}

let fnProp = symbol();
function setFn(el, fn) {
    el[fnProp] = fn;
}

function hasFn(el) {
    return !!el[fnProp];
}

function runFn(el, ...args) {
    return el[fnProp](...args);
}

function createView(view, _viewTitle, _currentRange, _activeRange) {
    return {
        type: view,
        title: _viewTitle,
        currentStart: _currentRange.start,
        currentEnd: _currentRange.end,
        activeStart: _activeRange.start,
        activeEnd: _activeRange.end,
        calendar: undefined
    };
}

function toViewWithLocalDates(view) {
    view = assign({}, view);
    view.currentStart = toLocalDate$1(view.currentStart);
    view.currentEnd = toLocalDate$1(view.currentEnd);
    view.activeStart = toLocalDate$1(view.activeStart);
    view.activeEnd = toLocalDate$1(view.activeEnd);

    return view;
}

const display = ['background'];

let eventId = 1;
function createEvents(input) {
    return input.map(event => ({
        id: 'id' in event ? String(event.id) : `{generated-${eventId++}}`,
        resourceIds: Array.isArray(event.resourceIds)
            ? event.resourceIds.map(String)
            : ('resourceId' in event ? [String(event.resourceId)] : []),
        allDay: event.allDay ?? (noTimePart(event.start) && noTimePart(event.end)),
        start: createDate(event.start),
        end: createDate(event.end),
        title: event.title || '',
        titleHTML: event.titleHTML || '',
        editable: event.editable,
        startEditable: event.startEditable,
        durationEditable: event.durationEditable,
        display: display.includes(event.display) ? event.display : 'auto',
        extendedProps: event.extendedProps || {},
        backgroundColor: event.backgroundColor || event.color
    }));
}

function createEventSources(input) {
    return input.map(source => ({
        events: source.events,
        url: (source.url && source.url.trimEnd('&')) || '',
        method: (source.method && source.method.toUpperCase()) || 'GET',
        extraParams: source.extraParams || {}
    }));
}

function createEventChunk(event, start, end) {
    return {
        start: event.start > start ? event.start : start,
        end: event.end < end ? event.end : end,
        event
    };
}

function sortEventChunks(chunks) {
    // Sort by start date
    chunks.sort((a, b) => {
        if (a.start < b.start) {
            return -1;
        }
        if (a.start > b.start) {
            return 1;
        }
        return 0;
    });
}

/**
 * Prepare event chunks for month view and all-day slot in week view
 */
function prepareEventChunks(chunks, hiddenDays) {
    let longChunks = {};

    if (chunks.length) {
        sortEventChunks(chunks);

        let prevChunk;
        for (let chunk of chunks) {
            let dates = [];
            let date = setMidnight(cloneDate(chunk.start));
            while (chunk.end > date) {
                if (!hiddenDays.includes(date.getUTCDay())) {
                    dates.push(cloneDate(date));
                    if (dates.length > 1) {
                        let key = date.getTime();
                        if (longChunks[key]) {
                            longChunks[key].chunks.push(chunk);
                        } else {
                            longChunks[key] = {
                                sorted: false,
                                chunks: [chunk]
                            };
                        }
                    }
                }
                addDay(date);
            }
            if (dates.length) {
                chunk.date = dates[0];
                chunk.days = dates.length;
                chunk.dates = dates;
                if (chunk.start < dates[0]) {
                    chunk.start = dates[0];
                }
                if (setMidnight(cloneDate(chunk.end)) > dates[dates.length - 1]) {
                    chunk.end = dates[dates.length - 1];
                }
            } else {
                chunk.date = setMidnight(cloneDate(chunk.start));
                chunk.days = 1;
                chunk.dates = [chunk.date];
            }

            if (prevChunk && datesEqual(prevChunk.date, chunk.date)) {
                chunk.prev = prevChunk;
            }
            prevChunk = chunk;
        }
    }

    return longChunks;
}

function repositionEvent(chunk, longChunks, height) {
    chunk.top = 0;
    if (chunk.prev) {
        chunk.top = chunk.prev.bottom + 1;
    }
    chunk.bottom = chunk.top + height;
    let margin = 1;
    let key = chunk.date.getTime();
    if (longChunks[key]) {
        if (!longChunks[key].sorted) {
            longChunks[key].chunks.sort((a, b) => a.top - b.top);
            longChunks[key].sorted = true;
        }
        for (let longChunk of longChunks[key].chunks) {
            if (chunk.top < longChunk.bottom && chunk.bottom > longChunk.top) {
                let offset = longChunk.bottom - chunk.top + 1;
                margin += offset;
                chunk.top += offset;
                chunk.bottom += offset;
            }
        }
    }

    return margin;
}

function createEventContent(chunk, displayEventEnd, eventContent, theme, _intlEventTime, _view) {
    let timeText = _intlEventTime.format(chunk.start), content;
    if (displayEventEnd && chunk.event.display !== 'pointer') {
        timeText += ` - ${_intlEventTime.format(chunk.end)}`;
    }
    if (eventContent) {
        content = is_function(eventContent)
            ? eventContent({
                event: toEventWithLocalDates(chunk.event),
                timeText,
                view: toViewWithLocalDates(_view)
            })
            : eventContent;
    } else {
        switch (chunk.event.display) {
            case 'background':
                content = '';
                break;
            case 'pointer':
                content = {
                    domNodes: [createElement('div', theme.eventTime, null, timeText)]
                };
                break;
            default:
                content = {
                    domNodes: [
                        createElement('div', theme.eventTime, null, timeText),
                        createElement('div', theme.eventTitle, chunk.event.titleHTML, chunk.event.title)
                    ]
                };
        }
    }

    return [timeText, content];
}

function toEventWithLocalDates(event) {
    return _cloneEvent(event, toLocalDate$1);
}

function cloneEvent(event) {
    return _cloneEvent(event, cloneDate);
}

function _cloneEvent(event, dateFn) {
    event = assign({}, event);
    event.start = dateFn(event.start);
    event.end = dateFn(event.end);

    return event;
}

/**
 * Check whether the event intersects with the given date range and resource
 * @param event
 * @param start
 * @param end
 * @param [resource]
 * @param [timeMode]  Zero-length events should be allowed (@see https://github.com/vkurko/calendar/issues/50), except in time mode
 * @return boolean
 */
function eventIntersects(event, start, end, resource, timeMode) {
    return (
        event.start < end && event.end > start || !timeMode && datesEqual(event.start, event.end, start)
    ) && (
        resource === undefined || event.resourceIds.includes(resource.id)
    );
}

let ignoreProp = symbol();
function ignore(jsEvent) {
    jsEvent[ignoreProp] = true;
}

function maybeIgnore(fn) {
    return jsEvent => {
        if (!jsEvent[ignoreProp]) {
            fn && fn(jsEvent);
            // Make upper listeners ignore the event
            ignore(jsEvent);
        }
    };
}

function writable2(value, parser, start) {
    return {
        ...writable(parser ? parser(value) : value, start),
        parse: parser
    };
}

function derived2(stores, fn, initValue) {
    let storeValue = initValue;
    let hasSubscribers = false;
    let auto = fn.length < 2;
    let fn2 = (_, set) => {
        hasSubscribers = true;
        if (auto) {
            storeValue = fn(_, set);
            set(storeValue);
        } else {
            fn(_, value => {storeValue = value; set(value);});
        }
        return () => {hasSubscribers = false;};
    };
    let store = derived(stores, fn2, storeValue);
    return {
        ...store,
        get: () => hasSubscribers ? storeValue : get_store_value(store)
    };
}

function intl(locale, format) {
    return derived([locale, format], ([$locale, $format]) => {
        let intl = is_function($format)
            ? {format: $format}
            : new Intl.DateTimeFormat($locale, $format);
        return {
            format: date => intl.format(toLocalDate$1(date))
        };
    });
}

function intlRange(locale, format) {
    return derived([locale, format], ([$locale, $format]) => {
        if (is_function($format)) {
            return {format: (start, end) => $format(toLocalDate$1(start), toLocalDate$1(end))};
        }
        let intl = new Intl.DateTimeFormat($locale, $format);
        return {
            format: (start, end) => formatRange(toLocalDate$1(start), toLocalDate$1(end), intl)
        };
    });
}

function createOptions(plugins) {
    let options = {
        allDayContent: undefined,
        allDaySlot: true,
        buttonText: {
            today: 'today',
        },
        date: new Date(),
        dateClick: undefined,
        datesSet: undefined,
        dayHeaderFormat: {
            weekday: 'short',
            month: 'numeric',
            day: 'numeric'
        },
        displayEventEnd: true,
        duration: {weeks: 1},
        events: [],
        eventBackgroundColor: undefined,
        eventClick: undefined,
        eventColor: undefined,
        eventContent: undefined,
        eventDidMount: undefined,
        eventMouseEnter: undefined,
        eventMouseLeave: undefined,
        eventSources: [],
        eventTimeFormat: {
            hour: 'numeric',
            minute: '2-digit'
        },
        firstDay: 0,
        flexibleSlotTimeLimits: false,  // ec option
        headerToolbar: {
            start: 'title',
            center: '',
            end: 'today prev,next'
        },
        height: 'auto',
        hiddenDays: [],
        highlightedDates: [],  // ec option
        lazyFetching: true,
        loading: undefined,
        locale: undefined,
        monthMode: false,
        nowIndicator: false,
        selectable: false,
        scrollTime: '06:00:00',
        slotDuration: '00:30:00',
        slotHeight: 24,  // ec option
        slotLabelFormat: {
            hour: 'numeric',
            minute: '2-digit'
        },
        slotMaxTime: '24:00:00',
        slotMinTime: '00:00:00',
        theme: {
            allDay: 'ec-all-day',
            active: 'ec-active',
            bgEvent: 'ec-bg-event',
            bgEvents: 'ec-bg-events',
            body: 'ec-body',
            button: 'ec-button',
            buttonGroup: 'ec-button-group',
            calendar: 'ec',
            compact: 'ec-compact',
            content: 'ec-content',
            day: 'ec-day',
            dayHead: 'ec-day-head',
            days: 'ec-days',
            event: 'ec-event',
            eventBody: 'ec-event-body',
            eventTime: 'ec-event-time',
            eventTitle: 'ec-event-title',
            events: 'ec-events',
            extra: 'ec-extra',
            handle: 'ec-handle',
            header: 'ec-header',
            hiddenScroll: 'ec-hidden-scroll',
            hiddenTimes: 'ec-hidden-times',
            highlight: 'ec-highlight',
            icon: 'ec-icon',
            line: 'ec-line',
            lines: 'ec-lines',
            nowIndicator: 'ec-now-indicator',
            otherMonth: 'ec-other-month',
            sidebar: 'ec-sidebar',
            sidebarTitle: 'ec-sidebar-title',
            today: 'ec-today',
            time: 'ec-time',
            title: 'ec-title',
            toolbar: 'ec-toolbar',
            week: 'ec-week',
            withScroll: 'ec-with-scroll'
        },
        titleFormat: {
            year: 'numeric',
            month: 'short',
            day: 'numeric'
        },
        view: undefined,
        viewDidMount: undefined,
        views: {}
    };

    for (let plugin of plugins) {
        if ('createOptions' in plugin) {
            plugin.createOptions(options);
        }
    }

    return options;
}

function createParsers(options, plugins) {
    let parsers = {
        buttonText: input => is_function(input) ? input(options.buttonText) : input,
        date: date => setMidnight(createDate(date)),
        duration: createDuration,
        events: createEvents,
        eventSources: createEventSources,
        hiddenDays: days => [...new Set(days)],
        highlightedDates: dates => dates.map(createDate),
        scrollTime: createDuration,
        slotDuration: createDuration,
        slotMaxTime: createDuration,
        slotMinTime: createDuration,
        theme: input => is_function(input) ? input(options.theme) : input
    };

    for (let plugin of plugins) {
        if ('createParsers' in plugin) {
            plugin.createParsers(parsers, options);
        }
    }

    return parsers;
}

let prev;
function diff(options) {
    let diff = [];
    if (prev) {
        for (let name of Object.keys(options)) {
            if (options[name] !== prev[name]) {
                diff.push([name, options[name]]);
            }
        }
    }
    prev = assign({}, options);

    return diff;
}

function activeRange(state) {
    return derived(
        [state._currentRange, state.firstDay, state.monthMode, state.slotMinTime, state.slotMaxTime],
        ([$_currentRange, $firstDay, $monthMode, $slotMinTime, $slotMaxTime]) => {
            let start = cloneDate($_currentRange.start);
            let end = cloneDate($_currentRange.end);

            if ($monthMode) {
                // First day of week
                prevClosestDay(start, $firstDay);
                nextClosestDay(end, $firstDay);
            } else if ($slotMaxTime.days || $slotMaxTime.seconds > DAY_IN_SECONDS) {
                addDuration(subtractDay(end), $slotMaxTime);
                let start2 = subtractDay(cloneDate(end));
                if (start2 < start) {
                    start = start2;
                }
            }

            return {start, end};
        }
    );
}

function currentRange(state) {
    return derived(
        [state.date, state.duration, state.monthMode, state.firstDay],
        ([$date, $duration, $monthMode, $firstDay]) => {
            let start = cloneDate($date), end;
            if ($monthMode) {
                start.setUTCDate(1);
            } else if ($duration.inWeeks) {
                // First day of week
                prevClosestDay(start, $firstDay);
            }
            end = addDuration(cloneDate(start), $duration);

            return {start, end};
        }
    );
}

function viewDates(state) {
    return derived2([state._activeRange, state.hiddenDays], ([$_activeRange, $hiddenDays]) => {
        let dates = [];
        let date = setMidnight(cloneDate($_activeRange.start));
        let end = setMidnight(cloneDate($_activeRange.end));
        while (date < end) {
            if (!$hiddenDays.includes(date.getUTCDay())) {
                dates.push(cloneDate(date));
            }
            addDay(date);
        }
        if (!dates.length && $hiddenDays.length && $hiddenDays.length < 7) {
            // Try to move the date
            state.date.update(date => {
                while ($hiddenDays.includes(date.getUTCDay())) {
                    addDay(date);
                }
                return date;
            });
            dates = state._viewDates.get();
        }

        return dates;
    });
}

function viewTitle(state) {
    return derived(
        [state.date, state._activeRange, state._titleIntlRange, state.monthMode],
        ([$date, $_activeRange, $_titleIntlRange, $monthMode]) => {
            return $monthMode
                ? $_titleIntlRange.format($date, $date)
                : $_titleIntlRange.format($_activeRange.start, subtractDay(cloneDate($_activeRange.end)));
        }
    );
}

function view(state) {
    return derived2([state.view, state._viewTitle, state._currentRange, state._activeRange], args => createView(...args));
}

function events(state) {
    let _events = writable([]);
    let abortController;
    let fetching = 0;
    let debounceHandle = {};
    derived(
        [state.events, state.eventSources, state._activeRange, state._fetchedRange, state.lazyFetching, state.loading],
        (values, set) => debounce(() => {
            let [$events, $eventSources, $_activeRange, $_fetchedRange, $lazyFetching, $loading] = values;
            if (!$eventSources.length) {
                set($events);
                return;
            }
            // Do not fetch if new range is within the previous one
            if (!$_fetchedRange.start || $_fetchedRange.start > $_activeRange.start || $_fetchedRange.end < $_activeRange.end || !$lazyFetching) {
                if (abortController) {
                    // Abort previous request
                    abortController.abort();
                }
                // Create new abort controller
                abortController = new AbortController();
                // Call loading hook
                if (is_function($loading) && !fetching) {
                    $loading(true);
                }
                let stopLoading = () => {
                    if (--fetching === 0 && is_function($loading)) {
                        $loading(false);
                    }
                };
                let events = [];
                // Prepare handlers
                let failure = e => stopLoading();
                let success = data => {
                    events = events.concat(createEvents(data));
                    set(events);
                    stopLoading();
                };
                // Prepare other stuff
                let startStr = toISOString($_activeRange.start);
                let endStr = toISOString($_activeRange.end);
                // Loop over event sources
                for (let source of $eventSources) {
                    if (is_function(source.events)) {
                        // Events as a function
                        let result = source.events({
                            start: toLocalDate$1($_activeRange.start),
                            end: toLocalDate$1($_activeRange.end),
                            startStr,
                            endStr
                        }, success, failure);
                        if (result !== undefined) {
                            Promise.resolve(result).then(success, failure);
                        }
                    } else {
                        // Events as a JSON feed
                        // Prepare params
                        let params = is_function(source.extraParams) ? source.extraParams() : assign({}, source.extraParams);
                        params.start = startStr;
                        params.end = endStr;
                        params = new URLSearchParams(params);
                        // Prepare fetch
                        let url = source.url, headers = {}, body;
                        if (['GET', 'HEAD'].includes(source.method)) {
                            url += (url.includes('?') ? '&' : '?') + params;
                        } else {
                            headers['content-type'] = 'application/x-www-form-urlencoded;charset=UTF-8';
                            body = String(params);  // Safari 10.1 doesn't convert to string automatically
                        }
                        // Do the fetch
                        fetch(url, {method: source.method, headers, body, signal: abortController.signal, credentials: 'same-origin'})
                            .then(response => response.json())
                            .then(success)
                            .catch(failure);
                    }
                    ++fetching;
                }
                // Save current range for future requests
                $_fetchedRange.start = $_activeRange.start;
                $_fetchedRange.end = $_activeRange.end;
            }
        }, debounceHandle, state._queue),
        []
    ).subscribe(_events.set);

    return _events;
}

function now() {
    return readable(createDate(), set => {
        let interval = setInterval(() => {
            set(createDate());
        }, 1000);

        return () => clearInterval(interval);
    });
}

function today(state) {
    return derived(state._now, $_now => setMidnight(cloneDate($_now)));
}

class State$4 {
    constructor(plugins, input) {
        plugins = plugins || [];

        // Create options
        let options = createOptions(plugins);
        let parsers = createParsers(options, plugins);

        // Create stores for options
        for (let [option, value] of Object.entries(options)) {
            this[option] = writable2(value, parsers[option]);
        }

        // Private stores
        this._queue = writable(new Map());  // debounce queue
        this._auxiliary = writable([]);  // auxiliary components
        this._currentRange = currentRange(this);
        this._activeRange = activeRange(this);
        this._fetchedRange = writable({start: undefined, end: undefined});
        this._events = events(this);
        this._now = now();
        this._today = today(this);
        this._ignoreClick = writable(false);
        this._intlEventTime = intl(this.locale, this.eventTimeFormat);
        this._intlSlotLabel = intl(this.locale, this.slotLabelFormat);
        this._intlDayHeader = intl(this.locale, this.dayHeaderFormat);
        this._titleIntlRange = intlRange(this.locale, this.titleFormat);
        this._scrollable = writable(false);
        this._viewTitle = viewTitle(this);
        this._viewDates = viewDates(this);
        this._view = view(this);
        this._viewComponent = writable(undefined);
        this._viewClass = writable(undefined);
        // Resources
        this._resBgColor = writable(noop);
        // Interaction
        this._interaction = writable({});
        this._iEvents = writable([null, null]);  // interaction events: [drag/resize, pointer]
        this._draggable = writable(noop);
        this._resizable = writable(noop);
        this._classes = writable(identity);
        this._iClass = writable(undefined);
        this._scroll = writable(undefined);

        // Let plugins create their private stores
        for (let plugin of plugins) {
            if ('createStores' in plugin) {
                plugin.createStores(this);
            }
        }

        if (input.view) {
            // Set initial view based on input
            this.view.set(input.view);
        }

        // Set options for each view
        let commonOpts = assign({}, options, input);
        parseOpts(commonOpts, this);
        let views = new Set([...Object.keys(options.views), ...Object.keys(input.views || {})]);
        for (let view of views) {
            let viewOpts = assign({}, options.views[view] || {}, input.views && input.views[view] || {});
            parseOpts(viewOpts, this);
            let opts = assign({}, commonOpts, viewOpts);
            // Change view component when view changes
            this.view.subscribe(newView => {
                if (newView === view) {
                    this._viewComponent.set(opts.component);
                    if (is_function(opts.viewDidMount)) {
                        tick().then(() => opts.viewDidMount(this._view.get()));
                    }
                }
            });
            // Process options
            for (let key of Object.keys(opts)) {
                if (this.hasOwnProperty(key) && key[0] !== '_') {
                    let {set, _set, ...rest} = this[key];

                    if (!_set) {
                        // Original set
                        _set = set;
                    }

                    this[key] = {
                        // Set value in all views
                        set: value => {opts[key] = value; set(value);},
                        _set,
                        ...rest
                    };

                    // Change value when view changes
                    this.view.subscribe(newView => {
                        if (newView === view) {
                            _set(opts[key]);
                        }
                    });
                }
            }
        }
    }
}

function parseOpts(opts, state) {
    for (let key of Object.keys(opts)) {
        if (state.hasOwnProperty(key) && key[0] !== '_') {
            if (state[key].parse) {
                opts[key] = state[key].parse(opts[key]);
            }
        }
    }
}

/* packages/core/src/Buttons.svelte generated by Svelte v3.55.1 */

function get_each_context$2$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[23] = list[i];
	return child_ctx;
}

// (38:4) {:else}
function create_else_block$1$1(ctx) {
	let button;
	let t_value = /*$buttonText*/ ctx[5][/*button*/ ctx[23]] + "";
	let t;
	let button_class_value;
	let mounted;
	let dispose;

	function click_handler_1() {
		return /*click_handler_1*/ ctx[20](/*button*/ ctx[23]);
	}

	return {
		c() {
			button = element("button");
			t = text(t_value);

			attr(button, "class", button_class_value = "" + (/*$theme*/ ctx[3].button + (/*$view*/ ctx[6] === /*button*/ ctx[23]
			? ' ' + /*$theme*/ ctx[3].active
			: '') + " ec-" + /*button*/ ctx[23]));
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, t);

			if (!mounted) {
				dispose = listen(button, "click", click_handler_1);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*$buttonText, buttons*/ 33 && t_value !== (t_value = /*$buttonText*/ ctx[5][/*button*/ ctx[23]] + "")) set_data(t, t_value);

			if (dirty & /*$theme, $view, buttons*/ 73 && button_class_value !== (button_class_value = "" + (/*$theme*/ ctx[3].button + (/*$view*/ ctx[6] === /*button*/ ctx[23]
			? ' ' + /*$theme*/ ctx[3].active
			: '') + " ec-" + /*button*/ ctx[23]))) {
				attr(button, "class", button_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (36:33) 
function create_if_block_4$1(ctx) {
	let button;
	let t_value = /*$buttonText*/ ctx[5][/*button*/ ctx[23]] + "";
	let t;
	let button_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			t = text(t_value);
			attr(button, "class", button_class_value = "" + (/*$theme*/ ctx[3].button + " ec-" + /*button*/ ctx[23]));
			button.disabled = /*isToday*/ ctx[1];
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, t);

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler*/ ctx[19]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*$buttonText, buttons*/ 33 && t_value !== (t_value = /*$buttonText*/ ctx[5][/*button*/ ctx[23]] + "")) set_data(t, t_value);

			if (dirty & /*$theme, buttons*/ 9 && button_class_value !== (button_class_value = "" + (/*$theme*/ ctx[3].button + " ec-" + /*button*/ ctx[23]))) {
				attr(button, "class", button_class_value);
			}

			if (dirty & /*isToday*/ 2) {
				button.disabled = /*isToday*/ ctx[1];
			}
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (34:32) 
function create_if_block_3$2(ctx) {
	let button;
	let i;
	let i_class_value;
	let button_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			i = element("i");
			attr(i, "class", i_class_value = "" + (/*$theme*/ ctx[3].icon + " ec-" + /*button*/ ctx[23]));
			attr(button, "class", button_class_value = "" + (/*$theme*/ ctx[3].button + " ec-" + /*button*/ ctx[23]));
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, i);

			if (!mounted) {
				dispose = listen(button, "click", /*next*/ ctx[17]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*$theme, buttons*/ 9 && i_class_value !== (i_class_value = "" + (/*$theme*/ ctx[3].icon + " ec-" + /*button*/ ctx[23]))) {
				attr(i, "class", i_class_value);
			}

			if (dirty & /*$theme, buttons*/ 9 && button_class_value !== (button_class_value = "" + (/*$theme*/ ctx[3].button + " ec-" + /*button*/ ctx[23]))) {
				attr(button, "class", button_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (32:31) 
function create_if_block_2$3(ctx) {
	let button;
	let i;
	let i_class_value;
	let button_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			i = element("i");
			attr(i, "class", i_class_value = "" + (/*$theme*/ ctx[3].icon + " ec-" + /*button*/ ctx[23]));
			attr(button, "class", button_class_value = "" + (/*$theme*/ ctx[3].button + " ec-" + /*button*/ ctx[23]));
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, i);

			if (!mounted) {
				dispose = listen(button, "click", /*prev*/ ctx[16]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*$theme, buttons*/ 9 && i_class_value !== (i_class_value = "" + (/*$theme*/ ctx[3].icon + " ec-" + /*button*/ ctx[23]))) {
				attr(i, "class", i_class_value);
			}

			if (dirty & /*$theme, buttons*/ 9 && button_class_value !== (button_class_value = "" + (/*$theme*/ ctx[3].button + " ec-" + /*button*/ ctx[23]))) {
				attr(button, "class", button_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

// (30:32) 
function create_if_block_1$3(ctx) {
	let h2;
	let t;
	let h2_class_value;

	return {
		c() {
			h2 = element("h2");
			t = text(/*$_viewTitle*/ ctx[4]);
			attr(h2, "class", h2_class_value = /*$theme*/ ctx[3].title);
		},
		m(target, anchor) {
			insert(target, h2, anchor);
			append(h2, t);
		},
		p(ctx, dirty) {
			if (dirty & /*$_viewTitle*/ 16) set_data(t, /*$_viewTitle*/ ctx[4]);

			if (dirty & /*$theme*/ 8 && h2_class_value !== (h2_class_value = /*$theme*/ ctx[3].title)) {
				attr(h2, "class", h2_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(h2);
		}
	};
}

// (29:4) {#if button == ''}
function create_if_block$1$3(ctx) {
	return { c: noop, m: noop, p: noop, d: noop };
}

// (28:0) {#each buttons as button}
function create_each_block$2$2(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*button*/ ctx[23] == '') return create_if_block$1$3;
		if (/*button*/ ctx[23] == 'title') return create_if_block_1$3;
		if (/*button*/ ctx[23] == 'prev') return create_if_block_2$3;
		if (/*button*/ ctx[23] === 'next') return create_if_block_3$2;
		if (/*button*/ ctx[23] === 'today') return create_if_block_4$1;
		return create_else_block$1$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$3$4(ctx) {
	let each_1_anchor;
	let each_value = /*buttons*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2$2(get_each_context$2$2(ctx, each_value, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (dirty & /*buttons, $theme, $_viewTitle, prev, next, isToday, $date, cloneDate, today, $buttonText, $view*/ 229503) {
				each_value = /*buttons*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

function instance$3$4($$self, $$props, $$invalidate) {
	let $duration;
	let $date;
	let $hiddenDays;
	let $_currentRange;
	let $theme;
	let $_viewTitle;
	let $buttonText;
	let $view;
	let { buttons } = $$props;
	let { _currentRange, _viewTitle, buttonText, date, duration, hiddenDays, theme, view } = getContext('state');
	component_subscribe($$self, _currentRange, value => $$invalidate(18, $_currentRange = value));
	component_subscribe($$self, _viewTitle, value => $$invalidate(4, $_viewTitle = value));
	component_subscribe($$self, buttonText, value => $$invalidate(5, $buttonText = value));
	component_subscribe($$self, date, value => $$invalidate(2, $date = value));
	component_subscribe($$self, duration, value => $$invalidate(21, $duration = value));
	component_subscribe($$self, hiddenDays, value => $$invalidate(22, $hiddenDays = value));
	component_subscribe($$self, theme, value => $$invalidate(3, $theme = value));
	component_subscribe($$self, view, value => $$invalidate(6, $view = value));
	let today = setMidnight(createDate()), isToday;

	function prev() {
		let d = subtractDuration($date, $duration);

		if ($hiddenDays.length && $hiddenDays.length < 7) {
			while ($hiddenDays.includes(d.getUTCDay())) {
				subtractDay(d);
			}
		}

		set_store_value(date, $date = d, $date);
	}

	function next() {
		set_store_value(date, $date = addDuration($date, $duration), $date);
	}

	const click_handler = () => set_store_value(date, $date = cloneDate(today), $date);
	const click_handler_1 = button => set_store_value(view, $view = button, $view);

	$$self.$$set = $$props => {
		if ('buttons' in $$props) $$invalidate(0, buttons = $$props.buttons);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$_currentRange*/ 262144) {
			$$invalidate(1, isToday = today >= $_currentRange.start && today < $_currentRange.end || null);
		}
	};

	return [
		buttons,
		isToday,
		$date,
		$theme,
		$_viewTitle,
		$buttonText,
		$view,
		_currentRange,
		_viewTitle,
		buttonText,
		date,
		duration,
		hiddenDays,
		theme,
		view,
		today,
		prev,
		next,
		$_currentRange,
		click_handler,
		click_handler_1
	];
}

class Buttons extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$3$4, create_fragment$3$4, safe_not_equal, { buttons: 0 });
	}
}

/* packages/core/src/Toolbar.svelte generated by Svelte v3.55.1 */

function get_each_context$1$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	return child_ctx;
}

function get_each_context_1$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[8] = list[i];
	return child_ctx;
}

// (28:16) {:else}
function create_else_block$2(ctx) {
	let buttons;
	let current;
	buttons = new Buttons({ props: { buttons: /*buttons*/ ctx[8] } });

	return {
		c() {
			create_component(buttons.$$.fragment);
		},
		m(target, anchor) {
			mount_component(buttons, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const buttons_changes = {};
			if (dirty & /*sections*/ 1) buttons_changes.buttons = /*buttons*/ ctx[8];
			buttons.$set(buttons_changes);
		},
		i(local) {
			if (current) return;
			transition_in(buttons.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(buttons.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(buttons, detaching);
		}
	};
}

// (24:16) {#if buttons.length > 1}
function create_if_block$6(ctx) {
	let div;
	let buttons;
	let div_class_value;
	let current;
	buttons = new Buttons({ props: { buttons: /*buttons*/ ctx[8] } });

	return {
		c() {
			div = element("div");
			create_component(buttons.$$.fragment);
			attr(div, "class", div_class_value = /*$theme*/ ctx[1].buttonGroup);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(buttons, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const buttons_changes = {};
			if (dirty & /*sections*/ 1) buttons_changes.buttons = /*buttons*/ ctx[8];
			buttons.$set(buttons_changes);

			if (!current || dirty & /*$theme*/ 2 && div_class_value !== (div_class_value = /*$theme*/ ctx[1].buttonGroup)) {
				attr(div, "class", div_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(buttons.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(buttons.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(buttons);
		}
	};
}

// (23:12) {#each sections[key] as buttons}
function create_each_block_1$4(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$6, create_else_block$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*buttons*/ ctx[8].length > 1) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (21:4) {#each Object.keys(sections) as key}
function create_each_block$1$3(ctx) {
	let div;
	let t;
	let current;
	let each_value_1 = /*sections*/ ctx[0][/*key*/ ctx[5]];
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append(div, t);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*$theme, sections, Object*/ 3) {
				each_value_1 = /*sections*/ ctx[0][/*key*/ ctx[5]];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1$4(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, t);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

function create_fragment$2$4(ctx) {
	let div;
	let div_class_value;
	let current;
	let each_value = Object.keys(/*sections*/ ctx[0]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1$3(get_each_context$1$3(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", div_class_value = /*$theme*/ ctx[1].toolbar);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*sections, Object, $theme*/ 3) {
				each_value = Object.keys(/*sections*/ ctx[0]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1$3(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (!current || dirty & /*$theme*/ 2 && div_class_value !== (div_class_value = /*$theme*/ ctx[1].toolbar)) {
				attr(div, "class", div_class_value);
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$2$5($$self, $$props, $$invalidate) {
	let $headerToolbar;
	let $theme;
	let { headerToolbar, theme } = getContext('state');
	component_subscribe($$self, headerToolbar, value => $$invalidate(4, $headerToolbar = value));
	component_subscribe($$self, theme, value => $$invalidate(1, $theme = value));
	let sections = { start: [], center: [], end: [] };

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*sections, $headerToolbar*/ 17) {
			{
				for (let key of Object.keys(sections)) {
					$$invalidate(0, sections[key] = $headerToolbar[key].split(' ').map(group => group.split(',')), sections);
				}
			}
		}
	};

	return [sections, $theme, headerToolbar, theme, $headerToolbar];
}

class Toolbar extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2$5, create_fragment$2$4, safe_not_equal, {});
	}
}

/* packages/core/src/Auxiliary.svelte generated by Svelte v3.55.1 */

function get_each_context$8(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

// (25:0) {#each $_auxiliary as component}
function create_each_block$8(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	var switch_value = /*component*/ ctx[11];

	function switch_props(ctx) {
		return {};
	}

	if (switch_value) {
		switch_instance = construct_svelte_component(switch_value, switch_props());
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m(target, anchor) {
			if (switch_instance) mount_component(switch_instance, target, anchor);
			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (switch_value !== (switch_value = /*component*/ ctx[11])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component(switch_value, switch_props());
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

function create_fragment$1$5(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*$_auxiliary*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*$_auxiliary*/ 1) {
				each_value = /*$_auxiliary*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$8(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$8(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

function instance$1$5($$self, $$props, $$invalidate) {
	let $_view;
	let $datesSet;
	let $_activeRange;
	let $_auxiliary;
	let { datesSet, _auxiliary, _activeRange, _queue, _view } = getContext('state');
	component_subscribe($$self, datesSet, value => $$invalidate(7, $datesSet = value));
	component_subscribe($$self, _auxiliary, value => $$invalidate(0, $_auxiliary = value));
	component_subscribe($$self, _activeRange, value => $$invalidate(5, $_activeRange = value));
	component_subscribe($$self, _view, value => $$invalidate(6, $_view = value));
	let debounceHandle = {};

	function runDatesSet(_activeRange) {
		if (is_function($datesSet)) {
			debounce(
				() => $datesSet({
					start: toLocalDate$1(_activeRange.start),
					end: toLocalDate$1(_activeRange.end),
					startStr: toISOString(_activeRange.start),
					endStr: toISOString(_activeRange.end),
					view: toViewWithLocalDates($_view)
				}),
				debounceHandle,
				_queue
			);
		}
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$_activeRange*/ 32) {
			// Set up datesSet callback
			runDatesSet($_activeRange);
		}
	};

	return [$_auxiliary, datesSet, _auxiliary, _activeRange, _view, $_activeRange];
}

class Auxiliary$2 extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1$5, create_fragment$1$5, safe_not_equal, {});
	}
}

/* packages/core/src/Calendar.svelte generated by Svelte v3.55.1 */

function create_fragment$b(ctx) {
	let div;
	let toolbar;
	let t0;
	let switch_instance;
	let div_class_value;
	let t1;
	let auxiliary;
	let current;
	let mounted;
	let dispose;
	toolbar = new Toolbar({});
	var switch_value = /*$_viewComponent*/ ctx[4];

	function switch_props(ctx) {
		return {};
	}

	if (switch_value) {
		switch_instance = construct_svelte_component(switch_value, switch_props());
	}

	auxiliary = new Auxiliary$2({});

	return {
		c() {
			div = element("div");
			create_component(toolbar.$$.fragment);
			t0 = space();
			if (switch_instance) create_component(switch_instance.$$.fragment);
			t1 = space();
			create_component(auxiliary.$$.fragment);

			attr(div, "class", div_class_value = "" + (/*$theme*/ ctx[0].calendar + (/*$_viewClass*/ ctx[1]
			? ' ' + /*$theme*/ ctx[0][/*$_viewClass*/ ctx[1]]
			: '') + (/*$_iClass*/ ctx[2]
			? ' ' + /*$theme*/ ctx[0][/*$_iClass*/ ctx[2]]
			: '')));

			set_style(div, "height", /*$height*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(toolbar, div, null);
			append(div, t0);
			if (switch_instance) mount_component(switch_instance, div, null);
			insert(target, t1, anchor);
			mount_component(auxiliary, target, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(window, "click", /*handleClick*/ ctx[16], true);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (switch_value !== (switch_value = /*$_viewComponent*/ ctx[4])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component(switch_value, switch_props());
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, div, null);
				} else {
					switch_instance = null;
				}
			}

			if (!current || dirty[0] & /*$theme, $_viewClass, $_iClass*/ 7 && div_class_value !== (div_class_value = "" + (/*$theme*/ ctx[0].calendar + (/*$_viewClass*/ ctx[1]
			? ' ' + /*$theme*/ ctx[0][/*$_viewClass*/ ctx[1]]
			: '') + (/*$_iClass*/ ctx[2]
			? ' ' + /*$theme*/ ctx[0][/*$_iClass*/ ctx[2]]
			: '')))) {
				attr(div, "class", div_class_value);
			}

			if (!current || dirty[0] & /*$height*/ 8) {
				set_style(div, "height", /*$height*/ ctx[3]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(toolbar.$$.fragment, local);
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			transition_in(auxiliary.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(toolbar.$$.fragment, local);
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			transition_out(auxiliary.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(toolbar);
			if (switch_instance) destroy_component(switch_instance);
			if (detaching) detach(t1);
			destroy_component(auxiliary, detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$b($$self, $$props, $$invalidate) {
	let $_queue;
	let $_ignoreClick;
	let $events;
	let $_events;
	let $eventSources;
	let $_interaction;
	let $theme;
	let $_viewClass;
	let $_iClass;
	let $height;
	let $_viewComponent;
	let { plugins = [] } = $$props;
	let { options = {} } = $$props;
	let component = get_current_component();
	let state = new State$4(plugins, options);
	setContext('state', state);
	let { _viewComponent, _viewClass, _ignoreClick, _interaction, _iClass, _events, _queue, events, eventSources, height, theme } = state;
	component_subscribe($$self, _viewComponent, value => $$invalidate(4, $_viewComponent = value));
	component_subscribe($$self, _viewClass, value => $$invalidate(1, $_viewClass = value));
	component_subscribe($$self, _ignoreClick, value => $$invalidate(32, $_ignoreClick = value));
	component_subscribe($$self, _interaction, value => $$invalidate(36, $_interaction = value));
	component_subscribe($$self, _iClass, value => $$invalidate(2, $_iClass = value));
	component_subscribe($$self, _events, value => $$invalidate(34, $_events = value));
	component_subscribe($$self, _queue, value => $$invalidate(31, $_queue = value));
	component_subscribe($$self, events, value => $$invalidate(33, $events = value));
	component_subscribe($$self, eventSources, value => $$invalidate(35, $eventSources = value));
	component_subscribe($$self, height, value => $$invalidate(3, $height = value));
	component_subscribe($$self, theme, value => $$invalidate(0, $theme = value));

	function setOption(name, value) {
		if (state.hasOwnProperty(name)) {
			if (state[name].parse) {
				value = state[name].parse(value);
			}

			state[name].set(value);
		}

		return this;
	}

	function getOption(name) {
		let value = state.hasOwnProperty(name)
		? get_store_value(state[name])
		: undefined;

		return value instanceof Date ? toLocalDate$1(value) : value;
	}

	function refetchEvents() {
		state._fetchedRange.set({ start: undefined, end: undefined });
		return this;
	}

	function getEvents() {
		return $_events.map(toEventWithLocalDates);
	}

	function getEventById(id) {
		for (let event of $_events) {
			if (event.id == id) {
				return toEventWithLocalDates(event);
			}
		}

		return null;
	}

	function addEvent(event) {
		updateEvents(events => events.concat(state.events.parse([event])));
		return this;
	}

	function updateEvent(event) {
		updateEvents(events => {
			for (let e of events) {
				if (e.id == event.id) {
					assign(e, state.events.parse([event])[0]);
					break;
				}
			}

			return events;
		});

		return this;
	}

	function removeEventById(id) {
		updateEvents(events => events.filter(event => event.id != id));
		return this;
	}

	function getView() {
		return toViewWithLocalDates(state._view.get());
	}

	function unselect() {
		if ($_interaction.action) {
			$_interaction.action.unselect();
		}

		return this;
	}

	function dateFromPoint(x, y) {
		for (let el of document.elementsFromPoint(x, y)) {
			if (hasFn(el)) {
				let date = runFn(el, y);
				return date ? toLocalDate$1(date) : null;
			}
		}

		return null;
	}

	function destroy() {
		destroy_component(component, true);
	}

	function updateEvents(func) {
		if ($eventSources.length) {
			set_store_value(_events, $_events = func($_events), $_events);
		} else {
			set_store_value(events, $events = func($events), $events);
		}
	}

	function handleClick(jsEvent) {
		if ($_ignoreClick) {
			ignore(jsEvent);
			set_store_value(_ignoreClick, $_ignoreClick = false, $_ignoreClick);
		}
	}

	beforeUpdate(() => {
		flushDebounce($_queue);
	});

	$$self.$$set = $$props => {
		if ('plugins' in $$props) $$invalidate(17, plugins = $$props.plugins);
		if ('options' in $$props) $$invalidate(18, options = $$props.options);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*options*/ 262144) {
			// Reactively update options that did change
			for (let [name, value] of diff(options)) {
				setOption(name, value);
			}
		}
	};

	return [
		$theme,
		$_viewClass,
		$_iClass,
		$height,
		$_viewComponent,
		_viewComponent,
		_viewClass,
		_ignoreClick,
		_interaction,
		_iClass,
		_events,
		_queue,
		events,
		eventSources,
		height,
		theme,
		handleClick,
		plugins,
		options,
		setOption,
		getOption,
		refetchEvents,
		getEvents,
		getEventById,
		addEvent,
		updateEvent,
		removeEventById,
		getView,
		unselect,
		dateFromPoint,
		destroy
	];
}

class Calendar$1 extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$b,
			create_fragment$b,
			safe_not_equal,
			{
				plugins: 17,
				options: 18,
				setOption: 19,
				getOption: 20,
				refetchEvents: 21,
				getEvents: 22,
				getEventById: 23,
				addEvent: 24,
				updateEvent: 25,
				removeEventById: 26,
				getView: 27,
				unselect: 28,
				dateFromPoint: 29,
				destroy: 30
			},
			null,
			[-1, -1]
		);
	}

	get setOption() {
		return this.$$.ctx[19];
	}

	get getOption() {
		return this.$$.ctx[20];
	}

	get refetchEvents() {
		return this.$$.ctx[21];
	}

	get getEvents() {
		return this.$$.ctx[22];
	}

	get getEventById() {
		return this.$$.ctx[23];
	}

	get addEvent() {
		return this.$$.ctx[24];
	}

	get updateEvent() {
		return this.$$.ctx[25];
	}

	get removeEventById() {
		return this.$$.ctx[26];
	}

	get getView() {
		return this.$$.ctx[27];
	}

	get unselect() {
		return this.$$.ctx[28];
	}

	get dateFromPoint() {
		return this.$$.ctx[29];
	}

	get destroy() {
		return this.$$.ctx[30];
	}
}

function times(state, localState) {
    return derived(
        [localState._slotTimeLimits, state._intlSlotLabel, state.slotDuration],
        ([$_slotTimeLimits, $_intlSlotLabel, $slotDuration]) => {
            let compact = $slotDuration.seconds >= 3600;
            let times = [];
            let date = createDate('2020-01-01');
            let end = cloneDate(date);
            let i = 1;
            addDuration(date, $_slotTimeLimits.min);
            addDuration(end, $_slotTimeLimits.max);
            while (date < end) {
                times.push(times.length && (i || compact) ? $_intlSlotLabel.format(date) : '');
                addDuration(date, $slotDuration);
                i = 1 - i;
            }

            return times;
        }
    );
}

function slotTimeLimits(state) {
    return derived(
        [state._events, state._viewDates, state.flexibleSlotTimeLimits, state.slotMinTime, state.slotMaxTime],
        ([$_events, $_viewDates, $flexibleSlotTimeLimits, $slotMinTime, $slotMaxTime]) => {
            let min = createDuration($slotMinTime);
            let max = createDuration($slotMaxTime);

            if ($flexibleSlotTimeLimits) {
                let minMin = createDuration(Math.min(min.seconds, Math.max(0, max.seconds - DAY_IN_SECONDS)));
                let maxMax = createDuration(Math.max(max.seconds, minMin.seconds + DAY_IN_SECONDS));
                loop: for (let date of $_viewDates) {
                    let start = addDuration(cloneDate(date), min);
                    let end = addDuration(cloneDate(date), max);
                    let minStart = addDuration(cloneDate(date), minMin);
                    let maxEnd = addDuration(cloneDate(date), maxMax);
                    for (let event of $_events) {
                        if (event.display === 'auto' && event.start < maxEnd && event.end > minStart) {
                            if (event.start < start) {
                                let seconds = Math.max((event.start - date) / 1000, minMin.seconds);
                                if (seconds < min.seconds) {
                                    min.seconds = seconds;
                                }
                            }
                            if (event.end > end) {
                                let seconds = Math.min((event.end - date) / 1000, maxMax.seconds);
                                if (seconds > max.seconds) {
                                    max.seconds = seconds;
                                }
                            }
                            if (min.seconds === minMin.seconds && max.seconds === maxMax.seconds) {
                                break loop;
                            }
                        }
                    }
                }
            }

            return {min, max};
        }
    );
}

class State$3 {
    constructor(state) {
        this._slotTimeLimits = slotTimeLimits(state);  // flexible limits
        this._times = times(state, this);
    }
}

function groupEventChunks(chunks) {
    if (!chunks.length) {
        return;
    }

    sortEventChunks(chunks);

    // Group
    let group = {
        columns: [],
        end: chunks[0].end
    };
    for (let chunk of chunks) {
        let c = 0;
        if (chunk.start < group.end) {
            for (; c < group.columns.length; ++c) {
                if (group.columns[c][group.columns[c].length - 1].end <= chunk.start) {
                    break;
                }
            }
            if (chunk.end > group.end) {
                group.end = chunk.end;
            }
        } else {
            group = {
                columns: [],
                end: chunk.end
            };
        }

        if (group.columns.length < c + 1) {
            group.columns.push([]);
        }
        group.columns[c].push(chunk);

        chunk.group = group;
        chunk.column = c;
    }
}

function createAllDayContent(allDayContent) {
    let text = 'all-day';
    let content;
    if (allDayContent) {
        content = is_function(allDayContent) ? allDayContent({text}) : allDayContent;
        if (typeof content === 'string') {
            content = {html: content};
        }
    } else {
        content = {
            html: text
        };
    }

    return content;
}

/* packages/time-grid/src/Header.svelte generated by Svelte v3.55.1 */

function get_each_context$5$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[12] = list[i];
	return child_ctx;
}

// (19:12) {#each $_times as time}
function create_each_block$5$1(ctx) {
	let div;
	let t_value = /*time*/ ctx[12] + "";
	let t;
	let div_class_value;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			attr(div, "class", div_class_value = /*$theme*/ ctx[2].time);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*$_times*/ 16 && t_value !== (t_value = /*time*/ ctx[12] + "")) set_data(t, t_value);

			if (dirty & /*$theme*/ 4 && div_class_value !== (div_class_value = /*$theme*/ ctx[2].time)) {
				attr(div, "class", div_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$8$1(ctx) {
	let div6;
	let div2;
	let div0;
	let div0_class_value;
	let setContent_action;
	let t0;
	let div1;
	let div1_class_value;
	let div2_class_value;
	let t1;
	let div4;
	let div3;
	let div3_class_value;
	let t2;
	let div4_class_value;
	let t3;
	let div5;
	let div5_class_value;
	let div6_class_value;
	let current;
	let mounted;
	let dispose;
	let each_value = /*$_times*/ ctx[4];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$5$1(get_each_context$5$1(ctx, each_value, i));
	}

	const default_slot_template = /*#slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);

	return {
		c() {
			div6 = element("div");
			div2 = element("div");
			div0 = element("div");
			t0 = space();
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			div4 = element("div");
			div3 = element("div");
			t2 = space();
			if (default_slot) default_slot.c();
			t3 = space();
			div5 = element("div");
			attr(div0, "class", div0_class_value = /*$theme*/ ctx[2].sidebarTitle);
			attr(div1, "class", div1_class_value = /*$theme*/ ctx[2].hiddenTimes);
			attr(div2, "class", div2_class_value = /*$theme*/ ctx[2].sidebar);
			attr(div3, "class", div3_class_value = /*$theme*/ ctx[2].lines);
			attr(div4, "class", div4_class_value = /*$theme*/ ctx[2].days);
			attr(div5, "class", div5_class_value = /*$theme*/ ctx[2].hiddenScroll);

			attr(div6, "class", div6_class_value = "" + ((/*allDay*/ ctx[0]
			? /*$theme*/ ctx[2].allDay
			: /*$theme*/ ctx[2].header) + (/*$_scrollable*/ ctx[3]
			? ' ' + /*$theme*/ ctx[2].withScroll
			: '')));
		},
		m(target, anchor) {
			insert(target, div6, anchor);
			append(div6, div2);
			append(div2, div0);
			append(div2, t0);
			append(div2, div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			append(div6, t1);
			append(div6, div4);
			append(div4, div3);
			append(div4, t2);

			if (default_slot) {
				default_slot.m(div4, null);
			}

			append(div6, t3);
			append(div6, div5);
			current = true;

			if (!mounted) {
				dispose = action_destroyer(setContent_action = setContent$1.call(null, div0, /*allDayText*/ ctx[1]));
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*$theme*/ 4 && div0_class_value !== (div0_class_value = /*$theme*/ ctx[2].sidebarTitle)) {
				attr(div0, "class", div0_class_value);
			}

			if (setContent_action && is_function(setContent_action.update) && dirty & /*allDayText*/ 2) setContent_action.update.call(null, /*allDayText*/ ctx[1]);

			if (dirty & /*$theme, $_times*/ 20) {
				each_value = /*$_times*/ ctx[4];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$5$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$5$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div1, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (!current || dirty & /*$theme*/ 4 && div1_class_value !== (div1_class_value = /*$theme*/ ctx[2].hiddenTimes)) {
				attr(div1, "class", div1_class_value);
			}

			if (!current || dirty & /*$theme*/ 4 && div2_class_value !== (div2_class_value = /*$theme*/ ctx[2].sidebar)) {
				attr(div2, "class", div2_class_value);
			}

			if (!current || dirty & /*$theme*/ 4 && div3_class_value !== (div3_class_value = /*$theme*/ ctx[2].lines)) {
				attr(div3, "class", div3_class_value);
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[10],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[10], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*$theme*/ 4 && div4_class_value !== (div4_class_value = /*$theme*/ ctx[2].days)) {
				attr(div4, "class", div4_class_value);
			}

			if (!current || dirty & /*$theme*/ 4 && div5_class_value !== (div5_class_value = /*$theme*/ ctx[2].hiddenScroll)) {
				attr(div5, "class", div5_class_value);
			}

			if (!current || dirty & /*allDay, $theme, $_scrollable*/ 13 && div6_class_value !== (div6_class_value = "" + ((/*allDay*/ ctx[0]
			? /*$theme*/ ctx[2].allDay
			: /*$theme*/ ctx[2].header) + (/*$_scrollable*/ ctx[3]
			? ' ' + /*$theme*/ ctx[2].withScroll
			: '')))) {
				attr(div6, "class", div6_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div6);
			destroy_each(each_blocks, detaching);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance$8$1($$self, $$props, $$invalidate) {
	let $allDayContent;
	let $theme;
	let $_scrollable;
	let $_times;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { allDay = false } = $$props;
	let { _scrollable, allDayContent, theme } = getContext('state');
	component_subscribe($$self, _scrollable, value => $$invalidate(3, $_scrollable = value));
	component_subscribe($$self, allDayContent, value => $$invalidate(9, $allDayContent = value));
	component_subscribe($$self, theme, value => $$invalidate(2, $theme = value));
	let { _times } = getContext('view-state');
	component_subscribe($$self, _times, value => $$invalidate(4, $_times = value));
	let allDayText;

	$$self.$$set = $$props => {
		if ('allDay' in $$props) $$invalidate(0, allDay = $$props.allDay);
		if ('$$scope' in $$props) $$invalidate(10, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$allDayContent*/ 512) {
			$$invalidate(1, allDayText = createAllDayContent($allDayContent));
		}
	};

	return [
		allDay,
		allDayText,
		$theme,
		$_scrollable,
		$_times,
		_scrollable,
		allDayContent,
		theme,
		_times,
		$allDayContent,
		$$scope,
		slots
	];
}

class Header$1 extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$8$1, create_fragment$8$1, safe_not_equal, { allDay: 0 });
	}
}

/* packages/time-grid/src/Body.svelte generated by Svelte v3.55.1 */

function get_each_context$4$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[30] = list[i];
	return child_ctx;
}

function get_each_context_1$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[33] = list[i];
	return child_ctx;
}

// (46:12) {#each $_times as time}
function create_each_block_1$2(ctx) {
	let div;
	let t_value = /*time*/ ctx[33] + "";
	let t;
	let div_class_value;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			attr(div, "class", div_class_value = /*$theme*/ ctx[5].time);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$_times*/ 2 && t_value !== (t_value = /*time*/ ctx[33] + "")) set_data(t, t_value);

			if (dirty[0] & /*$theme*/ 32 && div_class_value !== (div_class_value = /*$theme*/ ctx[5].time)) {
				attr(div, "class", div_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (52:16) {#each lines as line}
function create_each_block$4$1(ctx) {
	let div;
	let div_class_value;

	return {
		c() {
			div = element("div");
			attr(div, "class", div_class_value = /*$theme*/ ctx[5].line);
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$theme*/ 32 && div_class_value !== (div_class_value = /*$theme*/ ctx[5].line)) {
				attr(div, "class", div_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$7$1(ctx) {
	let div5;
	let div4;
	let div1;
	let div0;
	let div0_class_value;
	let setContent_action;
	let t0;
	let div1_class_value;
	let t1;
	let div3;
	let div2;
	let div2_class_value;
	let t2;
	let div3_class_value;
	let div4_class_value;
	let div5_class_value;
	let current;
	let mounted;
	let dispose;
	let each_value_1 = /*$_times*/ ctx[1];
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
	}

	let each_value = /*lines*/ ctx[3];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$4$1(get_each_context$4$1(ctx, each_value, i));
	}

	const default_slot_template = /*#slots*/ ctx[26].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[25], null);

	return {
		c() {
			div5 = element("div");
			div4 = element("div");
			div1 = element("div");
			div0 = element("div");
			t0 = space();

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t1 = space();
			div3 = element("div");
			div2 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			if (default_slot) default_slot.c();
			attr(div0, "class", div0_class_value = /*$theme*/ ctx[5].sidebarTitle);
			attr(div1, "class", div1_class_value = /*$theme*/ ctx[5].sidebar);
			attr(div2, "class", div2_class_value = /*$theme*/ ctx[5].lines);
			attr(div3, "class", div3_class_value = /*$theme*/ ctx[5].days);
			attr(div4, "class", div4_class_value = /*$theme*/ ctx[5].content);

			attr(div5, "class", div5_class_value = "" + (/*$theme*/ ctx[5].body + (/*compact*/ ctx[2]
			? ' ' + /*$theme*/ ctx[5].compact
			: '')));
		},
		m(target, anchor) {
			insert(target, div5, anchor);
			append(div5, div4);
			append(div4, div1);
			append(div1, div0);
			append(div1, t0);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div1, null);
			}

			append(div4, t1);
			append(div4, div3);
			append(div3, div2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div2, null);
			}

			append(div3, t2);

			if (default_slot) {
				default_slot.m(div3, null);
			}

			/*div5_binding*/ ctx[27](div5);
			current = true;

			if (!mounted) {
				dispose = [
					listen(window, "resize", /*recheckScrollable*/ ctx[17]),
					action_destroyer(setContent_action = setContent$1.call(null, div0, /*allDayText*/ ctx[4])),
					listen(div5, "scroll", function () {
						if (is_function(/*$_scroll*/ ctx[6])) /*$_scroll*/ ctx[6].apply(this, arguments);
					})
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (!current || dirty[0] & /*$theme*/ 32 && div0_class_value !== (div0_class_value = /*$theme*/ ctx[5].sidebarTitle)) {
				attr(div0, "class", div0_class_value);
			}

			if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*allDayText*/ 16) setContent_action.update.call(null, /*allDayText*/ ctx[4]);

			if (dirty[0] & /*$theme, $_times*/ 34) {
				each_value_1 = /*$_times*/ ctx[1];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1$2(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(div1, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;
			}

			if (!current || dirty[0] & /*$theme*/ 32 && div1_class_value !== (div1_class_value = /*$theme*/ ctx[5].sidebar)) {
				attr(div1, "class", div1_class_value);
			}

			if (dirty[0] & /*$theme, lines*/ 40) {
				each_value = /*lines*/ ctx[3];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$4$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$4$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div2, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (!current || dirty[0] & /*$theme*/ 32 && div2_class_value !== (div2_class_value = /*$theme*/ ctx[5].lines)) {
				attr(div2, "class", div2_class_value);
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 33554432)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[25],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[25])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[25], dirty, null),
						null
					);
				}
			}

			if (!current || dirty[0] & /*$theme*/ 32 && div3_class_value !== (div3_class_value = /*$theme*/ ctx[5].days)) {
				attr(div3, "class", div3_class_value);
			}

			if (!current || dirty[0] & /*$theme*/ 32 && div4_class_value !== (div4_class_value = /*$theme*/ ctx[5].content)) {
				attr(div4, "class", div4_class_value);
			}

			if (!current || dirty[0] & /*$theme, compact*/ 36 && div5_class_value !== (div5_class_value = "" + (/*$theme*/ ctx[5].body + (/*compact*/ ctx[2]
			? ' ' + /*$theme*/ ctx[5].compact
			: '')))) {
				attr(div5, "class", div5_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div5);
			destroy_each(each_blocks_1, detaching);
			destroy_each(each_blocks, detaching);
			if (default_slot) default_slot.d(detaching);
			/*div5_binding*/ ctx[27](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$7$1($$self, $$props, $$invalidate) {
	let $_scrollable;
	let $slotDuration;
	let $_times;
	let $slotHeight;
	let $scrollTime;
	let $_viewDates;
	let $allDayContent;
	let $_slotTimeLimits;
	let $theme;
	let $_scroll;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { _intlSlotLabel, _viewDates, scrollTime, _scrollable, _scroll, allDayContent, slotDuration, slotHeight, theme } = getContext('state');
	component_subscribe($$self, _viewDates, value => $$invalidate(22, $_viewDates = value));
	component_subscribe($$self, scrollTime, value => $$invalidate(21, $scrollTime = value));
	component_subscribe($$self, _scrollable, value => $$invalidate(28, $_scrollable = value));
	component_subscribe($$self, _scroll, value => $$invalidate(6, $_scroll = value));
	component_subscribe($$self, allDayContent, value => $$invalidate(23, $allDayContent = value));
	component_subscribe($$self, slotDuration, value => $$invalidate(19, $slotDuration = value));
	component_subscribe($$self, slotHeight, value => $$invalidate(20, $slotHeight = value));
	component_subscribe($$self, theme, value => $$invalidate(5, $theme = value));
	let { _slotTimeLimits, _times } = getContext('view-state');
	component_subscribe($$self, _slotTimeLimits, value => $$invalidate(24, $_slotTimeLimits = value));
	component_subscribe($$self, _times, value => $$invalidate(1, $_times = value));
	let el;
	let compact;
	let lines = [];
	let timeLimitMin;
	let allDayText;

	function recheckScrollable() {
		set_store_value(_scrollable, $_scrollable = hasYScroll(el), $_scrollable);
	}

	function div5_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			((((((($$invalidate(0, el), $$invalidate(22, $_viewDates)), $$invalidate(21, $scrollTime)), $$invalidate(18, timeLimitMin)), $$invalidate(19, $slotDuration)), $$invalidate(20, $slotHeight)), $$invalidate(1, $_times)), $$invalidate(24, $_slotTimeLimits));
		});
	}

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(25, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*$slotDuration, $_times, $_slotTimeLimits*/ 17301506) {
			{
				$$invalidate(2, compact = $slotDuration.seconds >= 3600);
				$$invalidate(3, lines.length = $_times.length, lines);

				// Use intermediate variable so that changes in _slotTimeLimits do not trigger setting the el.scrollTop
				$$invalidate(18, timeLimitMin = $_slotTimeLimits.min.seconds);
			}
		}

		if ($$self.$$.dirty[0] & /*$allDayContent*/ 8388608) {
			$$invalidate(4, allDayText = createAllDayContent($allDayContent));
		}

		if ($$self.$$.dirty[0] & /*el, $_viewDates, $scrollTime, timeLimitMin, $slotDuration, $slotHeight*/ 8126465) {
			if (el && $_viewDates) {
				$$invalidate(0, el.scrollTop = (($scrollTime.seconds - timeLimitMin) / $slotDuration.seconds - 0.5) * $slotHeight, el);
			}
		}

		if ($$self.$$.dirty[0] & /*el, $_times, $slotDuration*/ 524291) {
			if (el && $_times && $slotDuration) {
				setTimeout(recheckScrollable);
			}
		}
	};

	return [
		el,
		$_times,
		compact,
		lines,
		allDayText,
		$theme,
		$_scroll,
		_viewDates,
		scrollTime,
		_scrollable,
		_scroll,
		allDayContent,
		slotDuration,
		slotHeight,
		theme,
		_slotTimeLimits,
		_times,
		recheckScrollable,
		timeLimitMin,
		$slotDuration,
		$slotHeight,
		$scrollTime,
		$_viewDates,
		$allDayContent,
		$_slotTimeLimits,
		$$scope,
		slots,
		div5_binding
	];
}

class Body$2 extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$7$1, create_fragment$7$1, safe_not_equal, {}, null, [-1, -1]);
	}
}

/* packages/time-grid/src/Event.svelte generated by Svelte v3.55.1 */

function create_fragment$6$1(ctx) {
	let div1;
	let div0;
	let div0_class_value;
	let setContent_action;
	let t;
	let switch_instance;
	let current;
	let mounted;
	let dispose;
	var switch_value = /*$_interaction*/ ctx[7].resizer;

	function switch_props(ctx) {
		return { props: { event: /*event*/ ctx[0] } };
	}

	if (switch_value) {
		switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		switch_instance.$on("pointerdown", /*createDragHandler*/ ctx[31](true));
	}

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			t = space();
			if (switch_instance) create_component(switch_instance.$$.fragment);
			attr(div0, "class", div0_class_value = /*$theme*/ ctx[2].eventBody);
			attr(div1, "class", /*classes*/ ctx[4]);
			attr(div1, "style", /*style*/ ctx[5]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div1, t);
			if (switch_instance) mount_component(switch_instance, div1, null);
			/*div1_binding*/ ctx[45](div1);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(setContent_action = setContent$1.call(null, div0, /*content*/ ctx[6])),
					listen(div1, "click", function () {
						if (is_function(maybeIgnore(/*createHandler*/ ctx[30](/*$eventClick*/ ctx[8], /*display*/ ctx[1])))) maybeIgnore(/*createHandler*/ ctx[30](/*$eventClick*/ ctx[8], /*display*/ ctx[1])).apply(this, arguments);
					}),
					listen(div1, "mouseenter", function () {
						if (is_function(/*createHandler*/ ctx[30](/*$eventMouseEnter*/ ctx[9], /*display*/ ctx[1]))) /*createHandler*/ ctx[30](/*$eventMouseEnter*/ ctx[9], /*display*/ ctx[1]).apply(this, arguments);
					}),
					listen(div1, "mouseleave", function () {
						if (is_function(/*createHandler*/ ctx[30](/*$eventMouseLeave*/ ctx[10], /*display*/ ctx[1]))) /*createHandler*/ ctx[30](/*$eventMouseLeave*/ ctx[10], /*display*/ ctx[1]).apply(this, arguments);
					}),
					listen(div1, "pointerdown", function () {
						if (is_function(/*display*/ ctx[1] === 'auto' && /*$_draggable*/ ctx[11](/*event*/ ctx[0])
						? /*createDragHandler*/ ctx[31]()
						: undefined)) (/*display*/ ctx[1] === 'auto' && /*$_draggable*/ ctx[11](/*event*/ ctx[0])
						? /*createDragHandler*/ ctx[31]()
						: undefined).apply(this, arguments);
					})
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (!current || dirty[0] & /*$theme*/ 4 && div0_class_value !== (div0_class_value = /*$theme*/ ctx[2].eventBody)) {
				attr(div0, "class", div0_class_value);
			}

			if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*content*/ 64) setContent_action.update.call(null, /*content*/ ctx[6]);
			const switch_instance_changes = {};
			if (dirty[0] & /*event*/ 1) switch_instance_changes.event = /*event*/ ctx[0];

			if (switch_value !== (switch_value = /*$_interaction*/ ctx[7].resizer)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
					switch_instance.$on("pointerdown", /*createDragHandler*/ ctx[31](true));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, div1, null);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}

			if (!current || dirty[0] & /*classes*/ 16) {
				attr(div1, "class", /*classes*/ ctx[4]);
			}

			if (!current || dirty[0] & /*style*/ 32) {
				attr(div1, "style", /*style*/ ctx[5]);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (switch_instance) destroy_component(switch_instance);
			/*div1_binding*/ ctx[45](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$6$1($$self, $$props, $$invalidate) {
	let $_interaction;
	let $_view;
	let $eventDidMount;
	let $_intlEventTime;
	let $theme;
	let $eventContent;
	let $displayEventEnd;
	let $_classes;
	let $eventColor;
	let $eventBackgroundColor;
	let $_resBgColor;
	let $slotHeight;
	let $_slotTimeLimits;
	let $slotDuration;
	let $eventClick;
	let $eventMouseEnter;
	let $eventMouseLeave;
	let $_draggable;
	let { date } = $$props;
	let { chunk } = $$props;
	let { displayEventEnd, eventBackgroundColor, eventColor, eventContent, eventClick, eventDidMount, eventMouseEnter, eventMouseLeave, slotDuration, slotHeight, theme, _view, _intlEventTime, _interaction, _classes, _draggable, _resBgColor } = getContext('state');
	component_subscribe($$self, displayEventEnd, value => $$invalidate(37, $displayEventEnd = value));
	component_subscribe($$self, eventBackgroundColor, value => $$invalidate(40, $eventBackgroundColor = value));
	component_subscribe($$self, eventColor, value => $$invalidate(39, $eventColor = value));
	component_subscribe($$self, eventContent, value => $$invalidate(36, $eventContent = value));
	component_subscribe($$self, eventClick, value => $$invalidate(8, $eventClick = value));
	component_subscribe($$self, eventDidMount, value => $$invalidate(47, $eventDidMount = value));
	component_subscribe($$self, eventMouseEnter, value => $$invalidate(9, $eventMouseEnter = value));
	component_subscribe($$self, eventMouseLeave, value => $$invalidate(10, $eventMouseLeave = value));
	component_subscribe($$self, slotDuration, value => $$invalidate(44, $slotDuration = value));
	component_subscribe($$self, slotHeight, value => $$invalidate(42, $slotHeight = value));
	component_subscribe($$self, theme, value => $$invalidate(2, $theme = value));
	component_subscribe($$self, _view, value => $$invalidate(34, $_view = value));
	component_subscribe($$self, _intlEventTime, value => $$invalidate(35, $_intlEventTime = value));
	component_subscribe($$self, _interaction, value => $$invalidate(7, $_interaction = value));
	component_subscribe($$self, _classes, value => $$invalidate(38, $_classes = value));
	component_subscribe($$self, _draggable, value => $$invalidate(11, $_draggable = value));
	component_subscribe($$self, _resBgColor, value => $$invalidate(41, $_resBgColor = value));
	let { _slotTimeLimits, _viewResources } = getContext('view-state');
	component_subscribe($$self, _slotTimeLimits, value => $$invalidate(43, $_slotTimeLimits = value));
	let el;
	let event;
	let display;
	let classes;
	let style;
	let content;
	let timeText;

	onMount(() => {
		if (is_function($eventDidMount)) {
			$eventDidMount({
				event: toEventWithLocalDates(event),
				timeText,
				el,
				view: toViewWithLocalDates($_view)
			});
		}
	});

	function createHandler(fn, display) {
		return display !== 'preview' && is_function(fn)
		? jsEvent => fn({
				event: toEventWithLocalDates(event),
				el,
				jsEvent,
				view: toViewWithLocalDates($_view)
			})
		: undefined;
	}

	function createDragHandler(resize) {
		return jsEvent => $_interaction.action.dragTimeGrid(event, el, jsEvent, _viewResources, false, resize);
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(3, el);
		});
	}

	$$self.$$set = $$props => {
		if ('date' in $$props) $$invalidate(32, date = $$props.date);
		if ('chunk' in $$props) $$invalidate(33, chunk = $$props.chunk);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[1] & /*chunk*/ 4) {
			$$invalidate(0, event = chunk.event);
		}

		if ($$self.$$.dirty[0] & /*event, style, display, $theme*/ 39 | $$self.$$.dirty[1] & /*$slotDuration, $_slotTimeLimits, chunk, date, $slotHeight, $_resBgColor, $eventBackgroundColor, $eventColor, $_classes*/ 16262) {
			{
				$$invalidate(1, display = event.display);

				// Style
				let step = $slotDuration.seconds / 60;

				let offset = $_slotTimeLimits.min.seconds / 60;
				let start = (chunk.start - date) / 1000 / 60;
				let end = (chunk.end - date) / 1000 / 60;
				let top = (start - offset) / step * $slotHeight;
				let height = (end - start) / step * $slotHeight;
				let maxHeight = ($_slotTimeLimits.max.seconds / 60 - start) / step * $slotHeight;
				let bgColor = event.backgroundColor || $_resBgColor(event) || $eventBackgroundColor || $eventColor;
				$$invalidate(5, style = `top:${top}px;` + `min-height:${height}px;` + `height:${height}px;` + `max-height:${maxHeight}px;`);

				if (bgColor) {
					$$invalidate(5, style += `background-color:${bgColor};`);
				}

				if (display === 'auto' || display === 'ghost') {
					$$invalidate(5, style += `z-index:${chunk.column + 1};` + `left:${100 / chunk.group.columns.length * chunk.column}%;` + `width:${100 / chunk.group.columns.length * 0.5 * (1 + chunk.group.columns.length - chunk.column)}%;`);
				}

				// Class
				$$invalidate(4, classes = $_classes(display === 'background' ? $theme.bgEvent : $theme.event, event));
			}
		}

		if ($$self.$$.dirty[0] & /*$theme*/ 4 | $$self.$$.dirty[1] & /*chunk, $displayEventEnd, $eventContent, $_intlEventTime, $_view*/ 124) {
			// Content
			$$invalidate(6, [timeText, content] = createEventContent(chunk, $displayEventEnd, $eventContent, $theme, $_intlEventTime, $_view), content);
		}
	};

	return [
		event,
		display,
		$theme,
		el,
		classes,
		style,
		content,
		$_interaction,
		$eventClick,
		$eventMouseEnter,
		$eventMouseLeave,
		$_draggable,
		displayEventEnd,
		eventBackgroundColor,
		eventColor,
		eventContent,
		eventClick,
		eventDidMount,
		eventMouseEnter,
		eventMouseLeave,
		slotDuration,
		slotHeight,
		theme,
		_view,
		_intlEventTime,
		_interaction,
		_classes,
		_draggable,
		_resBgColor,
		_slotTimeLimits,
		createHandler,
		createDragHandler,
		date,
		chunk,
		$_view,
		$_intlEventTime,
		$eventContent,
		$displayEventEnd,
		$_classes,
		$eventColor,
		$eventBackgroundColor,
		$_resBgColor,
		$slotHeight,
		$_slotTimeLimits,
		$slotDuration,
		div1_binding
	];
}

class Event$1$1 extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$6$1, create_fragment$6$1, safe_not_equal, { date: 32, chunk: 33 }, null, [-1, -1]);
	}
}

/* packages/time-grid/src/NowIndicator.svelte generated by Svelte v3.55.1 */

function create_fragment$5$1(ctx) {
	let div;
	let div_class_value;

	return {
		c() {
			div = element("div");
			attr(div, "class", div_class_value = /*$theme*/ ctx[1].nowIndicator);
			set_style(div, "top", /*top*/ ctx[0] + "px");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, [dirty]) {
			if (dirty & /*$theme*/ 2 && div_class_value !== (div_class_value = /*$theme*/ ctx[1].nowIndicator)) {
				attr(div, "class", div_class_value);
			}

			if (dirty & /*top*/ 1) {
				set_style(div, "top", /*top*/ ctx[0] + "px");
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function instance$5$1($$self, $$props, $$invalidate) {
	let $slotHeight;
	let $_slotTimeLimits;
	let $slotDuration;
	let $_today;
	let $_now;
	let $theme;
	let { slotDuration, slotHeight, theme, _now, _today } = getContext('state');
	component_subscribe($$self, slotDuration, value => $$invalidate(11, $slotDuration = value));
	component_subscribe($$self, slotHeight, value => $$invalidate(9, $slotHeight = value));
	component_subscribe($$self, theme, value => $$invalidate(1, $theme = value));
	component_subscribe($$self, _now, value => $$invalidate(13, $_now = value));
	component_subscribe($$self, _today, value => $$invalidate(12, $_today = value));
	let { _slotTimeLimits } = getContext('view-state');
	component_subscribe($$self, _slotTimeLimits, value => $$invalidate(10, $_slotTimeLimits = value));
	let start;
	let top = 0;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$_now, $_today*/ 12288) {
			$$invalidate(8, start = ($_now - $_today) / 1000 / 60);
		}

		if ($$self.$$.dirty & /*$slotDuration, $_slotTimeLimits, start, $slotHeight*/ 3840) {
			{
				// Style
				let step = $slotDuration.seconds / 60;

				let offset = $_slotTimeLimits.min.seconds / 60;
				$$invalidate(0, top = (start - offset) / step * $slotHeight);
			}
		}
	};

	return [
		top,
		$theme,
		slotDuration,
		slotHeight,
		theme,
		_now,
		_today,
		_slotTimeLimits,
		start,
		$slotHeight,
		$_slotTimeLimits,
		$slotDuration,
		$_today,
		$_now
	];
}

class NowIndicator extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$5$1, create_fragment$5$1, safe_not_equal, {});
	}
}

/* packages/time-grid/src/Day.svelte generated by Svelte v3.55.1 */

function get_each_context$3$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[42] = list[i];
	return child_ctx;
}

function get_each_context_1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[42] = list[i];
	return child_ctx;
}

// (117:8) {#each bgChunks as chunk (chunk.event)}
function create_each_block_1$1(key_1, ctx) {
	let first;
	let event;
	let current;

	event = new Event$1$1({
			props: {
				date: /*date*/ ctx[0],
				chunk: /*chunk*/ ctx[42]
			}
		});

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			create_component(event.$$.fragment);
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);
			mount_component(event, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const event_changes = {};
			if (dirty[0] & /*date*/ 1) event_changes.date = /*date*/ ctx[0];
			if (dirty[0] & /*bgChunks*/ 8) event_changes.chunk = /*chunk*/ ctx[42];
			event.$set(event_changes);
		},
		i(local) {
			if (current) return;
			transition_in(event.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(event.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			destroy_component(event, detaching);
		}
	};
}

// (123:8) {#if iChunks[1]}
function create_if_block_2$2(ctx) {
	let event;
	let current;

	event = new Event$1$1({
			props: {
				date: /*date*/ ctx[0],
				chunk: /*iChunks*/ ctx[4][1]
			}
		});

	return {
		c() {
			create_component(event.$$.fragment);
		},
		m(target, anchor) {
			mount_component(event, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const event_changes = {};
			if (dirty[0] & /*date*/ 1) event_changes.date = /*date*/ ctx[0];
			if (dirty[0] & /*iChunks*/ 16) event_changes.chunk = /*iChunks*/ ctx[4][1];
			event.$set(event_changes);
		},
		i(local) {
			if (current) return;
			transition_in(event.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(event.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(event, detaching);
		}
	};
}

// (126:8) {#each chunks as chunk (chunk.event)}
function create_each_block$3$1(key_1, ctx) {
	let first;
	let event;
	let current;

	event = new Event$1$1({
			props: {
				date: /*date*/ ctx[0],
				chunk: /*chunk*/ ctx[42]
			}
		});

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			create_component(event.$$.fragment);
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);
			mount_component(event, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const event_changes = {};
			if (dirty[0] & /*date*/ 1) event_changes.date = /*date*/ ctx[0];
			if (dirty[0] & /*chunks*/ 4) event_changes.chunk = /*chunk*/ ctx[42];
			event.$set(event_changes);
		},
		i(local) {
			if (current) return;
			transition_in(event.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(event.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			destroy_component(event, detaching);
		}
	};
}

// (130:8) {#if iChunks[0] && !iChunks[0].event.allDay}
function create_if_block_1$2(ctx) {
	let event;
	let current;

	event = new Event$1$1({
			props: {
				date: /*date*/ ctx[0],
				chunk: /*iChunks*/ ctx[4][0]
			}
		});

	return {
		c() {
			create_component(event.$$.fragment);
		},
		m(target, anchor) {
			mount_component(event, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const event_changes = {};
			if (dirty[0] & /*date*/ 1) event_changes.date = /*date*/ ctx[0];
			if (dirty[0] & /*iChunks*/ 16) event_changes.chunk = /*iChunks*/ ctx[4][0];
			event.$set(event_changes);
		},
		i(local) {
			if (current) return;
			transition_in(event.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(event.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(event, detaching);
		}
	};
}

// (136:8) {#if $nowIndicator && isToday}
function create_if_block$2$1(ctx) {
	let nowindicator;
	let current;
	nowindicator = new NowIndicator({});

	return {
		c() {
			create_component(nowindicator.$$.fragment);
		},
		m(target, anchor) {
			mount_component(nowindicator, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(nowindicator.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(nowindicator.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(nowindicator, detaching);
		}
	};
}

function create_fragment$4$1(ctx) {
	let div3;
	let div0;
	let each_blocks_1 = [];
	let each0_lookup = new Map();
	let div0_class_value;
	let t0;
	let div1;
	let t1;
	let each_blocks = [];
	let each1_lookup = new Map();
	let t2;
	let div1_class_value;
	let t3;
	let div2;
	let div2_class_value;
	let div3_class_value;
	let current;
	let mounted;
	let dispose;
	let each_value_1 = /*bgChunks*/ ctx[3];
	const get_key = ctx => /*chunk*/ ctx[42].event;

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1$1(ctx, each_value_1, i);
		let key = get_key(child_ctx);
		each0_lookup.set(key, each_blocks_1[i] = create_each_block_1$1(key, child_ctx));
	}

	let if_block0 = /*iChunks*/ ctx[4][1] && create_if_block_2$2(ctx);
	let each_value = /*chunks*/ ctx[2];
	const get_key_1 = ctx => /*chunk*/ ctx[42].event;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$3$1(ctx, each_value, i);
		let key = get_key_1(child_ctx);
		each1_lookup.set(key, each_blocks[i] = create_each_block$3$1(key, child_ctx));
	}

	let if_block1 = /*iChunks*/ ctx[4][0] && !/*iChunks*/ ctx[4][0].event.allDay && create_if_block_1$2(ctx);
	let if_block2 = /*$nowIndicator*/ ctx[11] && /*isToday*/ ctx[5] && create_if_block$2$1();

	return {
		c() {
			div3 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t0 = space();
			div1 = element("div");
			if (if_block0) if_block0.c();
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			div2 = element("div");
			if (if_block2) if_block2.c();
			attr(div0, "class", div0_class_value = /*$theme*/ ctx[7].bgEvents);
			attr(div1, "class", div1_class_value = /*$theme*/ ctx[7].events);
			attr(div2, "class", div2_class_value = /*$theme*/ ctx[7].extra);

			attr(div3, "class", div3_class_value = "" + (/*$theme*/ ctx[7].day + (/*isToday*/ ctx[5] ? ' ' + /*$theme*/ ctx[7].today : '') + (/*highlight*/ ctx[6]
			? ' ' + /*$theme*/ ctx[7].highlight
			: '')));
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div0);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div0, null);
			}

			append(div3, t0);
			append(div3, div1);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			append(div1, t2);
			if (if_block1) if_block1.m(div1, null);
			append(div3, t3);
			append(div3, div2);
			if (if_block2) if_block2.m(div2, null);
			/*div3_binding*/ ctx[36](div3);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div3, "click", function () {
						if (is_function(maybeIgnore(/*createClickHandler*/ ctx[25](/*$dateClick*/ ctx[8])))) maybeIgnore(/*createClickHandler*/ ctx[25](/*$dateClick*/ ctx[8])).apply(this, arguments);
					}),
					listen(div3, "pointerenter", function () {
						if (is_function(/*createPointerEnterHandler*/ ctx[26](/*$_interaction*/ ctx[9]))) /*createPointerEnterHandler*/ ctx[26](/*$_interaction*/ ctx[9]).apply(this, arguments);
					}),
					listen(div3, "pointerleave", function () {
						if (is_function(createPointerLeaveHandler$1(/*$_interaction*/ ctx[9]))) createPointerLeaveHandler$1(/*$_interaction*/ ctx[9]).apply(this, arguments);
					}),
					listen(div3, "pointerdown", function () {
						if (is_function(/*createPointerDownHandler*/ ctx[27](/*$_interaction*/ ctx[9], /*$selectable*/ ctx[10]))) /*createPointerDownHandler*/ ctx[27](/*$_interaction*/ ctx[9], /*$selectable*/ ctx[10]).apply(this, arguments);
					})
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*date, bgChunks*/ 9) {
				each_value_1 = /*bgChunks*/ ctx[3];
				group_outros();
				each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx, each_value_1, each0_lookup, div0, outro_and_destroy_block, create_each_block_1$1, null, get_each_context_1$1);
				check_outros();
			}

			if (!current || dirty[0] & /*$theme*/ 128 && div0_class_value !== (div0_class_value = /*$theme*/ ctx[7].bgEvents)) {
				attr(div0, "class", div0_class_value);
			}

			if (/*iChunks*/ ctx[4][1]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*iChunks*/ 16) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (dirty[0] & /*date, chunks*/ 5) {
				each_value = /*chunks*/ ctx[2];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx, each_value, each1_lookup, div1, outro_and_destroy_block, create_each_block$3$1, t2, get_each_context$3$1);
				check_outros();
			}

			if (/*iChunks*/ ctx[4][0] && !/*iChunks*/ ctx[4][0].event.allDay) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*iChunks*/ 16) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*$theme*/ 128 && div1_class_value !== (div1_class_value = /*$theme*/ ctx[7].events)) {
				attr(div1, "class", div1_class_value);
			}

			if (/*$nowIndicator*/ ctx[11] && /*isToday*/ ctx[5]) {
				if (if_block2) {
					if (dirty[0] & /*$nowIndicator, isToday*/ 2080) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block$2$1();
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div2, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*$theme*/ 128 && div2_class_value !== (div2_class_value = /*$theme*/ ctx[7].extra)) {
				attr(div2, "class", div2_class_value);
			}

			if (!current || dirty[0] & /*$theme, isToday, highlight*/ 224 && div3_class_value !== (div3_class_value = "" + (/*$theme*/ ctx[7].day + (/*isToday*/ ctx[5] ? ' ' + /*$theme*/ ctx[7].today : '') + (/*highlight*/ ctx[6]
			? ' ' + /*$theme*/ ctx[7].highlight
			: '')))) {
				attr(div3, "class", div3_class_value);
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks_1[i]);
			}

			transition_in(if_block0);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(if_block1);
			transition_in(if_block2);
			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks_1.length; i += 1) {
				transition_out(each_blocks_1[i]);
			}

			transition_out(if_block0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(if_block1);
			transition_out(if_block2);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div3);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].d();
			}

			if (if_block0) if_block0.d();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			/*div3_binding*/ ctx[36](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function createPointerLeaveHandler$1(interaction) {
	return interaction.pointer
	? interaction.pointer.leave
	: undefined;
}

function instance$4$1($$self, $$props, $$invalidate) {
	let $_slotTimeLimits;
	let $_view;
	let $slotDuration;
	let $slotHeight;
	let $highlightedDates;
	let $_today;
	let $_iEvents;
	let $_events;
	let $theme;
	let $dateClick;
	let $_interaction;
	let $selectable;
	let $nowIndicator;
	let { date } = $$props;
	let { resource = undefined } = $$props;
	let { _events, _iEvents, dateClick, highlightedDates, nowIndicator, slotDuration, slotHeight, selectable, theme, _interaction, _today, _view } = getContext('state');
	component_subscribe($$self, _events, value => $$invalidate(35, $_events = value));
	component_subscribe($$self, _iEvents, value => $$invalidate(34, $_iEvents = value));
	component_subscribe($$self, dateClick, value => $$invalidate(8, $dateClick = value));
	component_subscribe($$self, highlightedDates, value => $$invalidate(32, $highlightedDates = value));
	component_subscribe($$self, nowIndicator, value => $$invalidate(11, $nowIndicator = value));
	component_subscribe($$self, slotDuration, value => $$invalidate(38, $slotDuration = value));
	component_subscribe($$self, slotHeight, value => $$invalidate(39, $slotHeight = value));
	component_subscribe($$self, selectable, value => $$invalidate(10, $selectable = value));
	component_subscribe($$self, theme, value => $$invalidate(7, $theme = value));
	component_subscribe($$self, _interaction, value => $$invalidate(9, $_interaction = value));
	component_subscribe($$self, _today, value => $$invalidate(33, $_today = value));
	component_subscribe($$self, _view, value => $$invalidate(37, $_view = value));
	let { _slotTimeLimits, _viewResources } = getContext('view-state');
	component_subscribe($$self, _slotTimeLimits, value => $$invalidate(31, $_slotTimeLimits = value));
	let el;
	let chunks, bgChunks, iChunks = [];
	let isToday, highlight;
	let start, end;

	function dateFromPoint(y) {
		y -= rect(el).top;
		return addDuration(cloneDate(date), $slotDuration, Math.floor(y / $slotHeight + $_slotTimeLimits.min.seconds / $slotDuration.seconds));
	}

	function createClickHandler(fn) {
		return is_function(fn)
		? jsEvent => {
				let d = dateFromPoint(jsEvent.clientY);

				fn({
					allDay: false,
					date: toLocalDate$1(d),
					dateStr: toISOString(d),
					dayEl: el,
					jsEvent,
					view: toViewWithLocalDates($_view),
					resource
				});
			}
		: undefined;
	}

	function createPointerEnterHandler(interaction) {
		return interaction.pointer
		? jsEvent => interaction.pointer.enterTimeGrid(date, el, jsEvent, _slotTimeLimits, resource)
		: undefined;
	}

	function createPointerDownHandler(interaction, selectable) {
		return selectable && interaction.action
		? jsEvent => interaction.action.selectTimeGrid(date, el, jsEvent, _viewResources, $_slotTimeLimits, false)
		: undefined;
	}

	function div3_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(1, el);
		});
	}

	$$self.$$set = $$props => {
		if ('date' in $$props) $$invalidate(0, date = $$props.date);
		if ('resource' in $$props) $$invalidate(28, resource = $$props.resource);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*date*/ 1 | $$self.$$.dirty[1] & /*$_slotTimeLimits*/ 1) {
			{
				$$invalidate(29, start = addDuration(cloneDate(date), $_slotTimeLimits.min));
				$$invalidate(30, end = addDuration(cloneDate(date), $_slotTimeLimits.max));
			}
		}

		if ($$self.$$.dirty[0] & /*start, end, resource, bgChunks, chunks*/ 1879048204 | $$self.$$.dirty[1] & /*$_events*/ 16) {
			{
				$$invalidate(2, chunks = []);
				$$invalidate(3, bgChunks = []);

				for (let event of $_events) {
					if (!event.allDay && eventIntersects(event, start, end, resource, true)) {
						let chunk = createEventChunk(event, start, end);

						switch (event.display) {
							case 'background':
								bgChunks.push(chunk);
								break;
							default:
								chunks.push(chunk);
						}
					}
				}

				groupEventChunks(chunks);
			}
		}

		if ($$self.$$.dirty[0] & /*start, end, resource*/ 1879048192 | $$self.$$.dirty[1] & /*$_iEvents*/ 8) {
			$$invalidate(4, iChunks = $_iEvents.map(event => event && eventIntersects(event, start, end, resource, true)
			? createEventChunk(event, start, end)
			: null));
		}

		if ($$self.$$.dirty[0] & /*date*/ 1 | $$self.$$.dirty[1] & /*$_today*/ 4) {
			$$invalidate(5, isToday = datesEqual(date, $_today));
		}

		if ($$self.$$.dirty[0] & /*date*/ 1 | $$self.$$.dirty[1] & /*$highlightedDates*/ 2) {
			$$invalidate(6, highlight = $highlightedDates.some(d => datesEqual(d, date)));
		}

		if ($$self.$$.dirty[0] & /*el*/ 2) {
			if (el) {
				setFn(el, dateFromPoint);
			}
		}
	};

	return [
		date,
		el,
		chunks,
		bgChunks,
		iChunks,
		isToday,
		highlight,
		$theme,
		$dateClick,
		$_interaction,
		$selectable,
		$nowIndicator,
		_events,
		_iEvents,
		dateClick,
		highlightedDates,
		nowIndicator,
		slotDuration,
		slotHeight,
		selectable,
		theme,
		_interaction,
		_today,
		_view,
		_slotTimeLimits,
		createClickHandler,
		createPointerEnterHandler,
		createPointerDownHandler,
		resource,
		start,
		end,
		$_slotTimeLimits,
		$highlightedDates,
		$_today,
		$_iEvents,
		$_events,
		div3_binding
	];
}

class Day$1$1 extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$4$1, create_fragment$4$1, safe_not_equal, { date: 0, resource: 28 }, null, [-1, -1]);
	}
}

/* packages/time-grid/src/all-day/Event.svelte generated by Svelte v3.55.1 */

function create_fragment$3$3(ctx) {
	let div1;
	let div0;
	let div0_class_value;
	let setContent_action;
	let t;
	let switch_instance;
	let current;
	let mounted;
	let dispose;
	var switch_value = /*$_interaction*/ ctx[7].resizer;

	function switch_props(ctx) {
		return { props: { event: /*event*/ ctx[0] } };
	}

	if (switch_value) {
		switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		switch_instance.$on("pointerdown", /*createDragHandler*/ ctx[27](true));
	}

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			t = space();
			if (switch_instance) create_component(switch_instance.$$.fragment);
			attr(div0, "class", div0_class_value = /*$theme*/ ctx[1].eventBody);
			attr(div1, "class", /*classes*/ ctx[3]);
			attr(div1, "style", /*style*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div1, t);
			if (switch_instance) mount_component(switch_instance, div1, null);
			/*div1_binding*/ ctx[39](div1);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(setContent_action = setContent$1.call(null, div0, /*content*/ ctx[5])),
					listen(div1, "click", function () {
						if (is_function(maybeIgnore(/*createHandler*/ ctx[26](/*$eventClick*/ ctx[8], /*display*/ ctx[6])))) maybeIgnore(/*createHandler*/ ctx[26](/*$eventClick*/ ctx[8], /*display*/ ctx[6])).apply(this, arguments);
					}),
					listen(div1, "mouseenter", function () {
						if (is_function(/*createHandler*/ ctx[26](/*$eventMouseEnter*/ ctx[9], /*display*/ ctx[6]))) /*createHandler*/ ctx[26](/*$eventMouseEnter*/ ctx[9], /*display*/ ctx[6]).apply(this, arguments);
					}),
					listen(div1, "mouseleave", function () {
						if (is_function(/*createHandler*/ ctx[26](/*$eventMouseLeave*/ ctx[10], /*display*/ ctx[6]))) /*createHandler*/ ctx[26](/*$eventMouseLeave*/ ctx[10], /*display*/ ctx[6]).apply(this, arguments);
					}),
					listen(div1, "pointerdown", function () {
						if (is_function(/*display*/ ctx[6] === 'auto' && /*$_draggable*/ ctx[11](/*event*/ ctx[0])
						? /*createDragHandler*/ ctx[27]()
						: undefined)) (/*display*/ ctx[6] === 'auto' && /*$_draggable*/ ctx[11](/*event*/ ctx[0])
						? /*createDragHandler*/ ctx[27]()
						: undefined).apply(this, arguments);
					})
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (!current || dirty[0] & /*$theme*/ 2 && div0_class_value !== (div0_class_value = /*$theme*/ ctx[1].eventBody)) {
				attr(div0, "class", div0_class_value);
			}

			if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*content*/ 32) setContent_action.update.call(null, /*content*/ ctx[5]);
			const switch_instance_changes = {};
			if (dirty[0] & /*event*/ 1) switch_instance_changes.event = /*event*/ ctx[0];

			if (switch_value !== (switch_value = /*$_interaction*/ ctx[7].resizer)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
					switch_instance.$on("pointerdown", /*createDragHandler*/ ctx[27](true));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, div1, null);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}

			if (!current || dirty[0] & /*classes*/ 8) {
				attr(div1, "class", /*classes*/ ctx[3]);
			}

			if (!current || dirty[0] & /*style*/ 16) {
				attr(div1, "style", /*style*/ ctx[4]);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (switch_instance) destroy_component(switch_instance);
			/*div1_binding*/ ctx[39](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$3$3($$self, $$props, $$invalidate) {
	let $_interaction;
	let $_view;
	let $eventDidMount;
	let $_intlEventTime;
	let $theme;
	let $eventContent;
	let $displayEventEnd;
	let $_classes;
	let $eventColor;
	let $eventBackgroundColor;
	let $eventClick;
	let $eventMouseEnter;
	let $eventMouseLeave;
	let $_draggable;
	let { chunk } = $$props;
	let { longChunks = {} } = $$props;
	let { displayEventEnd, eventBackgroundColor, eventClick, eventColor, eventContent, eventDidMount, eventMouseEnter, eventMouseLeave, theme, _view, _intlEventTime, _interaction, _classes, _draggable } = getContext('state');
	component_subscribe($$self, displayEventEnd, value => $$invalidate(35, $displayEventEnd = value));
	component_subscribe($$self, eventBackgroundColor, value => $$invalidate(38, $eventBackgroundColor = value));
	component_subscribe($$self, eventClick, value => $$invalidate(8, $eventClick = value));
	component_subscribe($$self, eventColor, value => $$invalidate(37, $eventColor = value));
	component_subscribe($$self, eventContent, value => $$invalidate(34, $eventContent = value));
	component_subscribe($$self, eventDidMount, value => $$invalidate(41, $eventDidMount = value));
	component_subscribe($$self, eventMouseEnter, value => $$invalidate(9, $eventMouseEnter = value));
	component_subscribe($$self, eventMouseLeave, value => $$invalidate(10, $eventMouseLeave = value));
	component_subscribe($$self, theme, value => $$invalidate(1, $theme = value));
	component_subscribe($$self, _view, value => $$invalidate(32, $_view = value));
	component_subscribe($$self, _intlEventTime, value => $$invalidate(33, $_intlEventTime = value));
	component_subscribe($$self, _interaction, value => $$invalidate(7, $_interaction = value));
	component_subscribe($$self, _classes, value => $$invalidate(36, $_classes = value));
	component_subscribe($$self, _draggable, value => $$invalidate(11, $_draggable = value));
	let { _viewResources } = getContext('view-state');
	createEventDispatcher();
	let el;
	let event;
	let classes;
	let style;
	let content;
	let timeText;
	let margin = 1;
	let display;

	onMount(() => {
		if (is_function($eventDidMount)) {
			$eventDidMount({
				event: toEventWithLocalDates(event),
				timeText,
				el,
				view: toViewWithLocalDates($_view)
			});
		}
	});

	function createHandler(fn, display) {
		return display !== 'preview' && is_function(fn)
		? jsEvent => fn({
				event: toEventWithLocalDates(event),
				el,
				jsEvent,
				view: toViewWithLocalDates($_view)
			})
		: undefined;
	}

	function createDragHandler(resize) {
		return jsEvent => $_interaction.action.dragTimeGrid(event, el, jsEvent, _viewResources, true, resize);
	}

	function reposition() {
		if (!el || display === 'preview') {
			return;
		}

		$$invalidate(31, margin = repositionEvent(chunk, longChunks, height(el)));
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(2, el);
		});
	}

	$$self.$$set = $$props => {
		if ('chunk' in $$props) $$invalidate(28, chunk = $$props.chunk);
		if ('longChunks' in $$props) $$invalidate(29, longChunks = $$props.longChunks);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*chunk*/ 268435456) {
			$$invalidate(0, event = chunk.event);
		}

		if ($$self.$$.dirty[0] & /*event, chunk, style, $theme*/ 268435475 | $$self.$$.dirty[1] & /*$eventBackgroundColor, $eventColor, margin, $_classes*/ 225) {
			{
				$$invalidate(6, display = event.display);

				// Class & Style
				let bgColor = event.backgroundColor || $eventBackgroundColor || $eventColor;

				$$invalidate(4, style = `width:calc(${chunk.days * 100}% + ${(chunk.days - 1) * 7}px);` + `margin-top:${margin}px;`);

				if (bgColor) {
					$$invalidate(4, style += `background-color:${bgColor};`);
				}

				$$invalidate(3, classes = $_classes($theme.event, event));
			}
		}

		if ($$self.$$.dirty[0] & /*chunk, $theme*/ 268435458 | $$self.$$.dirty[1] & /*$displayEventEnd, $eventContent, $_intlEventTime, $_view*/ 30) {
			// Content
			$$invalidate(5, [timeText, content] = createEventContent(chunk, $displayEventEnd, $eventContent, $theme, $_intlEventTime, $_view), content);
		}
	};

	return [
		event,
		$theme,
		el,
		classes,
		style,
		content,
		display,
		$_interaction,
		$eventClick,
		$eventMouseEnter,
		$eventMouseLeave,
		$_draggable,
		displayEventEnd,
		eventBackgroundColor,
		eventClick,
		eventColor,
		eventContent,
		eventDidMount,
		eventMouseEnter,
		eventMouseLeave,
		theme,
		_view,
		_intlEventTime,
		_interaction,
		_classes,
		_draggable,
		createHandler,
		createDragHandler,
		chunk,
		longChunks,
		reposition,
		margin,
		$_view,
		$_intlEventTime,
		$eventContent,
		$displayEventEnd,
		$_classes,
		$eventColor,
		$eventBackgroundColor,
		div1_binding
	];
}

class Event$3 extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$3$3,
			create_fragment$3$3,
			safe_not_equal,
			{
				chunk: 28,
				longChunks: 29,
				reposition: 30
			},
			null,
			[-1, -1]
		);
	}

	get reposition() {
		return this.$$.ctx[30];
	}
}

/* packages/time-grid/src/all-day/Day.svelte generated by Svelte v3.55.1 */

function get_each_context$2$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[32] = list[i];
	child_ctx[33] = list;
	child_ctx[34] = i;
	return child_ctx;
}

// (90:4) {#if iChunks[0] && datesEqual(iChunks[0].date, date)}
function create_if_block$1$2(ctx) {
	let div;
	let event;
	let div_class_value;
	let current;
	event = new Event$3({ props: { chunk: /*iChunks*/ ctx[2][0] } });

	return {
		c() {
			div = element("div");
			create_component(event.$$.fragment);
			attr(div, "class", div_class_value = "" + (/*$theme*/ ctx[8].events + " " + /*$theme*/ ctx[8].preview));
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(event, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const event_changes = {};
			if (dirty[0] & /*iChunks*/ 4) event_changes.chunk = /*iChunks*/ ctx[2][0];
			event.$set(event_changes);

			if (!current || dirty[0] & /*$theme*/ 256 && div_class_value !== (div_class_value = "" + (/*$theme*/ ctx[8].events + " " + /*$theme*/ ctx[8].preview))) {
				attr(div, "class", div_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(event.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(event.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(event);
		}
	};
}

// (96:8) {#each dayChunks as chunk, i (chunk.event)}
function create_each_block$2$1(key_1, ctx) {
	let first;
	let event;
	let i = /*i*/ ctx[34];
	let current;
	const assign_event = () => /*event_binding*/ ctx[25](event, i);
	const unassign_event = () => /*event_binding*/ ctx[25](null, i);

	let event_props = {
		chunk: /*chunk*/ ctx[32],
		longChunks: /*longChunks*/ ctx[1]
	};

	event = new Event$3({ props: event_props });
	assign_event();

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			create_component(event.$$.fragment);
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);
			mount_component(event, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (i !== /*i*/ ctx[34]) {
				unassign_event();
				i = /*i*/ ctx[34];
				assign_event();
			}

			const event_changes = {};
			if (dirty[0] & /*dayChunks*/ 16) event_changes.chunk = /*chunk*/ ctx[32];
			if (dirty[0] & /*longChunks*/ 2) event_changes.longChunks = /*longChunks*/ ctx[1];
			event.$set(event_changes);
		},
		i(local) {
			if (current) return;
			transition_in(event.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(event.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			unassign_event();
			destroy_component(event, detaching);
		}
	};
}

function create_fragment$2$3(ctx) {
	let div1;
	let show_if = /*iChunks*/ ctx[2][0] && datesEqual(/*iChunks*/ ctx[2][0].date, /*date*/ ctx[0]);
	let t;
	let div0;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let div0_class_value;
	let div1_class_value;
	let current;
	let mounted;
	let dispose;
	let if_block = show_if && create_if_block$1$2(ctx);
	let each_value = /*dayChunks*/ ctx[4];
	const get_key = ctx => /*chunk*/ ctx[32].event;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$2$1(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$2$1(key, child_ctx));
	}

	return {
		c() {
			div1 = element("div");
			if (if_block) if_block.c();
			t = space();
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div0, "class", div0_class_value = /*$theme*/ ctx[8].events);

			attr(div1, "class", div1_class_value = "" + (/*$theme*/ ctx[8].day + (/*isToday*/ ctx[5] ? ' ' + /*$theme*/ ctx[8].today : '') + (/*highlight*/ ctx[6]
			? ' ' + /*$theme*/ ctx[8].highlight
			: '')));
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			if (if_block) if_block.m(div1, null);
			append(div1, t);
			append(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			/*div1_binding*/ ctx[26](div1);
			current = true;

			if (!mounted) {
				dispose = [
					listen(window, "resize", /*reposition*/ ctx[21]),
					listen(div1, "click", function () {
						if (is_function(maybeIgnore(/*createClickHandler*/ ctx[19](/*$dateClick*/ ctx[9])))) maybeIgnore(/*createClickHandler*/ ctx[19](/*$dateClick*/ ctx[9])).apply(this, arguments);
					}),
					listen(div1, "pointerdown", function () {
						if (is_function(/*createPointerDownHandler*/ ctx[20](/*$_interaction*/ ctx[10], /*$selectable*/ ctx[11]))) /*createPointerDownHandler*/ ctx[20](/*$_interaction*/ ctx[10], /*$selectable*/ ctx[11]).apply(this, arguments);
					})
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*iChunks, date*/ 5) show_if = /*iChunks*/ ctx[2][0] && datesEqual(/*iChunks*/ ctx[2][0].date, /*date*/ ctx[0]);

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*iChunks, date*/ 5) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$1$2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (dirty[0] & /*dayChunks, longChunks, refs*/ 146) {
				each_value = /*dayChunks*/ ctx[4];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block$2$1, null, get_each_context$2$1);
				check_outros();
			}

			if (!current || dirty[0] & /*$theme*/ 256 && div0_class_value !== (div0_class_value = /*$theme*/ ctx[8].events)) {
				attr(div0, "class", div0_class_value);
			}

			if (!current || dirty[0] & /*$theme, isToday, highlight*/ 352 && div1_class_value !== (div1_class_value = "" + (/*$theme*/ ctx[8].day + (/*isToday*/ ctx[5] ? ' ' + /*$theme*/ ctx[8].today : '') + (/*highlight*/ ctx[6]
			? ' ' + /*$theme*/ ctx[8].highlight
			: '')))) {
				attr(div1, "class", div1_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			transition_out(if_block);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (if_block) if_block.d();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			/*div1_binding*/ ctx[26](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$2$4($$self, $$props, $$invalidate) {
	let $_slotTimeLimits;
	let $_view;
	let $highlightedDates;
	let $theme;
	let $dateClick;
	let $_interaction;
	let $selectable;
	let { date } = $$props;
	let { chunks } = $$props;
	let { longChunks } = $$props;
	let { iChunks = [] } = $$props;
	let { resource = undefined } = $$props;
	let { date: currentDate, dateClick, highlightedDates, theme, _view, _interaction, selectable } = getContext('state');
	component_subscribe($$self, dateClick, value => $$invalidate(9, $dateClick = value));
	component_subscribe($$self, highlightedDates, value => $$invalidate(24, $highlightedDates = value));
	component_subscribe($$self, theme, value => $$invalidate(8, $theme = value));
	component_subscribe($$self, _view, value => $$invalidate(28, $_view = value));
	component_subscribe($$self, _interaction, value => $$invalidate(10, $_interaction = value));
	component_subscribe($$self, selectable, value => $$invalidate(11, $selectable = value));
	let { _slotTimeLimits, _viewResources } = getContext('view-state');
	component_subscribe($$self, _slotTimeLimits, value => $$invalidate(27, $_slotTimeLimits = value));
	let el;
	let dayChunks;
	let today = setMidnight(createDate());
	let isToday;
	let highlight;
	let refs = [];

	function createClickHandler(fn) {
		return is_function(fn)
		? jsEvent => {
				fn({
					allDay: true,
					date: toLocalDate$1(date),
					dateStr: toISOString(date),
					dayEl: el,
					jsEvent,
					view: toViewWithLocalDates($_view),
					resource
				});
			}
		: undefined;
	}

	function createPointerDownHandler(interaction, selectable) {
		return selectable && interaction.action
		? jsEvent => interaction.action.selectTimeGrid(date, el, jsEvent, _viewResources, $_slotTimeLimits, true)
		: undefined;
	}

	function reposition() {
		$$invalidate(7, refs.length = dayChunks.length, refs);

		for (let ref of refs) {
			ref && ref.reposition && ref.reposition();
		}
	}

	afterUpdate(reposition);

	function event_binding($$value, i) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			refs[i] = $$value;
			$$invalidate(7, refs);
		});
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(3, el);
		});
	}

	$$self.$$set = $$props => {
		if ('date' in $$props) $$invalidate(0, date = $$props.date);
		if ('chunks' in $$props) $$invalidate(22, chunks = $$props.chunks);
		if ('longChunks' in $$props) $$invalidate(1, longChunks = $$props.longChunks);
		if ('iChunks' in $$props) $$invalidate(2, iChunks = $$props.iChunks);
		if ('resource' in $$props) $$invalidate(23, resource = $$props.resource);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*chunks, date, dayChunks*/ 4194321) {
			{
				$$invalidate(4, dayChunks = []);

				for (let chunk of chunks) {
					if (datesEqual(chunk.date, date)) {
						dayChunks.push(chunk);
					}
				}
			}
		}

		if ($$self.$$.dirty[0] & /*date, $highlightedDates*/ 16777217) {
			{
				$$invalidate(5, isToday = datesEqual(date, today));
				$$invalidate(6, highlight = $highlightedDates.some(d => datesEqual(d, date)));
			}
		}

		if ($$self.$$.dirty[0] & /*el, date*/ 9) {
			// dateFromPoint
			if (el) {
				setFn(el, () => date);
			}
		}
	};

	return [
		date,
		longChunks,
		iChunks,
		el,
		dayChunks,
		isToday,
		highlight,
		refs,
		$theme,
		$dateClick,
		$_interaction,
		$selectable,
		dateClick,
		highlightedDates,
		theme,
		_view,
		_interaction,
		selectable,
		_slotTimeLimits,
		createClickHandler,
		createPointerDownHandler,
		reposition,
		chunks,
		resource,
		$highlightedDates,
		event_binding,
		div1_binding
	];
}

class Day$2 extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$2$4,
			create_fragment$2$3,
			safe_not_equal,
			{
				date: 0,
				chunks: 22,
				longChunks: 1,
				iChunks: 2,
				resource: 23
			},
			null,
			[-1, -1]
		);
	}
}

/* packages/time-grid/src/all-day/Week.svelte generated by Svelte v3.55.1 */

function get_each_context$1$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[14] = list[i];
	return child_ctx;
}

// (45:0) {#each dates as date}
function create_each_block$1$2(ctx) {
	let day;
	let current;

	day = new Day$2({
			props: {
				date: /*date*/ ctx[14],
				chunks: /*chunks*/ ctx[2],
				longChunks: /*longChunks*/ ctx[3],
				iChunks: /*iChunks*/ ctx[4],
				resource: /*resource*/ ctx[1]
			}
		});

	return {
		c() {
			create_component(day.$$.fragment);
		},
		m(target, anchor) {
			mount_component(day, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const day_changes = {};
			if (dirty & /*dates*/ 1) day_changes.date = /*date*/ ctx[14];
			if (dirty & /*chunks*/ 4) day_changes.chunks = /*chunks*/ ctx[2];
			if (dirty & /*longChunks*/ 8) day_changes.longChunks = /*longChunks*/ ctx[3];
			if (dirty & /*iChunks*/ 16) day_changes.iChunks = /*iChunks*/ ctx[4];
			if (dirty & /*resource*/ 2) day_changes.resource = /*resource*/ ctx[1];
			day.$set(day_changes);
		},
		i(local) {
			if (current) return;
			transition_in(day.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(day.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(day, detaching);
		}
	};
}

function create_fragment$1$4(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*dates*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1$2(get_each_context$1$2(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*dates, chunks, longChunks, iChunks, resource*/ 31) {
				each_value = /*dates*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1$2(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

function instance$1$4($$self, $$props, $$invalidate) {
	let $hiddenDays;
	let $_iEvents;
	let $_events;
	let { dates } = $$props;
	let { resource = undefined } = $$props;
	let { _events, _iEvents, hiddenDays, theme } = getContext('state');
	component_subscribe($$self, _events, value => $$invalidate(12, $_events = value));
	component_subscribe($$self, _iEvents, value => $$invalidate(11, $_iEvents = value));
	component_subscribe($$self, hiddenDays, value => $$invalidate(10, $hiddenDays = value));
	let chunks, longChunks, iChunks = [];
	let start;
	let end;

	$$self.$$set = $$props => {
		if ('dates' in $$props) $$invalidate(0, dates = $$props.dates);
		if ('resource' in $$props) $$invalidate(1, resource = $$props.resource);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*dates*/ 1) {
			{
				$$invalidate(8, start = dates[0]);
				$$invalidate(9, end = addDay(cloneDate(dates[dates.length - 1])));
			}
		}

		if ($$self.$$.dirty & /*$_events, start, end, resource, chunks, $hiddenDays*/ 5894) {
			{
				$$invalidate(2, chunks = []);

				for (let event of $_events) {
					if (event.allDay && event.display !== 'background' && eventIntersects(event, start, end, resource)) {
						let chunk = createEventChunk(event, start, end);
						chunks.push(chunk);
					}
				}

				$$invalidate(3, longChunks = prepareEventChunks(chunks, $hiddenDays));
			}
		}

		if ($$self.$$.dirty & /*$_iEvents, start, end, resource, $hiddenDays*/ 3842) {
			$$invalidate(4, iChunks = $_iEvents.map(event => {
				let chunk;

				if (event && event.allDay && eventIntersects(event, start, end, resource)) {
					chunk = createEventChunk(event, start, end);
					prepareEventChunks([chunk], $hiddenDays);
				} else {
					chunk = null;
				}

				return chunk;
			}));
		}
	};

	return [
		dates,
		resource,
		chunks,
		longChunks,
		iChunks,
		_events,
		_iEvents,
		hiddenDays,
		start,
		end,
		$hiddenDays,
		$_iEvents,
		$_events
	];
}

class Week$1 extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1$4, create_fragment$1$4, safe_not_equal, { dates: 0, resource: 1 });
	}
}

/* packages/time-grid/src/View.svelte generated by Svelte v3.55.1 */

function get_each_context$7(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

function get_each_context_1$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

// (18:4) {#each $_viewDates as date}
function create_each_block_1$3(ctx) {
	let div;
	let t_value = /*$_intlDayHeader*/ ctx[2].format(/*date*/ ctx[11]) + "";
	let t;
	let div_class_value;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			attr(div, "class", div_class_value = /*$theme*/ ctx[1].day);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*$_intlDayHeader, $_viewDates*/ 5 && t_value !== (t_value = /*$_intlDayHeader*/ ctx[2].format(/*date*/ ctx[11]) + "")) set_data(t, t_value);

			if (dirty & /*$theme*/ 2 && div_class_value !== (div_class_value = /*$theme*/ ctx[1].day)) {
				attr(div, "class", div_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (17:0) <Header>
function create_default_slot_2$1(ctx) {
	let each_1_anchor;
	let each_value_1 = /*$_viewDates*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*$theme, $_intlDayHeader, $_viewDates*/ 7) {
				each_value_1 = /*$_viewDates*/ ctx[0];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1$3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (22:0) {#if $allDaySlot}
function create_if_block$5(ctx) {
	let header;
	let current;

	header = new Header$1({
			props: {
				allDay: true,
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(header.$$.fragment);
		},
		m(target, anchor) {
			mount_component(header, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const header_changes = {};

			if (dirty & /*$$scope, $_viewDates*/ 65537) {
				header_changes.$$scope = { dirty, ctx };
			}

			header.$set(header_changes);
		},
		i(local) {
			if (current) return;
			transition_in(header.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(header.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(header, detaching);
		}
	};
}

// (23:4) <Header allDay>
function create_default_slot_1$1(ctx) {
	let week;
	let current;
	week = new Week$1({ props: { dates: /*$_viewDates*/ ctx[0] } });

	return {
		c() {
			create_component(week.$$.fragment);
		},
		m(target, anchor) {
			mount_component(week, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const week_changes = {};
			if (dirty & /*$_viewDates*/ 1) week_changes.dates = /*$_viewDates*/ ctx[0];
			week.$set(week_changes);
		},
		i(local) {
			if (current) return;
			transition_in(week.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(week.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(week, detaching);
		}
	};
}

// (28:0) {#each $_viewDates as date}
function create_each_block$7(ctx) {
	let day;
	let current;
	day = new Day$1$1({ props: { date: /*date*/ ctx[11] } });

	return {
		c() {
			create_component(day.$$.fragment);
		},
		m(target, anchor) {
			mount_component(day, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const day_changes = {};
			if (dirty & /*$_viewDates*/ 1) day_changes.date = /*date*/ ctx[11];
			day.$set(day_changes);
		},
		i(local) {
			if (current) return;
			transition_in(day.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(day.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(day, detaching);
		}
	};
}

// (27:0) <Body>
function create_default_slot$3(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*$_viewDates*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*$_viewDates*/ 1) {
				each_value = /*$_viewDates*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$7(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$7(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

function create_fragment$a(ctx) {
	let header;
	let t0;
	let t1;
	let body;
	let current;

	header = new Header$1({
			props: {
				$$slots: { default: [create_default_slot_2$1] },
				$$scope: { ctx }
			}
		});

	let if_block = /*$allDaySlot*/ ctx[3] && create_if_block$5(ctx);

	body = new Body$2({
			props: {
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(header.$$.fragment);
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			create_component(body.$$.fragment);
		},
		m(target, anchor) {
			mount_component(header, target, anchor);
			insert(target, t0, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, t1, anchor);
			mount_component(body, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const header_changes = {};

			if (dirty & /*$$scope, $_viewDates, $theme, $_intlDayHeader*/ 65543) {
				header_changes.$$scope = { dirty, ctx };
			}

			header.$set(header_changes);

			if (/*$allDaySlot*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*$allDaySlot*/ 8) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$5(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t1.parentNode, t1);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const body_changes = {};

			if (dirty & /*$$scope, $_viewDates*/ 65537) {
				body_changes.$$scope = { dirty, ctx };
			}

			body.$set(body_changes);
		},
		i(local) {
			if (current) return;
			transition_in(header.$$.fragment, local);
			transition_in(if_block);
			transition_in(body.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(header.$$.fragment, local);
			transition_out(if_block);
			transition_out(body.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(header, detaching);
			if (detaching) detach(t0);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t1);
			destroy_component(body, detaching);
		}
	};
}

function instance$a($$self, $$props, $$invalidate) {
	let $_viewClass;
	let $_viewDates;
	let $theme;
	let $_intlDayHeader;
	let $allDaySlot;
	let state = getContext('state');
	let { _viewDates, _intlDayHeader, _viewClass, allDaySlot, theme } = state;
	component_subscribe($$self, _viewDates, value => $$invalidate(0, $_viewDates = value));
	component_subscribe($$self, _intlDayHeader, value => $$invalidate(2, $_intlDayHeader = value));
	component_subscribe($$self, _viewClass, value => $$invalidate(9, $_viewClass = value));
	component_subscribe($$self, allDaySlot, value => $$invalidate(3, $allDaySlot = value));
	component_subscribe($$self, theme, value => $$invalidate(1, $theme = value));
	setContext('view-state', new State$3(state));
	set_store_value(_viewClass, $_viewClass = 'week', $_viewClass);

	return [
		$_viewDates,
		$theme,
		$_intlDayHeader,
		$allDaySlot,
		_viewDates,
		_intlDayHeader,
		_viewClass,
		allDaySlot,
		theme
	];
}

class View$3 extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});
	}
}

var index$4 = {
	createOptions(options) {
		// Common options
		options.buttonText.timeGridDay = 'day';
		options.buttonText.timeGridWeek = 'week';
		options.view = 'timeGridWeek';
		options.views.timeGridDay = {
			component: View$3,
			dayHeaderFormat: {weekday: 'long'},
			duration: {days: 1},
			titleFormat: {year: 'numeric', month: 'long', day: 'numeric'}
		};
		options.views.timeGridWeek = {
			component: View$3,
			duration: {weeks: 1}
		};
	}
};

function traverseTimeGrid(dayEl) {
    let colEl = child(ancestor(dayEl, 1), 1);
    let bodyEl = ancestor(dayEl, 3);
    let col = pos(dayEl) - 1;

    return [colEl, bodyEl, col];
}

function traverseResourceTimeGrid(dayEl, datesAboveResources) {
    let colEl = child(child(ancestor(dayEl, 2), 1), 0);
    let resourceEl = ancestor(dayEl, 1);
    let bodyEl = ancestor(resourceEl, 3);
    let col = pos(dayEl);
    let resourceCol = pos(resourceEl) - 1;

    return datesAboveResources ? [colEl, bodyEl, resourceCol, col] : [colEl, bodyEl, col, resourceCol];
}

function traverseDayGrid(dayEl) {
    let daysEl = ancestor(dayEl, 1);
    let contentEl = ancestor(daysEl, 1);
    let colEl = child(child(contentEl, 0), 0);
    let bodyEl = ancestor(contentEl, 1);
    let col = pos(dayEl);
    let row = pos(daysEl);

    return [colEl, bodyEl, col, row, contentEl.children];
}

function child(el, pos) {
    return el.children[pos];
}

function pos(el) {
    let result = 0;
    while ((el = el.previousElementSibling)) {
        ++result;
    }
    return result;
}

let busy = false;
function animate(fn) {
    if (!busy) {
        busy = true;
        window.requestAnimationFrame(() => {
            fn();
            busy = false;
        });
    }
}

function limit(value, max) {
    return Math.max(0, Math.min(max, value));
}

function floor(value) {
    return Math.floor(value);
}

/* packages/interaction/src/Action.svelte generated by Svelte v3.55.1 */

const { window: window_1 } = globals;

function create_fragment$3$2(ctx) {
	let mounted;
	let dispose;

	return {
		c: noop,
		m(target, anchor) {
			if (!mounted) {
				dispose = [
					listen(window_1, "pointermove", /*handlePointerMove*/ ctx[31]),
					listen(window_1, "pointerup", /*handlePointerUp*/ ctx[32]),
					listen(window_1, "pointercancel", /*handlePointerUp*/ ctx[32]),
					listen(window_1, "scroll", /*handleScroll*/ ctx[0]),
					listen(window_1, "selectstart", function () {
						if (is_function(createPreventDefaultHandler(/*selectstart_handler*/ ctx[40]))) createPreventDefaultHandler(/*selectstart_handler*/ ctx[40]).apply(this, arguments);
					}),
					listen(window_1, "contextmenu", function () {
						if (is_function(createPreventDefaultHandler(/*contextmenu_handler*/ ctx[41]))) createPreventDefaultHandler(/*contextmenu_handler*/ ctx[41]).apply(this, arguments);
					}),
					listen(window_1, "touchstart", /*handleTouchStart*/ ctx[33]),
					listen(window_1, "touchmove", /*touchmove_handler*/ ctx[39], { passive: false })
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		i: noop,
		o: noop,
		d(detaching) {
			mounted = false;
			run_all(dispose);
		}
	};
}

const ACTION_DRAG = 1;
const ACTION_RESIZE = 2;
const ACTION_SELECT = 3;
const VIEW_TIME_GRID = 1;
const VIEW_DAY_GRID = 2;

function createPreventDefaultHandler(condition) {
	return jsEvent => {
		if (condition()) {
			jsEvent.preventDefault();
		}
	};
}

function instance$3$2($$self, $$props, $$invalidate) {
	let $_view;
	let $unselectFn;
	let $_events;
	let $_iEvents;
	let $selectBackgroundColor;
	let $_iClass;

	let $_viewResources,
		$$unsubscribe__viewResources = noop,
		$$subscribe__viewResources = () => ($$unsubscribe__viewResources(), $$unsubscribe__viewResources = subscribe(_viewResources, $$value => $$invalidate(71, $_viewResources = $$value)), _viewResources);

	let $eventDrop;
	let $eventResize;
	let $eventDragStop;
	let $eventResizeStop;
	let $select;
	let $unselectCancel;
	let $unselectAuto;
	let $dragScroll;
	let $eventDragStart;
	let $eventResizeStart;
	let $_viewDates;
	let $hiddenDays;
	let $slotDuration;
	let $slotHeight;
	let $datesAboveResources;
	let $_ignoreClick;
	let $eventDragMinDistance;
	let $selectMinDistance;
	let $longPressDelay;
	let $eventLongPressDelay;
	let $selectLongPressDelay;
	$$self.$$.on_destroy.push(() => $$unsubscribe__viewResources());
	let { _iEvents, _iClass, _ignoreClick, _events, _viewDates, _view, datesAboveResources, dragScroll, editable, eventStartEditable, eventDragMinDistance, eventDragStart, eventDragStop, eventDrop, eventLongPressDelay, eventResizeStart, eventResizeStop, eventResize, longPressDelay, select, selectBackgroundColor, selectLongPressDelay, selectMinDistance, slotDuration, slotHeight, hiddenDays, unselect: unselectFn, unselectAuto, unselectCancel } = getContext('state');
	component_subscribe($$self, _iEvents, value => $$invalidate(68, $_iEvents = value));
	component_subscribe($$self, _iClass, value => $$invalidate(70, $_iClass = value));
	component_subscribe($$self, _ignoreClick, value => $$invalidate(87, $_ignoreClick = value));
	component_subscribe($$self, _events, value => $$invalidate(67, $_events = value));
	component_subscribe($$self, _viewDates, value => $$invalidate(82, $_viewDates = value));
	component_subscribe($$self, _view, value => $$invalidate(65, $_view = value));
	component_subscribe($$self, datesAboveResources, value => $$invalidate(86, $datesAboveResources = value));
	component_subscribe($$self, dragScroll, value => $$invalidate(79, $dragScroll = value));
	component_subscribe($$self, eventDragMinDistance, value => $$invalidate(88, $eventDragMinDistance = value));
	component_subscribe($$self, eventDragStart, value => $$invalidate(80, $eventDragStart = value));
	component_subscribe($$self, eventDragStop, value => $$invalidate(74, $eventDragStop = value));
	component_subscribe($$self, eventDrop, value => $$invalidate(72, $eventDrop = value));
	component_subscribe($$self, eventLongPressDelay, value => $$invalidate(91, $eventLongPressDelay = value));
	component_subscribe($$self, eventResizeStart, value => $$invalidate(81, $eventResizeStart = value));
	component_subscribe($$self, eventResizeStop, value => $$invalidate(75, $eventResizeStop = value));
	component_subscribe($$self, eventResize, value => $$invalidate(73, $eventResize = value));
	component_subscribe($$self, longPressDelay, value => $$invalidate(90, $longPressDelay = value));
	component_subscribe($$self, select, value => $$invalidate(76, $select = value));
	component_subscribe($$self, selectBackgroundColor, value => $$invalidate(69, $selectBackgroundColor = value));
	component_subscribe($$self, selectLongPressDelay, value => $$invalidate(92, $selectLongPressDelay = value));
	component_subscribe($$self, selectMinDistance, value => $$invalidate(89, $selectMinDistance = value));
	component_subscribe($$self, slotDuration, value => $$invalidate(84, $slotDuration = value));
	component_subscribe($$self, slotHeight, value => $$invalidate(85, $slotHeight = value));
	component_subscribe($$self, hiddenDays, value => $$invalidate(83, $hiddenDays = value));
	component_subscribe($$self, unselectFn, value => $$invalidate(66, $unselectFn = value));
	component_subscribe($$self, unselectAuto, value => $$invalidate(78, $unselectAuto = value));
	component_subscribe($$self, unselectCancel, value => $$invalidate(77, $unselectCancel = value));
	let action;
	let view;
	let interacting;
	let event;
	let col, row;
	let offsetX, offsetY;
	let fromX, fromY;
	let toX, toY;
	let delta;
	let colEl, rowEls, bodyEl;
	let colRect, bodyRect;
	let _viewResources;
	let resourceCol, newResourceCol;
	let isAllDay = false;
	let iClass;
	let minEnd; // minimum end time when resizing
	let selected; // whether selection has been made
	let timer; // timer for long press delays

	function dragTimeGrid(eventToDrag, el, jsEvent, resourcesStore, allDay, resize) {
		if (!action && jsEvent.isPrimary) {
			$$invalidate(1, action = resize ? ACTION_RESIZE : ACTION_DRAG);
			view = VIEW_TIME_GRID;
			event = eventToDrag;
			$$subscribe__viewResources($$invalidate(2, _viewResources = resourcesStore));
			isAllDay = allDay;
			iClass = resize ? allDay ? 'resizingX' : 'resizingY' : 'dragging';
			let dayEl = ancestor(el, 2);

			if (resourcesStore) {
				[colEl, bodyEl, col, resourceCol] = traverseResourceTimeGrid(dayEl, $datesAboveResources);
			} else {
				[colEl, bodyEl, col] = traverseTimeGrid(dayEl);
			}

			common(jsEvent);
			offsetY = floor((jsEvent.clientY - colRect.top) / $slotHeight);
			offsetX = 0; // applicable for all-day slot

			if (allDay && (!resourcesStore || !$datesAboveResources)) {
				offsetX = floor((jsEvent.clientX - colRect.left) / colRect.width) - col - (resourceCol || 0) * $_viewDates.length;
			}

			if (resize) {
				minEnd = addDuration(cloneDate(event.start), $slotDuration);
			}

			move(jsEvent);
		}
	}

	function dragDayGrid(eventToDrag, el, jsEvent, inPopup, resize) {
		if (!action && jsEvent.isPrimary) {
			$$invalidate(1, action = resize ? ACTION_RESIZE : ACTION_DRAG);
			view = VIEW_DAY_GRID;
			event = eventToDrag;
			iClass = resize ? 'resizingX' : 'dragging';
			let dayEl = ancestor(el, inPopup ? 3 : 2);
			[colEl, bodyEl, col, row, rowEls] = traverseDayGrid(dayEl);
			common(jsEvent);

			offsetX = inPopup
			? 0
			: floor((jsEvent.clientX - colRect.left) / colRect.width) - col;

			if (resize) {
				minEnd = cloneDate(event.start);
				minEnd.setUTCHours(event.end.getUTCHours(), event.end.getUTCMinutes(), event.end.getUTCSeconds());

				if (minEnd < event.start) {
					addDay(minEnd);
				} // minEnd = addDuration(cloneDate(event.start), $slotDuration);  alternative version
			}

			move(jsEvent);
		}
	}

	function selectTimeGrid(colDate, dayEl, jsEvent, resourcesStore, _slotTimeLimits, allDay) {
		if (!action && jsEvent.isPrimary) {
			$$invalidate(1, action = ACTION_SELECT);
			view = VIEW_TIME_GRID;
			$$subscribe__viewResources($$invalidate(2, _viewResources = resourcesStore));
			isAllDay = allDay;
			iClass = 'selecting';

			if (resourcesStore) {
				[colEl, bodyEl, col, resourceCol] = traverseResourceTimeGrid(dayEl, $datesAboveResources);
			} else {
				[colEl, bodyEl, col] = traverseTimeGrid(dayEl);
			}

			common(jsEvent);
			offsetY = floor((jsEvent.clientY - colRect.top) / $slotHeight);
			offsetX = 0; // applicable for all-day slot

			if (allDay && (!resourcesStore || !$datesAboveResources)) {
				offsetX = floor((jsEvent.clientX - colRect.left) / colRect.width) - col - (resourceCol || 0) * $_viewDates.length;
			}

			// Create dummy source event
			let date = cloneDate(colDate);

			if (!allDay) {
				addDuration(date, $slotDuration, offsetY + _slotTimeLimits.min.seconds / $slotDuration.seconds);
			}

			event = {
				allDay,
				start: date,
				end: allDay
				? addDay(cloneDate(date))
				: addDuration(cloneDate(date), $slotDuration),
				resourceIds: _viewResources ? [$_viewResources[resourceCol].id] : []
			};

			move(jsEvent);
		}
	}

	function selectDayGrid(dayDate, dayEl, jsEvent) {
		if (!action && jsEvent.isPrimary) {
			$$invalidate(1, action = ACTION_SELECT);
			view = VIEW_DAY_GRID;
			iClass = 'selecting';
			[colEl, bodyEl, col, row, rowEls] = traverseDayGrid(dayEl);
			common(jsEvent);
			offsetX = floor((jsEvent.clientX - colRect.left) / colRect.width) - col;

			// Create dummy source event
			let date = cloneDate(dayDate);

			event = {
				allDay: false,
				start: date,
				end: addDay(cloneDate(date)),
				resourceIds: []
			};

			move(jsEvent);
		}
	}

	function common(jsEvent) {
		window.getSelection().removeAllRanges();
		colRect = rect(colEl);
		bodyRect = rect(bodyEl);
		fromX = toX = jsEvent.clientX;
		fromY = toY = jsEvent.clientY;

		if (jsEvent.pointerType !== 'mouse') {
			// For touch devices init long press delay
			$$invalidate(3, timer = setTimeout(
				() => {
					if (action) {
						interacting = true;
						move(jsEvent);
					}
				},
				(selecting()
				? $selectLongPressDelay
				: $eventLongPressDelay) ?? $longPressDelay
			));
		}
	}

	function move(jsEvent) {
		let rx = toX - colRect.left;
		let ry = toY - colRect.top;

		if (interacting || jsEvent && jsEvent.pointerType === 'mouse' && distance() >= (selecting() ? $selectMinDistance : $eventDragMinDistance)) {
			interacting = true;
			unselect(jsEvent);
			set_store_value(_iClass, $_iClass = iClass, $_iClass);
			set_store_value(_ignoreClick, $_ignoreClick = true, $_ignoreClick);
			let newCol = floor(rx / colRect.width);

			if (view === VIEW_TIME_GRID) {
				// timeGrid
				if (_viewResources) {
					if (dragging()) {
						if ($datesAboveResources) {
							let dayCol = limit(floor(newCol / $_viewResources.length), $_viewDates.length - 1);
							newResourceCol = limit(newCol - dayCol * $_viewResources.length, $_viewResources.length - 1);
							newCol = dayCol;
						} else {
							newResourceCol = limit(floor(newCol / $_viewDates.length), $_viewResources.length - 1);
							newCol -= newResourceCol * $_viewDates.length;
						}
					} else {
						if ($datesAboveResources) {
							newCol = floor(newCol / $_viewResources.length);
						} else {
							newCol -= resourceCol * $_viewDates.length;
						}
					}
				}

				newCol = limit(newCol, $_viewDates.length - 1);

				delta = createDuration({
					days: ($_viewDates[newCol] - $_viewDates[col]) / 1000 / 60 / 60 / 24 - offsetX,
					seconds: isAllDay
					? 0
					: (floor(ry / $slotHeight) - offsetY) * $slotDuration.seconds
				});
			} else {
				// dayGrid
				let cols = 7 - $hiddenDays.length;

				newCol = limit(newCol, cols - 1);
				let newRow = -1;

				do {
					++newRow;
					ry -= rowEls[newRow].offsetHeight;
				} while (ry > 0 && newRow < rowEls.length - 1);

				delta = createDuration({
					days: ($_viewDates[newRow * cols + newCol] - $_viewDates[row * cols + col]) / 1000 / 60 / 60 / 24 - offsetX
				});
			}

			if (!$_iEvents[0]) {
				if (selecting()) {
					createIEventSelect();
				} else {
					createIEvent(jsEvent, resizing() ? $eventResizeStart : $eventDragStart);
				}
			}

			set_store_value(_iEvents, $_iEvents[0].end = addDuration(cloneDate(event.end), delta), $_iEvents);

			if (resizing()) {
				if ($_iEvents[0].end < minEnd) {
					set_store_value(_iEvents, $_iEvents[0].end = minEnd, $_iEvents);
					delta = createDuration(($_iEvents[0].end - event.end) / 1000);
				}
			} else if (selecting()) {
				if ($_iEvents[0].end < event.end) {
					set_store_value(_iEvents, $_iEvents[0].end = event.end, $_iEvents);
					set_store_value(_iEvents, $_iEvents[0].start = addDuration(cloneDate(event.start), delta), $_iEvents);
				} else {
					set_store_value(_iEvents, $_iEvents[0].start = event.start, $_iEvents);
				}
			} else {
				set_store_value(_iEvents, $_iEvents[0].start = addDuration(cloneDate(event.start), delta), $_iEvents);

				if (_viewResources) {
					set_store_value(_iEvents, $_iEvents[0].resourceIds = event.resourceIds.filter(id => id !== $_viewResources[resourceCol].id), $_iEvents);
					$_iEvents[0].resourceIds.push($_viewResources[newResourceCol].id);
				}
			}
		}

		if ($dragScroll) {
			animate(() => {
				if (toY < 0) {
					window.scrollBy(0, Math.max(-10, toY / 3));
				}

				if (toY < bodyRect.top) {
					bodyEl.scrollTop += Math.max(-10, (toY - bodyRect.top) / 3);
				}

				if (toY > window.innerHeight) {
					window.scrollBy(0, Math.min(10, (toY - window.innerHeight) / 3));
				}

				if (toY > bodyRect.bottom) {
					bodyEl.scrollTop += Math.min(10, (toY - bodyRect.bottom) / 3);
				}
			});
		}
	}

	function handleScroll() {
		if (action) {
			colRect = rect(colEl);
			bodyRect = rect(bodyEl);
			move();
		}
	}

	function handlePointerMove(jsEvent) {
		if (action && jsEvent.isPrimary) {
			toX = jsEvent.clientX;
			toY = jsEvent.clientY;
			move(jsEvent);
		}
	}

	function handlePointerUp(jsEvent) {
		if (selected && $unselectAuto && !($unselectCancel && jsEvent.target.closest($unselectCancel))) {
			unselect(jsEvent);
		}

		if (action && jsEvent.isPrimary) {
			if (interacting) {
				if (selecting()) {
					selected = true;

					if (is_function($select)) {
						let { start, end } = toEventWithLocalDates($_iEvents[0]);

						$select({
							start,
							end,
							startStr: toISOString($_iEvents[0].start),
							endStr: toISOString($_iEvents[0].end),
							allDay: isAllDay,
							jsEvent,
							view: toViewWithLocalDates($_view),
							resource: resourceCol !== undefined
							? $_viewResources[resourceCol]
							: undefined
						});
					}
				} else {
					event.display = 'auto';
					let callback = resizing() ? $eventResizeStop : $eventDragStop;

					if (is_function(callback)) {
						callback({
							event: toEventWithLocalDates(event),
							jsEvent,
							view: toViewWithLocalDates($_view)
						});
					}

					let oldEvent = cloneEvent(event);
					updateEvent(event, $_iEvents[0]);
					destroyIEvent();
					callback = resizing() ? $eventResize : $eventDrop;

					if (is_function(callback)) {
						let eventRef = event;

						let info = resizing()
						? { endDelta: delta }
						: {
								delta,
								oldResource: resourceCol !== newResourceCol
								? $_viewResources[resourceCol]
								: undefined,
								newResource: resourceCol !== newResourceCol
								? $_viewResources[newResourceCol]
								: undefined
							};

						callback(assign(info, {
							event: toEventWithLocalDates(event),
							oldEvent: toEventWithLocalDates(oldEvent),
							jsEvent,
							view: toViewWithLocalDates($_view),
							revert() {
								updateEvent(eventRef, oldEvent);
							}
						}));
					}
				}
			}

			colEl = rowEls = bodyEl = null;
			resourceCol = newResourceCol = undefined;
			$$invalidate(1, action = view = interacting = false);
			isAllDay = false;
			set_store_value(_iClass, $_iClass = undefined, $_iClass);
			$$subscribe__viewResources($$invalidate(2, _viewResources = undefined));

			if (timer) {
				clearTimeout(timer);
				$$invalidate(3, timer = undefined);
			}
		}
	}

	function createIEvent(jsEvent, callback) {
		if (is_function(callback)) {
			callback({
				event: toEventWithLocalDates(event),
				jsEvent,
				view: toViewWithLocalDates($_view)
			});
		}

		event.display = 'preview';
		set_store_value(_iEvents, $_iEvents[0] = cloneEvent(event), $_iEvents);
		event.display = 'ghost';
		_events.set($_events);
	}

	function createIEventSelect() {
		set_store_value(
			_iEvents,
			$_iEvents[0] = {
				id: '{select}',
				allDay: event.allDay,
				start: event.start,
				title: '',
				display: 'preview',
				extendedProps: {},
				backgroundColor: $selectBackgroundColor,
				resourceIds: event.resourceIds
			},
			$_iEvents
		);
	}

	function destroyIEvent() {
		set_store_value(_iEvents, $_iEvents[0] = null, $_iEvents);
	}

	function updateEvent(target, source) {
		target.start = source.start;
		target.end = source.end;
		target.resourceIds = source.resourceIds;
		_events.set($_events);
	}

	function distance() {
		return Math.sqrt(Math.pow(toX - fromX, 2) + Math.pow(toY - fromY, 2));
	}

	function dragging() {
		return action === ACTION_DRAG;
	}

	function resizing() {
		return action === ACTION_RESIZE;
	}

	function selecting() {
		return action === ACTION_SELECT;
	}

	function unselect(jsEvent) {
		if (selected) {
			selected = false;
			destroyIEvent();

			if (is_function($unselectFn)) {
				$unselectFn({
					jsEvent,
					view: toViewWithLocalDates($_view)
				});
			}
		}
	}

	// Clear selection on view params change
	_view.subscribe(unselect);

	function handleTouchStart(jsEvent) {
		if (action) {
			let target = jsEvent.target;
			let stops = [];
			let stop = () => run_all(stops);
			stops.push(listen(target, 'touchmove', createPreventDefaultHandler(() => interacting)));
			stops.push(listen(target, 'touchend', stop));
			stops.push(listen(target, 'touchcancel', stop));
		}
	}

	function touchmove_handler(event) {
		bubble.call(this, $$self, event);
	}

	const selectstart_handler = () => action;
	const contextmenu_handler = () => timer;

	return [
		handleScroll,
		action,
		_viewResources,
		timer,
		_iEvents,
		_iClass,
		_ignoreClick,
		_events,
		_viewDates,
		_view,
		datesAboveResources,
		dragScroll,
		eventDragMinDistance,
		eventDragStart,
		eventDragStop,
		eventDrop,
		eventLongPressDelay,
		eventResizeStart,
		eventResizeStop,
		eventResize,
		longPressDelay,
		select,
		selectBackgroundColor,
		selectLongPressDelay,
		selectMinDistance,
		slotDuration,
		slotHeight,
		hiddenDays,
		unselectFn,
		unselectAuto,
		unselectCancel,
		handlePointerMove,
		handlePointerUp,
		handleTouchStart,
		dragTimeGrid,
		dragDayGrid,
		selectTimeGrid,
		selectDayGrid,
		unselect,
		touchmove_handler,
		selectstart_handler,
		contextmenu_handler
	];
}

class Action extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$3$2,
			create_fragment$3$2,
			safe_not_equal,
			{
				dragTimeGrid: 34,
				dragDayGrid: 35,
				selectTimeGrid: 36,
				selectDayGrid: 37,
				handleScroll: 0,
				unselect: 38
			},
			null,
			[-1, -1, -1, -1]
		);
	}

	get dragTimeGrid() {
		return this.$$.ctx[34];
	}

	get dragDayGrid() {
		return this.$$.ctx[35];
	}

	get selectTimeGrid() {
		return this.$$.ctx[36];
	}

	get selectDayGrid() {
		return this.$$.ctx[37];
	}

	get handleScroll() {
		return this.$$.ctx[0];
	}

	get unselect() {
		return this.$$.ctx[38];
	}
}

/* packages/interaction/src/Pointer.svelte generated by Svelte v3.55.1 */

function create_fragment$2$2(ctx) {
	let mounted;
	let dispose;

	return {
		c: noop,
		m(target, anchor) {
			if (!mounted) {
				dispose = [
					listen(window, "pointermove", /*handlePointerMove*/ ctx[5]),
					listen(window, "scroll", /*handleScroll*/ ctx[0])
				];

				mounted = true;
			}
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			mounted = false;
			run_all(dispose);
		}
	};
}

function validEvent(jsEvent) {
	return jsEvent.isPrimary && jsEvent.pointerType === 'mouse';
}

function instance$2$3($$self, $$props, $$invalidate) {
	let $_iEvents;
	let $slotDuration;

	let $_slotTimeLimits,
		$$unsubscribe__slotTimeLimits = noop,
		$$subscribe__slotTimeLimits = () => ($$unsubscribe__slotTimeLimits(), $$unsubscribe__slotTimeLimits = subscribe(_slotTimeLimits, $$value => $$invalidate(17, $_slotTimeLimits = $$value)), _slotTimeLimits);

	let $slotHeight;
	$$self.$$.on_destroy.push(() => $$unsubscribe__slotTimeLimits());
	let { _iEvents, _events, _viewDates, slotDuration, slotHeight, hiddenDays, _view, datesAboveResources, theme } = getContext('state');
	component_subscribe($$self, _iEvents, value => $$invalidate(9, $_iEvents = value));
	component_subscribe($$self, slotDuration, value => $$invalidate(16, $slotDuration = value));
	component_subscribe($$self, slotHeight, value => $$invalidate(18, $slotHeight = value));
	let y;
	let colDate;
	let colEl;
	let colRect;
	let resource;
	let _slotTimeLimits;
	let date;

	function enterTimeGrid(date, el, jsEvent, slotTimeLimitsStore, resourceObj) {
		if (validEvent(jsEvent)) {
			colDate = date;
			colEl = el;
			colRect = rect(colEl);
			y = jsEvent.clientY;
			$$subscribe__slotTimeLimits($$invalidate(1, _slotTimeLimits = slotTimeLimitsStore));
			resource = resourceObj;
		}
	}

	function enterDayGrid(date, jsEvent) {
		if (validEvent(jsEvent)) {
			colDate = date;
			colEl = null;
			y = $$subscribe__slotTimeLimits($$invalidate(1, _slotTimeLimits = resource = undefined));
		}
	}

	function leave(jsEvent) {
		if (validEvent(jsEvent)) {
			removePointerEvent();
		}
	}

	function move() {
		if (!colDate) {
			return;
		}

		if (colEl) {
			// timeGrid
			let ry = y - colRect.top;

			date = addDuration(cloneDate(colDate), $slotDuration, floor(ry / $slotHeight + $_slotTimeLimits.min.seconds / $slotDuration.seconds));
		} else {
			// dayGrid
			date = colDate;
		}

		if (!$_iEvents[1]) {
			createPointerEvent();
		}

		set_store_value(_iEvents, $_iEvents[1].start = date, $_iEvents);
		set_store_value(_iEvents, $_iEvents[1].end = addDuration(cloneDate(date), $slotDuration), $_iEvents);
		set_store_value(_iEvents, $_iEvents[1].resourceIds = resource ? [resource.id] : [], $_iEvents);
	}

	function handleScroll() {
		if (colEl) {
			colRect = rect(colEl);
			move();
		}
	}

	function handlePointerMove(jsEvent) {
		if (validEvent(jsEvent)) {
			y = jsEvent.clientY;
			move();
		}
	}

	function createPointerEvent() {
		set_store_value(
			_iEvents,
			$_iEvents[1] = {
				id: '{pointer}',
				title: '',
				display: 'pointer',
				extendedProps: {},
				backgroundColor: 'transparent'
			},
			$_iEvents
		);
	}

	function removePointerEvent() {
		colDate = colEl = set_store_value(_iEvents, $_iEvents[1] = null, $_iEvents);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$_iEvents*/ 512) {
			if ($_iEvents[0]) {
				removePointerEvent();
			}
		}
	};

	return [
		handleScroll,
		_slotTimeLimits,
		_iEvents,
		slotDuration,
		slotHeight,
		handlePointerMove,
		enterTimeGrid,
		enterDayGrid,
		leave,
		$_iEvents
	];
}

class Pointer extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$2$3, create_fragment$2$2, safe_not_equal, {
			enterTimeGrid: 6,
			enterDayGrid: 7,
			leave: 8,
			handleScroll: 0
		});
	}

	get enterTimeGrid() {
		return this.$$.ctx[6];
	}

	get enterDayGrid() {
		return this.$$.ctx[7];
	}

	get leave() {
		return this.$$.ctx[8];
	}

	get handleScroll() {
		return this.$$.ctx[0];
	}
}

/* packages/interaction/src/Resizer.svelte generated by Svelte v3.55.1 */

function create_if_block$1$1(ctx) {
	let div;
	let div_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			attr(div, "class", div_class_value = /*$theme*/ ctx[2].resizer);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (!mounted) {
				dispose = listen(div, "pointerdown", /*pointerdown_handler*/ ctx[5]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*$theme*/ 4 && div_class_value !== (div_class_value = /*$theme*/ ctx[2].resizer)) {
				attr(div, "class", div_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$1$3(ctx) {
	let show_if = /*event*/ ctx[0].display === 'auto' && /*$_resizable*/ ctx[1](/*event*/ ctx[0]);
	let if_block_anchor;
	let if_block = show_if && create_if_block$1$1(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (dirty & /*event, $_resizable*/ 3) show_if = /*event*/ ctx[0].display === 'auto' && /*$_resizable*/ ctx[1](/*event*/ ctx[0]);

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$1$1(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$1$3($$self, $$props, $$invalidate) {
	let $_resizable;
	let $theme;
	let { event } = $$props;
	let { theme, _resizable } = getContext('state');
	component_subscribe($$self, theme, value => $$invalidate(2, $theme = value));
	component_subscribe($$self, _resizable, value => $$invalidate(1, $_resizable = value));

	function pointerdown_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('event' in $$props) $$invalidate(0, event = $$props.event);
	};

	return [event, $_resizable, $theme, theme, _resizable, pointerdown_handler];
}

class Resizer extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1$3, create_fragment$1$3, safe_not_equal, { event: 0 });
	}
}

/* packages/interaction/src/Auxiliary.svelte generated by Svelte v3.55.1 */

function create_if_block$4(ctx) {
	let pointer_1;
	let current;
	let pointer_1_props = {};
	pointer_1 = new Pointer({ props: pointer_1_props });
	/*pointer_1_binding*/ ctx[18](pointer_1);

	return {
		c() {
			create_component(pointer_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component(pointer_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const pointer_1_changes = {};
			pointer_1.$set(pointer_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(pointer_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(pointer_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			/*pointer_1_binding*/ ctx[18](null);
			destroy_component(pointer_1, detaching);
		}
	};
}

function create_fragment$9(ctx) {
	let action;
	let t;
	let if_block_anchor;
	let current;
	let action_props = {};
	action = new Action({ props: action_props });
	/*action_binding*/ ctx[17](action);
	let if_block = /*$pointer*/ ctx[1] && create_if_block$4(ctx);

	return {
		c() {
			create_component(action.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			mount_component(action, target, anchor);
			insert(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const action_changes = {};
			action.$set(action_changes);

			if (/*$pointer*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*$pointer*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$4(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(action.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(action.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			/*action_binding*/ ctx[17](null);
			destroy_component(action, detaching);
			if (detaching) detach(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$9($$self, $$props, $$invalidate) {
	let $_interaction;
	let $_scroll;
	let $editable;
	let $eventDurationEditable;
	let $_resizable;
	let $eventStartEditable;
	let $_draggable;
	let $theme;
	let $_classes;
	let $pointer;
	let { theme, editable, eventStartEditable, eventDurationEditable, pointer, _interaction, _classes, _draggable, _resizable, _scroll } = getContext('state');
	component_subscribe($$self, theme, value => $$invalidate(16, $theme = value));
	component_subscribe($$self, editable, value => $$invalidate(12, $editable = value));
	component_subscribe($$self, eventStartEditable, value => $$invalidate(14, $eventStartEditable = value));
	component_subscribe($$self, eventDurationEditable, value => $$invalidate(13, $eventDurationEditable = value));
	component_subscribe($$self, pointer, value => $$invalidate(1, $pointer = value));
	component_subscribe($$self, _interaction, value => $$invalidate(0, $_interaction = value));
	component_subscribe($$self, _classes, value => $$invalidate(21, $_classes = value));
	component_subscribe($$self, _draggable, value => $$invalidate(15, $_draggable = value));
	component_subscribe($$self, _resizable, value => $$invalidate(20, $_resizable = value));
	component_subscribe($$self, _scroll, value => $$invalidate(19, $_scroll = value));
	set_store_value(_interaction, $_interaction.resizer = Resizer, $_interaction);

	set_store_value(
		_scroll,
		$_scroll = () => {
			for (let component of Object.values($_interaction)) {
				component?.handleScroll?.();
			}
		},
		$_scroll
	);

	function action_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$_interaction.action = $$value;
			_interaction.set($_interaction);
		});
	}

	function pointer_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$_interaction.pointer = $$value;
			_interaction.set($_interaction);
		});
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$eventStartEditable, $editable*/ 20480) {
			set_store_value(_draggable, $_draggable = event => (event.startEditable ?? $eventStartEditable) || (event.editable ?? $editable), $_draggable);
		}

		if ($$self.$$.dirty & /*$_draggable, $theme*/ 98304) {
			set_store_value(
				_classes,
				$_classes = (className, event) => {
					switch (event.display) {
						case 'auto':
							return className + ($_draggable(event) ? ' ' + $theme.draggable : '');
						case 'ghost':
							return `${$theme.event} ${$theme.ghost}`;
						case 'preview':
							return `${$theme.event} ${$theme.preview}`;
						case 'pointer':
							return `${$theme.event} ${$theme.pointer}`;
						default:
							return className;
					}
				},
				$_classes
			);
		}

		if ($$self.$$.dirty & /*$eventDurationEditable, $editable*/ 12288) {
			set_store_value(_resizable, $_resizable = event => (event.durationEditable ?? $eventDurationEditable) || (event.editable ?? $editable), $_resizable);
		}
	};

	return [
		$_interaction,
		$pointer,
		theme,
		editable,
		eventStartEditable,
		eventDurationEditable,
		pointer,
		_interaction,
		_classes,
		_draggable,
		_resizable,
		_scroll,
		$editable,
		$eventDurationEditable,
		$eventStartEditable,
		$_draggable,
		$theme,
		action_binding,
		pointer_1_binding
	];
}

class Auxiliary$1 extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});
	}
}

var index$3 = {
	createOptions(options) {
		options.dragScroll = true;
		options.editable = false;
		options.eventDragMinDistance = 5;
		options.eventDragStart = undefined;
		options.eventDragStop = undefined;
		options.eventDrop = undefined;
		options.eventDurationEditable = true;
		options.eventLongPressDelay = undefined;
		options.eventResizeStart = undefined;
		options.eventResizeStop = undefined;
		options.eventResize = undefined;
		options.eventStartEditable = true;
		options.longPressDelay = 1000;
		options.pointer = false;
		options.select = undefined;
		options.selectBackgroundColor = undefined;  // ec option
		options.selectLongPressDelay = undefined;
		options.selectMinDistance = 5;
		options.unselect = undefined;
		options.unselectAuto = true;
		options.unselectCancel = '';
		options.theme.draggable = 'ec-draggable';
		options.theme.ghost = 'ec-ghost';
		options.theme.preview = 'ec-preview';
		options.theme.pointer = 'ec-pointer';
		options.theme.resizer = 'ec-resizer';
		options.theme.dragging = 'ec-dragging';
		options.theme.resizingY = 'ec-resizing-y';
		options.theme.resizingX = 'ec-resizing-x';
		options.theme.selecting = 'ec-selecting';
	},

	createStores(state) {
		state._auxiliary.update($_auxiliary => [...$_auxiliary, Auxiliary$1]);
	}
};

function viewResources(state) {
    return derived(
        [state.resources, state.filterResourcesWithEvents, state._events, state._activeRange],
        ([$resources, $filterResourcesWithEvents, $_events, $_activeRange]) => {
            let result = $resources;

            if ($filterResourcesWithEvents) {
                result = $resources.filter(resource => {
                    for (let event of $_events) {
                        if (
                            event.display !== 'background' &&
                            event.resourceIds.includes(resource.id) &&
                            event.start < $_activeRange.end &&
                            event.end > $_activeRange.start
                        ) {
                            return true;
                        }
                    }
                    return false;
                });
            }

            if (!result.length) {
                result = state.resources.parse([{}]);
            }

            return result;
        }
    );
}

class State$2 extends State$3 {
    constructor(state) {
        super(state);

        this._viewResources = viewResources(state);
    }
}

function isObject(test) {
    return typeof test === 'object' && test !== null;
}

function setContent(node, content) {
    let actions = {
        update(content) {
            while (node.firstChild) {
                node.removeChild(node.lastChild);
            }
            if (!isObject(content)) {
                node.innerText = content;
            } else if (content.domNodes) {
                for (let child of content.domNodes) {
                    node.appendChild(child);
                }
            } else if (content.html) {
                node.innerHTML = content.html;
            }
        }
    };
    actions.update(content);

    return actions;
}

function toLocalDate(date) {
    return new Date(
        date.getUTCFullYear(),
        date.getUTCMonth(),
        date.getUTCDate(),
        date.getUTCHours(),
        date.getUTCMinutes(),
        date.getUTCSeconds()
    );
}

/* packages/resource-time-grid/src/Label.svelte generated by Svelte v3.55.1 */

function create_fragment$1$2(ctx) {
	let div;
	let div_class_value;
	let setContent_action;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			attr(div, "class", div_class_value = /*$theme*/ ctx[2].day);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			/*div_binding*/ ctx[9](div);

			if (!mounted) {
				dispose = action_destroyer(setContent_action = setContent.call(null, div, /*content*/ ctx[1]));
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*$theme*/ 4 && div_class_value !== (div_class_value = /*$theme*/ ctx[2].day)) {
				attr(div, "class", div_class_value);
			}

			if (setContent_action && is_function(setContent_action.update) && dirty & /*content*/ 2) setContent_action.update.call(null, /*content*/ ctx[1]);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			/*div_binding*/ ctx[9](null);
			mounted = false;
			dispose();
		}
	};
}

function instance$2$2($$self, $$props, $$invalidate) {
	let $resourceLabelDidMount;
	let $resourceLabelContent;
	let $theme;
	let { resource } = $$props;
	let { date = undefined } = $$props;
	let { resourceLabelContent, resourceLabelDidMount, theme } = getContext('state');
	component_subscribe($$self, resourceLabelContent, value => $$invalidate(8, $resourceLabelContent = value));
	component_subscribe($$self, resourceLabelDidMount, value => $$invalidate(10, $resourceLabelDidMount = value));
	component_subscribe($$self, theme, value => $$invalidate(2, $theme = value));
	let el;
	let content;

	onMount(() => {
		if (is_function($resourceLabelDidMount)) {
			$resourceLabelDidMount({
				resource,
				date: date ? toLocalDate(date) : undefined,
				el
			});
		}
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$props => {
		if ('resource' in $$props) $$invalidate(6, resource = $$props.resource);
		if ('date' in $$props) $$invalidate(7, date = $$props.date);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$resourceLabelContent, resource, date*/ 448) {
			// Content
			if ($resourceLabelContent) {
				$$invalidate(1, content = is_function($resourceLabelContent)
				? $resourceLabelContent({
						resource,
						date: date ? toLocalDate(date) : undefined
					})
				: $resourceLabelContent);
			} else {
				$$invalidate(1, content = resource.titleHTML
				? { html: resource.titleHTML }
				: resource.title);
			}
		}
	};

	return [
		el,
		content,
		$theme,
		resourceLabelContent,
		resourceLabelDidMount,
		theme,
		resource,
		date,
		$resourceLabelContent,
		div_binding
	];
}

class Label extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2$2, create_fragment$1$2, safe_not_equal, { resource: 6, date: 7 });
	}
}

/* packages/resource-time-grid/src/View.svelte generated by Svelte v3.55.1 */

function get_each_context$6(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[17] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[20] = list[i];
	return child_ctx;
}

function get_each_context_4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[26] = list[i];
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[23] = list[i];
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[26] = list[i];
	return child_ctx;
}

function get_each_context_5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[17] = list[i];
	return child_ctx;
}

function get_each_context_6(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[20] = list[i];
	return child_ctx;
}

// (26:12) {:else}
function create_else_block_2(ctx) {
	let label;
	let current;
	label = new Label({ props: { resource: /*item0*/ ctx[17] } });

	return {
		c() {
			create_component(label.$$.fragment);
		},
		m(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const label_changes = {};
			if (dirty[0] & /*loops*/ 8) label_changes.resource = /*item0*/ ctx[17];
			label.$set(label_changes);
		},
		i(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(label, detaching);
		}
	};
}

// (24:12) {#if $datesAboveResources}
function create_if_block_4(ctx) {
	let div;
	let t_value = /*$_intlDayHeader*/ ctx[5].format(/*item0*/ ctx[17]) + "";
	let t;
	let div_class_value;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			attr(div, "class", div_class_value = /*$theme*/ ctx[4].day);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$_intlDayHeader, loops*/ 40 && t_value !== (t_value = /*$_intlDayHeader*/ ctx[5].format(/*item0*/ ctx[17]) + "")) set_data(t, t_value);

			if (dirty[0] & /*$theme*/ 16 && div_class_value !== (div_class_value = /*$theme*/ ctx[4].day)) {
				attr(div, "class", div_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (29:12) {#if loops[1].length > 1}
function create_if_block_2$1(ctx) {
	let div;
	let div_class_value;
	let current;
	let each_value_6 = /*loops*/ ctx[3][1];
	let each_blocks = [];

	for (let i = 0; i < each_value_6.length; i += 1) {
		each_blocks[i] = create_each_block_6(get_each_context_6(ctx, each_value_6, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", div_class_value = /*$theme*/ ctx[4].days);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*loops, $datesAboveResources, $theme, $_intlDayHeader*/ 60) {
				each_value_6 = /*loops*/ ctx[3][1];
				let i;

				for (i = 0; i < each_value_6.length; i += 1) {
					const child_ctx = get_each_context_6(ctx, each_value_6, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_6(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, null);
					}
				}

				group_outros();

				for (i = each_value_6.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (!current || dirty[0] & /*$theme*/ 16 && div_class_value !== (div_class_value = /*$theme*/ ctx[4].days)) {
				attr(div, "class", div_class_value);
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_6.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (34:24) {:else}
function create_else_block_1(ctx) {
	let div;
	let t_value = /*$_intlDayHeader*/ ctx[5].format(/*item1*/ ctx[20]) + "";
	let t;
	let div_class_value;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			attr(div, "class", div_class_value = /*$theme*/ ctx[4].day);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$_intlDayHeader, loops*/ 40 && t_value !== (t_value = /*$_intlDayHeader*/ ctx[5].format(/*item1*/ ctx[20]) + "")) set_data(t, t_value);

			if (dirty[0] & /*$theme*/ 16 && div_class_value !== (div_class_value = /*$theme*/ ctx[4].day)) {
				attr(div, "class", div_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (32:24) {#if $datesAboveResources}
function create_if_block_3$1(ctx) {
	let label;
	let current;

	label = new Label({
			props: {
				resource: /*item1*/ ctx[20],
				date: /*item0*/ ctx[17]
			}
		});

	return {
		c() {
			create_component(label.$$.fragment);
		},
		m(target, anchor) {
			mount_component(label, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const label_changes = {};
			if (dirty[0] & /*loops*/ 8) label_changes.resource = /*item1*/ ctx[20];
			if (dirty[0] & /*loops*/ 8) label_changes.date = /*item0*/ ctx[17];
			label.$set(label_changes);
		},
		i(local) {
			if (current) return;
			transition_in(label.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(label.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(label, detaching);
		}
	};
}

// (31:20) {#each loops[1] as item1}
function create_each_block_6(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_3$1, create_else_block_1];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*$datesAboveResources*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (22:4) {#each loops[0] as item0}
function create_each_block_5(ctx) {
	let div;
	let current_block_type_index;
	let if_block0;
	let t0;
	let t1;
	let div_class_value;
	let current;
	const if_block_creators = [create_if_block_4, create_else_block_2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*$datesAboveResources*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = /*loops*/ ctx[3][1].length > 1 && create_if_block_2$1(ctx);

	return {
		c() {
			div = element("div");
			if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			attr(div, "class", div_class_value = /*$theme*/ ctx[4].resource);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			append(div, t0);
			if (if_block1) if_block1.m(div, null);
			append(div, t1);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				transition_in(if_block0, 1);
				if_block0.m(div, t0);
			}

			if (/*loops*/ ctx[3][1].length > 1) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*loops*/ 8) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*$theme*/ 16 && div_class_value !== (div_class_value = /*$theme*/ ctx[4].resource)) {
				attr(div, "class", div_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
		}
	};
}

// (21:0) <Header>
function create_default_slot_2(ctx) {
	let each_1_anchor;
	let current;
	let each_value_5 = /*loops*/ ctx[3][0];
	let each_blocks = [];

	for (let i = 0; i < each_value_5.length; i += 1) {
		each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$theme, loops, $datesAboveResources, $_intlDayHeader*/ 60) {
				each_value_5 = /*loops*/ ctx[3][0];
				let i;

				for (i = 0; i < each_value_5.length; i += 1) {
					const child_ctx = get_each_context_5(ctx, each_value_5, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_5(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value_5.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_5.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (43:0) {#if $allDaySlot}
function create_if_block$3(ctx) {
	let header;
	let current;

	header = new Header$1({
			props: {
				allDay: true,
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(header.$$.fragment);
		},
		m(target, anchor) {
			mount_component(header, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const header_changes = {};

			if (dirty[0] & /*$_viewDates, $theme, $_viewResources, $datesAboveResources*/ 23 | dirty[1] & /*$$scope*/ 16) {
				header_changes.$$scope = { dirty, ctx };
			}

			header.$set(header_changes);
		},
		i(local) {
			if (current) return;
			transition_in(header.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(header.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(header, detaching);
		}
	};
}

// (53:8) {:else}
function create_else_block$1(ctx) {
	let each_1_anchor;
	let current;
	let each_value_4 = /*$_viewResources*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value_4.length; i += 1) {
		each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$theme, $_viewDates, $_viewResources*/ 19) {
				each_value_4 = /*$_viewResources*/ ctx[1];
				let i;

				for (i = 0; i < each_value_4.length; i += 1) {
					const child_ctx = get_each_context_4(ctx, each_value_4, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_4(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value_4.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_4.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (45:8) {#if $datesAboveResources}
function create_if_block_1$1(ctx) {
	let each_1_anchor;
	let current;
	let each_value_2 = /*$_viewDates*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$theme, $_viewResources, $_viewDates*/ 19) {
				each_value_2 = /*$_viewDates*/ ctx[0];
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_2.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (54:12) {#each $_viewResources as resource}
function create_each_block_4(ctx) {
	let div;
	let week;
	let t;
	let div_class_value;
	let current;

	week = new Week$1({
			props: {
				dates: /*$_viewDates*/ ctx[0],
				resource: /*resource*/ ctx[26]
			}
		});

	return {
		c() {
			div = element("div");
			create_component(week.$$.fragment);
			t = space();
			attr(div, "class", div_class_value = /*$theme*/ ctx[4].resource);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(week, div, null);
			append(div, t);
			current = true;
		},
		p(ctx, dirty) {
			const week_changes = {};
			if (dirty[0] & /*$_viewDates*/ 1) week_changes.dates = /*$_viewDates*/ ctx[0];
			if (dirty[0] & /*$_viewResources*/ 2) week_changes.resource = /*resource*/ ctx[26];
			week.$set(week_changes);

			if (!current || dirty[0] & /*$theme*/ 16 && div_class_value !== (div_class_value = /*$theme*/ ctx[4].resource)) {
				attr(div, "class", div_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(week.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(week.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(week);
		}
	};
}

// (48:20) {#each $_viewResources as resource}
function create_each_block_3(ctx) {
	let week;
	let current;

	week = new Week$1({
			props: {
				dates: [/*date*/ ctx[23]],
				resource: /*resource*/ ctx[26]
			}
		});

	return {
		c() {
			create_component(week.$$.fragment);
		},
		m(target, anchor) {
			mount_component(week, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const week_changes = {};
			if (dirty[0] & /*$_viewDates*/ 1) week_changes.dates = [/*date*/ ctx[23]];
			if (dirty[0] & /*$_viewResources*/ 2) week_changes.resource = /*resource*/ ctx[26];
			week.$set(week_changes);
		},
		i(local) {
			if (current) return;
			transition_in(week.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(week.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(week, detaching);
		}
	};
}

// (46:12) {#each $_viewDates as date}
function create_each_block_2(ctx) {
	let div;
	let t;
	let div_class_value;
	let current;
	let each_value_3 = /*$_viewResources*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			attr(div, "class", div_class_value = /*$theme*/ ctx[4].resource);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append(div, t);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$_viewDates, $_viewResources*/ 3) {
				each_value_3 = /*$_viewResources*/ ctx[1];
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3(ctx, each_value_3, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_3(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, t);
					}
				}

				group_outros();

				for (i = each_value_3.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (!current || dirty[0] & /*$theme*/ 16 && div_class_value !== (div_class_value = /*$theme*/ ctx[4].resource)) {
				attr(div, "class", div_class_value);
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_3.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (44:4) <Header allDay>
function create_default_slot_1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1$1, create_else_block$1];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*$datesAboveResources*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (65:8) {#each loops[1] as item1}
function create_each_block_1(ctx) {
	let day;
	let current;

	day = new Day$1$1({
			props: {
				date: /*$datesAboveResources*/ ctx[2]
				? /*item0*/ ctx[17]
				: /*item1*/ ctx[20],
				resource: /*$datesAboveResources*/ ctx[2]
				? /*item1*/ ctx[20]
				: /*item0*/ ctx[17]
			}
		});

	return {
		c() {
			create_component(day.$$.fragment);
		},
		m(target, anchor) {
			mount_component(day, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const day_changes = {};

			if (dirty[0] & /*$datesAboveResources, loops*/ 12) day_changes.date = /*$datesAboveResources*/ ctx[2]
			? /*item0*/ ctx[17]
			: /*item1*/ ctx[20];

			if (dirty[0] & /*$datesAboveResources, loops*/ 12) day_changes.resource = /*$datesAboveResources*/ ctx[2]
			? /*item1*/ ctx[20]
			: /*item0*/ ctx[17];

			day.$set(day_changes);
		},
		i(local) {
			if (current) return;
			transition_in(day.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(day.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(day, detaching);
		}
	};
}

// (63:0) {#each loops[0] as item0}
function create_each_block$6(ctx) {
	let div;
	let t;
	let div_class_value;
	let current;
	let each_value_1 = /*loops*/ ctx[3][1];
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			attr(div, "class", div_class_value = /*$theme*/ ctx[4].resource);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append(div, t);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$datesAboveResources, loops*/ 12) {
				each_value_1 = /*loops*/ ctx[3][1];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, t);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (!current || dirty[0] & /*$theme*/ 16 && div_class_value !== (div_class_value = /*$theme*/ ctx[4].resource)) {
				attr(div, "class", div_class_value);
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

// (62:0) <Body>
function create_default_slot$2(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*loops*/ ctx[3][0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$theme, loops, $datesAboveResources*/ 28) {
				each_value = /*loops*/ ctx[3][0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$6(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$6(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

function create_fragment$8(ctx) {
	let header;
	let t0;
	let t1;
	let body;
	let current;

	header = new Header$1({
			props: {
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			}
		});

	let if_block = /*$allDaySlot*/ ctx[6] && create_if_block$3(ctx);

	body = new Body$2({
			props: {
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(header.$$.fragment);
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			create_component(body.$$.fragment);
		},
		m(target, anchor) {
			mount_component(header, target, anchor);
			insert(target, t0, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, t1, anchor);
			mount_component(body, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const header_changes = {};

			if (dirty[0] & /*loops, $theme, $datesAboveResources, $_intlDayHeader*/ 60 | dirty[1] & /*$$scope*/ 16) {
				header_changes.$$scope = { dirty, ctx };
			}

			header.$set(header_changes);

			if (/*$allDaySlot*/ ctx[6]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*$allDaySlot*/ 64) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t1.parentNode, t1);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const body_changes = {};

			if (dirty[0] & /*loops, $theme, $datesAboveResources*/ 28 | dirty[1] & /*$$scope*/ 16) {
				body_changes.$$scope = { dirty, ctx };
			}

			body.$set(body_changes);
		},
		i(local) {
			if (current) return;
			transition_in(header.$$.fragment, local);
			transition_in(if_block);
			transition_in(body.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(header.$$.fragment, local);
			transition_out(if_block);
			transition_out(body.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(header, detaching);
			if (detaching) detach(t0);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t1);
			destroy_component(body, detaching);
		}
	};
}

function instance$1$2($$self, $$props, $$invalidate) {
	let $_viewDates;
	let $_viewResources;
	let $datesAboveResources;
	let $_viewClass;
	let $theme;
	let $_intlDayHeader;
	let $allDaySlot;
	let state = getContext('state');
	let { datesAboveResources, _viewDates, _intlDayHeader, _viewClass, allDaySlot, theme } = state;
	component_subscribe($$self, datesAboveResources, value => $$invalidate(2, $datesAboveResources = value));
	component_subscribe($$self, _viewDates, value => $$invalidate(0, $_viewDates = value));
	component_subscribe($$self, _intlDayHeader, value => $$invalidate(5, $_intlDayHeader = value));
	component_subscribe($$self, _viewClass, value => $$invalidate(14, $_viewClass = value));
	component_subscribe($$self, allDaySlot, value => $$invalidate(6, $allDaySlot = value));
	component_subscribe($$self, theme, value => $$invalidate(4, $theme = value));
	let viewState = new State$2(state);
	setContext('view-state', viewState);
	let { _viewResources } = viewState;
	component_subscribe($$self, _viewResources, value => $$invalidate(1, $_viewResources = value));
	set_store_value(_viewClass, $_viewClass = 'week', $_viewClass);
	let loops;

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*$datesAboveResources, $_viewDates, $_viewResources*/ 7) {
			$$invalidate(3, loops = $datesAboveResources
			? [$_viewDates, $_viewResources]
			: [$_viewResources, $_viewDates]);
		}
	};

	return [
		$_viewDates,
		$_viewResources,
		$datesAboveResources,
		loops,
		$theme,
		$_intlDayHeader,
		$allDaySlot,
		datesAboveResources,
		_viewDates,
		_intlDayHeader,
		_viewClass,
		allDaySlot,
		theme,
		_viewResources
	];
}

class View$2 extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1$2, create_fragment$8, safe_not_equal, {}, null, [-1, -1]);
	}
}

/* packages/resource-time-grid/src/Auxiliary.svelte generated by Svelte v3.55.1 */

function instance$8($$self, $$props, $$invalidate) {
	let $resources;
	let $_resBgColor;
	let { resources, _resBgColor } = getContext('state');
	component_subscribe($$self, resources, value => $$invalidate(2, $resources = value));
	component_subscribe($$self, _resBgColor, value => $$invalidate(3, $_resBgColor = value));

	set_store_value(
		_resBgColor,
		$_resBgColor = event => {
			let resource = $resources.find(res => event.resourceIds.includes(res.id));
			return resource?.eventBackgroundColor;
		},
		$_resBgColor
	);

	return [resources, _resBgColor];
}

class Auxiliary extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$8, null, safe_not_equal, {});
	}
}

var index$2 = {
	createOptions(options) {
		options.resources = [];
		options.datesAboveResources = false;
		options.filterResourcesWithEvents = false;
		options.resourceLabelContent = undefined;
		options.resourceLabelDidMount = undefined;
		// Common options
		options.buttonText.resourceTimeGridDay = 'day';
		options.buttonText.resourceTimeGridWeek = 'week';
		options.theme.resource = 'ec-resource';
		options.theme.resourceTitle = 'ec-resource-title';
		options.view = 'resourceTimeGridWeek';
		options.views.resourceTimeGridDay = {
			component: View$2,
			duration: {days: 1}
		};
		options.views.resourceTimeGridWeek = {
			component: View$2,
			duration: {weeks: 1}
		};
	},

	createParsers(parsers, options) {
		parsers.resources = createResources;
	},

	createStores(state) {
		state._auxiliary.update($_auxiliary => [...$_auxiliary, Auxiliary]);
	}
};

function createResources(input) {
	return input.map(resource => ({
		id: String(resource.id),
		title: resource.title || '',
		titleHTML: resource.titleHTML || '',
		eventBackgroundColor: resource.eventBackgroundColor,
	}));
}

function days(state) {
    return derived([state.date, state.firstDay, state.hiddenDays], ([$date, $firstDay, $hiddenDays]) => {
        let days = [];
        let day = cloneDate($date);
        let max = 7;
        // First day of week
        while (day.getUTCDay() !== $firstDay && max) {
            subtractDay(day);
            --max;
        }
        for (let i = 0; i < 7; ++i) {
            if (!$hiddenDays.includes(day.getUTCDay())) {
                days.push(cloneDate(day));
            }
            addDay(day);
        }

        return days;
    });
}

class State$1 {
    constructor(state) {
        this._days = days(state);
        this._hiddenEvents = writable({});
        this._popupDate = writable(null);
        this._popupChunks = writable([]);
    }
}

/* packages/day-grid/src/Header.svelte generated by Svelte v3.55.1 */

function get_each_context$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[8] = list[i];
	return child_ctx;
}

// (10:8) {#each $_days as day}
function create_each_block$4(ctx) {
	let div;
	let t_value = /*$_intlDayHeader*/ ctx[3].format(/*day*/ ctx[8]) + "";
	let t;
	let div_class_value;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			attr(div, "class", div_class_value = /*$theme*/ ctx[0].day);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*$_intlDayHeader, $_days*/ 12 && t_value !== (t_value = /*$_intlDayHeader*/ ctx[3].format(/*day*/ ctx[8]) + "")) set_data(t, t_value);

			if (dirty & /*$theme*/ 1 && div_class_value !== (div_class_value = /*$theme*/ ctx[0].day)) {
				attr(div, "class", div_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment$6(ctx) {
	let div2;
	let div0;
	let div0_class_value;
	let t;
	let div1;
	let div1_class_value;
	let div2_class_value;
	let each_value = /*$_days*/ ctx[2];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	}

	return {
		c() {
			div2 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			div1 = element("div");
			attr(div0, "class", div0_class_value = /*$theme*/ ctx[0].days);
			attr(div1, "class", div1_class_value = /*$theme*/ ctx[0].hiddenScroll);

			attr(div2, "class", div2_class_value = "" + (/*$theme*/ ctx[0].header + (/*$_scrollable*/ ctx[1]
			? ' ' + /*$theme*/ ctx[0].withScroll
			: '')));
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			append(div2, t);
			append(div2, div1);
		},
		p(ctx, [dirty]) {
			if (dirty & /*$theme, $_intlDayHeader, $_days*/ 13) {
				each_value = /*$_days*/ ctx[2];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$4(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$4(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*$theme*/ 1 && div0_class_value !== (div0_class_value = /*$theme*/ ctx[0].days)) {
				attr(div0, "class", div0_class_value);
			}

			if (dirty & /*$theme*/ 1 && div1_class_value !== (div1_class_value = /*$theme*/ ctx[0].hiddenScroll)) {
				attr(div1, "class", div1_class_value);
			}

			if (dirty & /*$theme, $_scrollable*/ 3 && div2_class_value !== (div2_class_value = "" + (/*$theme*/ ctx[0].header + (/*$_scrollable*/ ctx[1]
			? ' ' + /*$theme*/ ctx[0].withScroll
			: '')))) {
				attr(div2, "class", div2_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div2);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	let $theme;
	let $_scrollable;
	let $_days;
	let $_intlDayHeader;
	let { theme, _intlDayHeader, _scrollable } = getContext('state');
	component_subscribe($$self, theme, value => $$invalidate(0, $theme = value));
	component_subscribe($$self, _intlDayHeader, value => $$invalidate(3, $_intlDayHeader = value));
	component_subscribe($$self, _scrollable, value => $$invalidate(1, $_scrollable = value));
	let { _days } = getContext('view-state');
	component_subscribe($$self, _days, value => $$invalidate(2, $_days = value));

	return [
		$theme,
		$_scrollable,
		$_days,
		$_intlDayHeader,
		theme,
		_intlDayHeader,
		_scrollable,
		_days
	];
}

class Header extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});
	}
}

/* packages/day-grid/src/Body.svelte generated by Svelte v3.55.1 */

function create_fragment$5(ctx) {
	let div1;
	let div0;
	let div0_class_value;
	let div1_class_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			attr(div0, "class", div0_class_value = /*$theme*/ ctx[1].content);

			attr(div1, "class", div1_class_value = "" + (/*$theme*/ ctx[1].body + (/*$dayMaxEvents*/ ctx[2] === true
			? ' ' + /*$theme*/ ctx[1].uniform
			: '')));
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			/*div1_binding*/ ctx[13](div1);
			current = true;

			if (!mounted) {
				dispose = [
					listen(window, "resize", /*recheckScrollable*/ ctx[9]),
					listen(div1, "scroll", function () {
						if (is_function(/*$_scroll*/ ctx[3])) /*$_scroll*/ ctx[3].apply(this, arguments);
					})
				];

				mounted = true;
			}
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[11],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*$theme*/ 2 && div0_class_value !== (div0_class_value = /*$theme*/ ctx[1].content)) {
				attr(div0, "class", div0_class_value);
			}

			if (!current || dirty & /*$theme, $dayMaxEvents*/ 6 && div1_class_value !== (div1_class_value = "" + (/*$theme*/ ctx[1].body + (/*$dayMaxEvents*/ ctx[2] === true
			? ' ' + /*$theme*/ ctx[1].uniform
			: '')))) {
				attr(div1, "class", div1_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (default_slot) default_slot.d(detaching);
			/*div1_binding*/ ctx[13](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	let $_scrollable;
	let $_events;
	let $theme;
	let $dayMaxEvents;
	let $_scroll;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { dayMaxEvents, _events, _scrollable, _scroll, theme } = getContext('state');
	component_subscribe($$self, dayMaxEvents, value => $$invalidate(2, $dayMaxEvents = value));
	component_subscribe($$self, _events, value => $$invalidate(10, $_events = value));
	component_subscribe($$self, _scrollable, value => $$invalidate(14, $_scrollable = value));
	component_subscribe($$self, _scroll, value => $$invalidate(3, $_scroll = value));
	component_subscribe($$self, theme, value => $$invalidate(1, $theme = value));
	let el;

	function recheckScrollable() {
		set_store_value(_scrollable, $_scrollable = hasYScroll(el), $_scrollable);
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(11, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*el, $_events*/ 1025) {
			if (el && $_events) {
				setTimeout(recheckScrollable);
			}
		}
	};

	return [
		el,
		$theme,
		$dayMaxEvents,
		$_scroll,
		dayMaxEvents,
		_events,
		_scrollable,
		_scroll,
		theme,
		recheckScrollable,
		$_events,
		$$scope,
		slots,
		div1_binding
	];
}

class Body$1 extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});
	}
}

/* packages/day-grid/src/Event.svelte generated by Svelte v3.55.1 */

function create_fragment$4(ctx) {
	let div1;
	let div0;
	let div0_class_value;
	let setContent_action;
	let t;
	let switch_instance;
	let current;
	let mounted;
	let dispose;
	var switch_value = /*$_interaction*/ ctx[7].resizer;

	function switch_props(ctx) {
		return { props: { event: /*event*/ ctx[0] } };
	}

	if (switch_value) {
		switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		switch_instance.$on("pointerdown", /*createDragHandler*/ ctx[30](true));
	}

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			t = space();
			if (switch_instance) create_component(switch_instance.$$.fragment);
			attr(div0, "class", div0_class_value = /*$theme*/ ctx[1].eventBody);
			attr(div1, "class", /*classes*/ ctx[3]);
			attr(div1, "style", /*style*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div1, t);
			if (switch_instance) mount_component(switch_instance, div1, null);
			/*div1_binding*/ ctx[45](div1);
			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(setContent_action = setContent$1.call(null, div0, /*content*/ ctx[5])),
					listen(div1, "click", function () {
						if (is_function(maybeIgnore(/*createHandler*/ ctx[29](/*$eventClick*/ ctx[8], /*display*/ ctx[6])))) maybeIgnore(/*createHandler*/ ctx[29](/*$eventClick*/ ctx[8], /*display*/ ctx[6])).apply(this, arguments);
					}),
					listen(div1, "mouseenter", function () {
						if (is_function(/*createHandler*/ ctx[29](/*$eventMouseEnter*/ ctx[9], /*display*/ ctx[6]))) /*createHandler*/ ctx[29](/*$eventMouseEnter*/ ctx[9], /*display*/ ctx[6]).apply(this, arguments);
					}),
					listen(div1, "mouseleave", function () {
						if (is_function(/*createHandler*/ ctx[29](/*$eventMouseLeave*/ ctx[10], /*display*/ ctx[6]))) /*createHandler*/ ctx[29](/*$eventMouseLeave*/ ctx[10], /*display*/ ctx[6]).apply(this, arguments);
					}),
					listen(div1, "pointerdown", function () {
						if (is_function(/*display*/ ctx[6] === 'auto' && /*$_draggable*/ ctx[11](/*event*/ ctx[0])
						? /*createDragHandler*/ ctx[30]()
						: undefined)) (/*display*/ ctx[6] === 'auto' && /*$_draggable*/ ctx[11](/*event*/ ctx[0])
						? /*createDragHandler*/ ctx[30]()
						: undefined).apply(this, arguments);
					})
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (!current || dirty[0] & /*$theme*/ 2 && div0_class_value !== (div0_class_value = /*$theme*/ ctx[1].eventBody)) {
				attr(div0, "class", div0_class_value);
			}

			if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*content*/ 32) setContent_action.update.call(null, /*content*/ ctx[5]);
			const switch_instance_changes = {};
			if (dirty[0] & /*event*/ 1) switch_instance_changes.event = /*event*/ ctx[0];

			if (switch_value !== (switch_value = /*$_interaction*/ ctx[7].resizer)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
					switch_instance.$on("pointerdown", /*createDragHandler*/ ctx[30](true));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, div1, null);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}

			if (!current || dirty[0] & /*classes*/ 8) {
				attr(div1, "class", /*classes*/ ctx[3]);
			}

			if (!current || dirty[0] & /*style*/ 16) {
				attr(div1, "style", /*style*/ ctx[4]);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (switch_instance) destroy_component(switch_instance);
			/*div1_binding*/ ctx[45](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let $_hiddenEvents;
	let $dayMaxEvents;
	let $_interaction;
	let $_view;
	let $eventDidMount;
	let $_intlEventTime;
	let $theme;
	let $eventContent;
	let $displayEventEnd;
	let $_classes;
	let $eventColor;
	let $eventBackgroundColor;
	let $_resBgColor;
	let $eventClick;
	let $eventMouseEnter;
	let $eventMouseLeave;
	let $_draggable;
	let { chunk } = $$props;
	let { longChunks = {} } = $$props;
	let { inPopup = false } = $$props;
	let { dayMaxEvents, displayEventEnd, eventBackgroundColor, eventClick, eventColor, eventContent, eventDidMount, eventMouseEnter, eventMouseLeave, theme, _view, _intlEventTime, _interaction, _classes, _draggable, _resBgColor } = getContext('state');
	component_subscribe($$self, dayMaxEvents, value => $$invalidate(48, $dayMaxEvents = value));
	component_subscribe($$self, displayEventEnd, value => $$invalidate(40, $displayEventEnd = value));
	component_subscribe($$self, eventBackgroundColor, value => $$invalidate(43, $eventBackgroundColor = value));
	component_subscribe($$self, eventClick, value => $$invalidate(8, $eventClick = value));
	component_subscribe($$self, eventColor, value => $$invalidate(42, $eventColor = value));
	component_subscribe($$self, eventContent, value => $$invalidate(39, $eventContent = value));
	component_subscribe($$self, eventDidMount, value => $$invalidate(49, $eventDidMount = value));
	component_subscribe($$self, eventMouseEnter, value => $$invalidate(9, $eventMouseEnter = value));
	component_subscribe($$self, eventMouseLeave, value => $$invalidate(10, $eventMouseLeave = value));
	component_subscribe($$self, theme, value => $$invalidate(1, $theme = value));
	component_subscribe($$self, _view, value => $$invalidate(37, $_view = value));
	component_subscribe($$self, _intlEventTime, value => $$invalidate(38, $_intlEventTime = value));
	component_subscribe($$self, _interaction, value => $$invalidate(7, $_interaction = value));
	component_subscribe($$self, _classes, value => $$invalidate(41, $_classes = value));
	component_subscribe($$self, _draggable, value => $$invalidate(11, $_draggable = value));
	component_subscribe($$self, _resBgColor, value => $$invalidate(44, $_resBgColor = value));
	let { _hiddenEvents } = getContext('view-state');
	component_subscribe($$self, _hiddenEvents, value => $$invalidate(47, $_hiddenEvents = value));
	let el;
	let event;
	let classes;
	let style;
	let content;
	let timeText;
	let margin = 1;
	let hidden = false;
	let display;

	onMount(() => {
		if (is_function($eventDidMount)) {
			$eventDidMount({
				event: toEventWithLocalDates(event),
				timeText,
				el,
				view: toViewWithLocalDates($_view)
			});
		}
	});

	function createHandler(fn, display) {
		return display !== 'preview' && is_function(fn)
		? jsEvent => fn({
				event: toEventWithLocalDates(event),
				el,
				jsEvent,
				view: toViewWithLocalDates($_view)
			})
		: undefined;
	}

	function createDragHandler(resize) {
		return jsEvent => $_interaction.action.dragDayGrid(event, el, jsEvent, inPopup, resize);
	}

	function reposition() {
		if (!el || display === 'preview' || inPopup) {
			return;
		}

		$$invalidate(35, margin = repositionEvent(chunk, longChunks, height(el)));

		if ($dayMaxEvents === true) {
			hide();
		} else {
			$$invalidate(36, hidden = false);
		}
	}

	function hide() {
		let dayEl = ancestor(el, 2);
		let h = height(dayEl) - height(dayEl.firstElementChild) - footHeight(dayEl);
		$$invalidate(36, hidden = chunk.bottom > h);
		let update = false;

		// Hide or show the event throughout all days
		for (let date of chunk.dates) {
			let hiddenEvents = $_hiddenEvents[date.getTime()];

			if (hiddenEvents) {
				let size = hiddenEvents.size;

				if (hidden) {
					hiddenEvents.add(chunk.event);
				} else {
					hiddenEvents.delete(chunk.event);
				}

				if (size !== hiddenEvents.size) {
					update = true;
				}
			}
		}

		if (update) {
			_hiddenEvents.set($_hiddenEvents);
		}
	}

	function footHeight(dayEl) {
		let h = 0;

		for (let i = 0; i < chunk.days; ++i) {
			h = Math.max(h, height(dayEl.lastElementChild));
			dayEl = dayEl.nextElementSibling;

			if (!dayEl) {
				break;
			}
		}

		return h;
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(2, el);
		});
	}

	$$self.$$set = $$props => {
		if ('chunk' in $$props) $$invalidate(31, chunk = $$props.chunk);
		if ('longChunks' in $$props) $$invalidate(32, longChunks = $$props.longChunks);
		if ('inPopup' in $$props) $$invalidate(33, inPopup = $$props.inPopup);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[1] & /*chunk*/ 1) {
			$$invalidate(0, event = chunk.event);
		}

		if ($$self.$$.dirty[0] & /*event, style, $theme*/ 19 | $$self.$$.dirty[1] & /*$_resBgColor, $eventBackgroundColor, $eventColor, chunk, margin, hidden, $_classes*/ 15409) {
			{
				$$invalidate(6, display = event.display);

				// Class & Style
				let bgColor = event.backgroundColor || $_resBgColor(event) || $eventBackgroundColor || $eventColor;

				$$invalidate(4, style = `width:calc(${chunk.days * 100}% + ${(chunk.days - 1) * 7}px);` + `margin-top:${margin}px;`);

				if (bgColor) {
					$$invalidate(4, style += `background-color:${bgColor};`);
				}

				if (hidden) {
					$$invalidate(4, style += 'visibility:hidden;');
				}

				$$invalidate(3, classes = $_classes($theme.event, event));
			}
		}

		if ($$self.$$.dirty[0] & /*$theme*/ 2 | $$self.$$.dirty[1] & /*chunk, $displayEventEnd, $eventContent, $_intlEventTime, $_view*/ 961) {
			// Content
			$$invalidate(5, [timeText, content] = createEventContent(chunk, $displayEventEnd, $eventContent, $theme, $_intlEventTime, $_view), content);
		}
	};

	return [
		event,
		$theme,
		el,
		classes,
		style,
		content,
		display,
		$_interaction,
		$eventClick,
		$eventMouseEnter,
		$eventMouseLeave,
		$_draggable,
		dayMaxEvents,
		displayEventEnd,
		eventBackgroundColor,
		eventClick,
		eventColor,
		eventContent,
		eventDidMount,
		eventMouseEnter,
		eventMouseLeave,
		theme,
		_view,
		_intlEventTime,
		_interaction,
		_classes,
		_draggable,
		_resBgColor,
		_hiddenEvents,
		createHandler,
		createDragHandler,
		chunk,
		longChunks,
		inPopup,
		reposition,
		margin,
		hidden,
		$_view,
		$_intlEventTime,
		$eventContent,
		$displayEventEnd,
		$_classes,
		$eventColor,
		$eventBackgroundColor,
		$_resBgColor,
		div1_binding
	];
}

class Event$2 extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$4,
			create_fragment$4,
			safe_not_equal,
			{
				chunk: 31,
				longChunks: 32,
				inPopup: 33,
				reposition: 34
			},
			null,
			[-1, -1]
		);
	}

	get reposition() {
		return this.$$.ctx[34];
	}
}

/* packages/day-grid/src/Popup.svelte generated by Svelte v3.55.1 */

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[18] = list[i];
	return child_ctx;
}

// (84:8) {#each $_popupChunks as chunk (chunk.event)}
function create_each_block$3(key_1, ctx) {
	let first;
	let event;
	let current;

	event = new Event$2({
			props: { chunk: /*chunk*/ ctx[18], inPopup: true }
		});

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			create_component(event.$$.fragment);
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);
			mount_component(event, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const event_changes = {};
			if (dirty & /*$_popupChunks*/ 1) event_changes.chunk = /*chunk*/ ctx[18];
			event.$set(event_changes);
		},
		i(local) {
			if (current) return;
			transition_in(event.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(event.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			destroy_component(event, detaching);
		}
	};
}

function create_fragment$3$1(ctx) {
	let div2;
	let div0;
	let t0_value = /*$_intlDayPopover*/ ctx[5].format(/*$_popupDate*/ ctx[3]) + "";
	let t0;
	let t1;
	let a;
	let div0_class_value;
	let t3;
	let div1;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let div1_class_value;
	let div2_class_value;
	let current;
	let mounted;
	let dispose;
	let each_value = /*$_popupChunks*/ ctx[0];
	const get_key = ctx => /*chunk*/ ctx[18].event;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$3(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
	}

	return {
		c() {
			div2 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			a = element("a");
			a.textContent = "×";
			t3 = space();
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div0, "class", div0_class_value = /*$theme*/ ctx[4].dayHead);
			attr(div1, "class", div1_class_value = /*$theme*/ ctx[4].events);
			attr(div2, "class", div2_class_value = /*$theme*/ ctx[4].popup);
			attr(div2, "style", /*style*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div0);
			append(div0, t0);
			append(div0, t1);
			append(div0, a);
			append(div2, t3);
			append(div2, div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			/*div2_binding*/ ctx[14](div2);
			current = true;

			if (!mounted) {
				dispose = [
					listen(a, "click", stop_propagation(/*close*/ ctx[11])),
					action_destroyer(outsideEvent.call(null, div2, 'pointerdown')),
					listen(div2, "pointerdown", stop_propagation(/*pointerdown_handler*/ ctx[13])),
					listen(div2, "pointerdownoutside", /*handlePointerDownOutside*/ ctx[12])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if ((!current || dirty & /*$_intlDayPopover, $_popupDate*/ 40) && t0_value !== (t0_value = /*$_intlDayPopover*/ ctx[5].format(/*$_popupDate*/ ctx[3]) + "")) set_data(t0, t0_value);

			if (!current || dirty & /*$theme*/ 16 && div0_class_value !== (div0_class_value = /*$theme*/ ctx[4].dayHead)) {
				attr(div0, "class", div0_class_value);
			}

			if (dirty & /*$_popupChunks*/ 1) {
				each_value = /*$_popupChunks*/ ctx[0];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div1, outro_and_destroy_block, create_each_block$3, null, get_each_context$3);
				check_outros();
			}

			if (!current || dirty & /*$theme*/ 16 && div1_class_value !== (div1_class_value = /*$theme*/ ctx[4].events)) {
				attr(div1, "class", div1_class_value);
			}

			if (!current || dirty & /*$theme*/ 16 && div2_class_value !== (div2_class_value = /*$theme*/ ctx[4].popup)) {
				attr(div2, "class", div2_class_value);
			}

			if (!current || dirty & /*style*/ 4) {
				attr(div2, "style", /*style*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			/*div2_binding*/ ctx[14](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$3$1($$self, $$props, $$invalidate) {
	let $_ignoreClick;
	let $_popupDate;
	let $_popupChunks;
	let $theme;
	let $_intlDayPopover;
	let { theme, _ignoreClick, _intlDayPopover } = getContext('state');
	component_subscribe($$self, theme, value => $$invalidate(4, $theme = value));
	component_subscribe($$self, _ignoreClick, value => $$invalidate(15, $_ignoreClick = value));
	component_subscribe($$self, _intlDayPopover, value => $$invalidate(5, $_intlDayPopover = value));
	let { _popupDate, _popupChunks } = getContext('view-state');
	component_subscribe($$self, _popupDate, value => $$invalidate(3, $_popupDate = value));
	component_subscribe($$self, _popupChunks, value => $$invalidate(0, $_popupChunks = value));
	let el;
	let style = '';

	function position() {
		let dayEl = ancestor(el, 1);
		let bodyEl = ancestor(dayEl, 3);
		let popupRect = rect(el);
		let dayRect = rect(dayEl);
		let bodyRect = rect(bodyEl);

		if (!dayEl.previousElementSibling) {
			$$invalidate(2, style = 'left:0;');
		} else if (!dayEl.nextElementSibling) {
			$$invalidate(2, style = 'right:0;');
		} else {
			let left = (dayEl.offsetWidth - popupRect.width) / 2;
			$$invalidate(2, style = `left:${left}px;`);
		}

		let top;

		if (popupRect.height >= bodyRect.height) {
			top = bodyRect.top - dayRect.top;
			let bottom = dayRect.bottom - bodyRect.bottom;
			$$invalidate(2, style += `bottom:${bottom}px;`);
		} else {
			top = (dayRect.height - popupRect.height) / 2;

			if (dayRect.top + top < bodyRect.top) {
				top = bodyRect.top - dayRect.top;
			} else if (dayRect.top + top + popupRect.height > bodyRect.bottom) {
				top = bodyRect.bottom - dayRect.top - popupRect.height;
			}
		}

		$$invalidate(2, style += `top:${top}px;`);
	}

	function reposition() {
		// Skip the first call (el is not defined at this time)
		if (el) {
			$$invalidate(2, style = '');

			// Let chunks to update/mount then position the popup
			tick().then(() => {
				if ($_popupChunks.length) {
					position();
				} else {
					close();
				}
			});
		}
	}

	function close(e) {
		set_store_value(_popupDate, $_popupDate = null, $_popupDate);
	}

	function handlePointerDownOutside(e) {
		close();
		set_store_value(_ignoreClick, $_ignoreClick = true, $_ignoreClick);
	}

	function pointerdown_handler(event) {
		bubble.call(this, $$self, event);
	}

	function div2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(1, el);
		});
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$_popupChunks*/ 1) {
			if ($_popupChunks) {
				// Fire reposition only on popup chunks change
				reposition();
			}
		}
	};

	return [
		$_popupChunks,
		el,
		style,
		$_popupDate,
		$theme,
		$_intlDayPopover,
		theme,
		_ignoreClick,
		_intlDayPopover,
		_popupDate,
		_popupChunks,
		close,
		handlePointerDownOutside,
		pointerdown_handler,
		div2_binding
	];
}

class Popup extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$3$1, create_fragment$3$1, safe_not_equal, {});
	}
}

/* packages/day-grid/src/Day.svelte generated by Svelte v3.55.1 */

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[48] = list[i];
	child_ctx[49] = list;
	child_ctx[50] = i;
	return child_ctx;
}

// (141:4) {#if iChunks[1] && datesEqual(iChunks[1].date, date)}
function create_if_block_3(ctx) {
	let div;
	let event;
	let div_class_value;
	let current;
	event = new Event$2({ props: { chunk: /*iChunks*/ ctx[2][1] } });

	return {
		c() {
			div = element("div");
			create_component(event.$$.fragment);
			attr(div, "class", div_class_value = /*$theme*/ ctx[12].events);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(event, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const event_changes = {};
			if (dirty[0] & /*iChunks*/ 4) event_changes.chunk = /*iChunks*/ ctx[2][1];
			event.$set(event_changes);

			if (!current || dirty[0] & /*$theme*/ 4096 && div_class_value !== (div_class_value = /*$theme*/ ctx[12].events)) {
				attr(div, "class", div_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(event.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(event.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(event);
		}
	};
}

// (147:4) {#if iChunks[0] && datesEqual(iChunks[0].date, date)}
function create_if_block_2(ctx) {
	let div;
	let event;
	let div_class_value;
	let current;
	event = new Event$2({ props: { chunk: /*iChunks*/ ctx[2][0] } });

	return {
		c() {
			div = element("div");
			create_component(event.$$.fragment);
			attr(div, "class", div_class_value = "" + (/*$theme*/ ctx[12].events + " " + /*$theme*/ ctx[12].preview));
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(event, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const event_changes = {};
			if (dirty[0] & /*iChunks*/ 4) event_changes.chunk = /*iChunks*/ ctx[2][0];
			event.$set(event_changes);

			if (!current || dirty[0] & /*$theme*/ 4096 && div_class_value !== (div_class_value = "" + (/*$theme*/ ctx[12].events + " " + /*$theme*/ ctx[12].preview))) {
				attr(div, "class", div_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(event.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(event.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(event);
		}
	};
}

// (153:8) {#each dayChunks as chunk, i (chunk.event)}
function create_each_block$2(key_1, ctx) {
	let first;
	let event;
	let i = /*i*/ ctx[50];
	let current;
	const assign_event = () => /*event_binding*/ ctx[39](event, i);
	const unassign_event = () => /*event_binding*/ ctx[39](null, i);

	let event_props = {
		chunk: /*chunk*/ ctx[48],
		longChunks: /*longChunks*/ ctx[1]
	};

	event = new Event$2({ props: event_props });
	assign_event();

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			create_component(event.$$.fragment);
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);
			mount_component(event, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (i !== /*i*/ ctx[50]) {
				unassign_event();
				i = /*i*/ ctx[50];
				assign_event();
			}

			const event_changes = {};
			if (dirty[0] & /*dayChunks*/ 16) event_changes.chunk = /*chunk*/ ctx[48];
			if (dirty[0] & /*longChunks*/ 2) event_changes.longChunks = /*longChunks*/ ctx[1];
			event.$set(event_changes);
		},
		i(local) {
			if (current) return;
			transition_in(event.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(event.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			unassign_event();
			destroy_component(event, detaching);
		}
	};
}

// (157:4) {#if showPopup}
function create_if_block_1(ctx) {
	let popup;
	let current;
	popup = new Popup({});

	return {
		c() {
			create_component(popup.$$.fragment);
		},
		m(target, anchor) {
			mount_component(popup, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in(popup.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(popup.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(popup, detaching);
		}
	};
}

// (161:8) {#if hiddenEvents.size}
function create_if_block$2(ctx) {
	let a;
	let setContent_action;
	let mounted;
	let dispose;

	return {
		c() {
			a = element("a");
		},
		m(target, anchor) {
			insert(target, a, anchor);

			if (!mounted) {
				dispose = [
					listen(a, "click", stop_propagation(/*showMore*/ ctx[29])),
					listen(a, "pointerdown", stop_propagation(/*pointerdown_handler*/ ctx[38])),
					action_destroyer(setContent_action = setContent$1.call(null, a, /*moreLink*/ ctx[6]))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*moreLink*/ 64) setContent_action.update.call(null, /*moreLink*/ ctx[6]);
		},
		d(detaching) {
			if (detaching) detach(a);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$2$1(ctx) {
	let div3;
	let div0;
	let t0_value = /*date*/ ctx[0].getUTCDate() + "";
	let t0;
	let div0_class_value;
	let t1;
	let show_if_1 = /*iChunks*/ ctx[2][1] && datesEqual(/*iChunks*/ ctx[2][1].date, /*date*/ ctx[0]);
	let t2;
	let show_if = /*iChunks*/ ctx[2][0] && datesEqual(/*iChunks*/ ctx[2][0].date, /*date*/ ctx[0]);
	let t3;
	let div1;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let div1_class_value;
	let t4;
	let t5;
	let div2;
	let div2_class_value;
	let div3_class_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = show_if_1 && create_if_block_3(ctx);
	let if_block1 = show_if && create_if_block_2(ctx);
	let each_value = /*dayChunks*/ ctx[4];
	const get_key = ctx => /*chunk*/ ctx[48].event;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$2(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
	}

	let if_block2 = /*showPopup*/ ctx[7] && create_if_block_1();
	let if_block3 = /*hiddenEvents*/ ctx[5].size && create_if_block$2(ctx);

	return {
		c() {
			div3 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t4 = space();
			if (if_block2) if_block2.c();
			t5 = space();
			div2 = element("div");
			if (if_block3) if_block3.c();
			attr(div0, "class", div0_class_value = /*$theme*/ ctx[12].dayHead);
			attr(div1, "class", div1_class_value = /*$theme*/ ctx[12].events);
			attr(div2, "class", div2_class_value = /*$theme*/ ctx[12].dayFoot);

			attr(div3, "class", div3_class_value = "" + (/*$theme*/ ctx[12].day + (/*isToday*/ ctx[8] ? ' ' + /*$theme*/ ctx[12].today : '') + (/*otherMonth*/ ctx[9]
			? ' ' + /*$theme*/ ctx[12].otherMonth
			: '') + (/*highlight*/ ctx[10]
			? ' ' + /*$theme*/ ctx[12].highlight
			: '')));
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div0);
			append(div0, t0);
			append(div3, t1);
			if (if_block0) if_block0.m(div3, null);
			append(div3, t2);
			if (if_block1) if_block1.m(div3, null);
			append(div3, t3);
			append(div3, div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			append(div3, t4);
			if (if_block2) if_block2.m(div3, null);
			append(div3, t5);
			append(div3, div2);
			if (if_block3) if_block3.m(div2, null);
			/*div3_binding*/ ctx[40](div3);
			current = true;

			if (!mounted) {
				dispose = [
					listen(window, "resize", /*reposition*/ ctx[31]),
					listen(div3, "click", function () {
						if (is_function(maybeIgnore(/*createClickHandler*/ ctx[27](/*$dateClick*/ ctx[13])))) maybeIgnore(/*createClickHandler*/ ctx[27](/*$dateClick*/ ctx[13])).apply(this, arguments);
					}),
					listen(div3, "pointerenter", function () {
						if (is_function(/*createPointerEnterHandler*/ ctx[28](/*$_interaction*/ ctx[14]))) /*createPointerEnterHandler*/ ctx[28](/*$_interaction*/ ctx[14]).apply(this, arguments);
					}),
					listen(div3, "pointerleave", function () {
						if (is_function(createPointerLeaveHandler(/*$_interaction*/ ctx[14]))) createPointerLeaveHandler(/*$_interaction*/ ctx[14]).apply(this, arguments);
					}),
					listen(div3, "pointerdown", function () {
						if (is_function(/*createPointerDownHandler*/ ctx[30](/*$_interaction*/ ctx[14], /*$selectable*/ ctx[15]))) /*createPointerDownHandler*/ ctx[30](/*$_interaction*/ ctx[14], /*$selectable*/ ctx[15]).apply(this, arguments);
					})
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty[0] & /*date*/ 1) && t0_value !== (t0_value = /*date*/ ctx[0].getUTCDate() + "")) set_data(t0, t0_value);

			if (!current || dirty[0] & /*$theme*/ 4096 && div0_class_value !== (div0_class_value = /*$theme*/ ctx[12].dayHead)) {
				attr(div0, "class", div0_class_value);
			}

			if (dirty[0] & /*iChunks, date*/ 5) show_if_1 = /*iChunks*/ ctx[2][1] && datesEqual(/*iChunks*/ ctx[2][1].date, /*date*/ ctx[0]);

			if (show_if_1) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*iChunks, date*/ 5) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div3, t2);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (dirty[0] & /*iChunks, date*/ 5) show_if = /*iChunks*/ ctx[2][0] && datesEqual(/*iChunks*/ ctx[2][0].date, /*date*/ ctx[0]);

			if (show_if) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*iChunks, date*/ 5) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div3, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (dirty[0] & /*dayChunks, longChunks, refs*/ 2066) {
				each_value = /*dayChunks*/ ctx[4];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div1, outro_and_destroy_block, create_each_block$2, null, get_each_context$2);
				check_outros();
			}

			if (!current || dirty[0] & /*$theme*/ 4096 && div1_class_value !== (div1_class_value = /*$theme*/ ctx[12].events)) {
				attr(div1, "class", div1_class_value);
			}

			if (/*showPopup*/ ctx[7]) {
				if (if_block2) {
					if (dirty[0] & /*showPopup*/ 128) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_1();
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div3, t5);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*hiddenEvents*/ ctx[5].size) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block$2(ctx);
					if_block3.c();
					if_block3.m(div2, null);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (!current || dirty[0] & /*$theme*/ 4096 && div2_class_value !== (div2_class_value = /*$theme*/ ctx[12].dayFoot)) {
				attr(div2, "class", div2_class_value);
			}

			if (!current || dirty[0] & /*$theme, isToday, otherMonth, highlight*/ 5888 && div3_class_value !== (div3_class_value = "" + (/*$theme*/ ctx[12].day + (/*isToday*/ ctx[8] ? ' ' + /*$theme*/ ctx[12].today : '') + (/*otherMonth*/ ctx[9]
			? ' ' + /*$theme*/ ctx[12].otherMonth
			: '') + (/*highlight*/ ctx[10]
			? ' ' + /*$theme*/ ctx[12].highlight
			: '')))) {
				attr(div3, "class", div3_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(if_block2);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(if_block2);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div3);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			/*div3_binding*/ ctx[40](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function createPointerLeaveHandler(interaction) {
	return interaction.pointer
	? interaction.pointer.leave
	: undefined;
}

function instance$2$1($$self, $$props, $$invalidate) {
	let $_hiddenEvents;
	let $_popupChunks;
	let $_popupDate;
	let $_view;
	let $moreLinkContent;
	let $highlightedDates;
	let $currentDate;
	let $theme;
	let $dateClick;
	let $_interaction;
	let $selectable;
	let { date } = $$props;
	let { chunks } = $$props;
	let { longChunks } = $$props;
	let { iChunks = [] } = $$props;
	let { date: currentDate, dateClick, dayMaxEvents, highlightedDates, moreLinkContent, theme, _view, _interaction, selectable, _queue } = getContext('state');
	component_subscribe($$self, currentDate, value => $$invalidate(37, $currentDate = value));
	component_subscribe($$self, dateClick, value => $$invalidate(13, $dateClick = value));
	component_subscribe($$self, highlightedDates, value => $$invalidate(36, $highlightedDates = value));
	component_subscribe($$self, moreLinkContent, value => $$invalidate(35, $moreLinkContent = value));
	component_subscribe($$self, theme, value => $$invalidate(12, $theme = value));
	component_subscribe($$self, _view, value => $$invalidate(42, $_view = value));
	component_subscribe($$self, _interaction, value => $$invalidate(14, $_interaction = value));
	component_subscribe($$self, selectable, value => $$invalidate(15, $selectable = value));
	let { _hiddenEvents, _popupDate, _popupChunks } = getContext('view-state');
	component_subscribe($$self, _hiddenEvents, value => $$invalidate(33, $_hiddenEvents = value));
	component_subscribe($$self, _popupDate, value => $$invalidate(34, $_popupDate = value));
	component_subscribe($$self, _popupChunks, value => $$invalidate(41, $_popupChunks = value));
	let el;
	let dayChunks;
	let today = setMidnight(createDate());
	let isToday;
	let otherMonth;
	let highlight;
	let hiddenEvents = new Set(); // hidden events of this day
	let moreLink = '';
	let showPopup;
	let refs = [];

	function createClickHandler(fn) {
		return is_function(fn)
		? jsEvent => fn({
				allDay: true,
				date: toLocalDate$1(date),
				dateStr: toISOString(date),
				dayEl: el,
				jsEvent,
				view: toViewWithLocalDates($_view)
			})
		: undefined;
	}

	function createPointerEnterHandler(interaction) {
		return interaction.pointer
		? jsEvent => interaction.pointer.enterDayGrid(date, jsEvent)
		: undefined;
	}

	function showMore() {
		set_store_value(_popupDate, $_popupDate = date, $_popupDate);
	}

	function setPopupChunks() {
		let nextDay = addDay(cloneDate(date));
		let chunks = dayChunks.concat(longChunks[date.getTime()]?.chunks || []);
		set_store_value(_popupChunks, $_popupChunks = chunks.map(chunk => assign({}, chunk, createEventChunk(chunk.event, date, nextDay), { days: 1, dates: [date] })).sort((a, b) => a.top - b.top), $_popupChunks);
	}

	function createPointerDownHandler(interaction, selectable) {
		return selectable && interaction.action
		? jsEvent => interaction.action.selectDayGrid(date, el, jsEvent)
		: undefined;
	}

	function reposition() {
		$$invalidate(11, refs.length = dayChunks.length, refs);

		for (let ref of refs) {
			ref && ref.reposition && ref.reposition();
		}
	}

	afterUpdate(reposition);
	let debounceHandle = {};

	function pointerdown_handler(event) {
		bubble.call(this, $$self, event);
	}

	function event_binding($$value, i) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			refs[i] = $$value;
			$$invalidate(11, refs);
		});
	}

	function div3_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(3, el);
		});
	}

	$$self.$$set = $$props => {
		if ('date' in $$props) $$invalidate(0, date = $$props.date);
		if ('chunks' in $$props) $$invalidate(32, chunks = $$props.chunks);
		if ('longChunks' in $$props) $$invalidate(1, longChunks = $$props.longChunks);
		if ('iChunks' in $$props) $$invalidate(2, iChunks = $$props.iChunks);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*hiddenEvents, date, dayChunks*/ 49 | $$self.$$.dirty[1] & /*chunks*/ 2) {
			{
				$$invalidate(4, dayChunks = []);
				hiddenEvents.clear();
				((($$invalidate(5, hiddenEvents), $$invalidate(32, chunks)), $$invalidate(0, date)), $$invalidate(4, dayChunks));

				for (let chunk of chunks) {
					if (datesEqual(chunk.date, date)) {
						dayChunks.push(chunk);
					} // if ($dayMaxEvents !== false && dayChunks.length > $dayMaxEvents) {
					// 	chunk.hidden = true;
				} // }
			}
		}

		if ($$self.$$.dirty[0] & /*date, hiddenEvents*/ 33) {
			set_store_value(_hiddenEvents, $_hiddenEvents[date.getTime()] = hiddenEvents, $_hiddenEvents);
		}

		if ($$self.$$.dirty[0] & /*date*/ 1 | $$self.$$.dirty[1] & /*$currentDate, $highlightedDates*/ 96) {
			{
				$$invalidate(8, isToday = datesEqual(date, today));
				$$invalidate(9, otherMonth = date.getUTCMonth() !== $currentDate.getUTCMonth());
				$$invalidate(10, highlight = $highlightedDates.some(d => datesEqual(d, date)));
			}
		}

		if ($$self.$$.dirty[0] & /*hiddenEvents, moreLink*/ 96 | $$self.$$.dirty[1] & /*$_hiddenEvents, $moreLinkContent*/ 20) {
			if ($_hiddenEvents && hiddenEvents.size) {
				// make Svelte update this block on $_hiddenEvents update
				let text = '+' + hiddenEvents.size + ' more';

				if ($moreLinkContent) {
					$$invalidate(6, moreLink = is_function($moreLinkContent)
					? $moreLinkContent({ num: hiddenEvents.size, text })
					: $moreLinkContent);

					if (typeof moreLink === 'string') {
						$$invalidate(6, moreLink = { html: moreLink });
					}
				} else {
					$$invalidate(6, moreLink = { html: text });
				}
			}
		}

		if ($$self.$$.dirty[0] & /*date*/ 1 | $$self.$$.dirty[1] & /*$_popupDate*/ 8) {
			$$invalidate(7, showPopup = $_popupDate && datesEqual(date, $_popupDate));
		}

		if ($$self.$$.dirty[0] & /*showPopup, longChunks, dayChunks*/ 146) {
			if (showPopup && longChunks && dayChunks) {
				// Let chunks to reposition then set popup chunks
				tick().then(setPopupChunks);
			}
		}

		if ($$self.$$.dirty[0] & /*el, date*/ 9) {
			// dateFromPoint
			if (el) {
				setFn(el, () => date);
			}
		}

		if ($$self.$$.dirty[1] & /*$_hiddenEvents*/ 4) {
			if ($_hiddenEvents) {
				debounce(reposition, debounceHandle, _queue);
			}
		}
	};

	return [
		date,
		longChunks,
		iChunks,
		el,
		dayChunks,
		hiddenEvents,
		moreLink,
		showPopup,
		isToday,
		otherMonth,
		highlight,
		refs,
		$theme,
		$dateClick,
		$_interaction,
		$selectable,
		currentDate,
		dateClick,
		highlightedDates,
		moreLinkContent,
		theme,
		_view,
		_interaction,
		selectable,
		_hiddenEvents,
		_popupDate,
		_popupChunks,
		createClickHandler,
		createPointerEnterHandler,
		showMore,
		createPointerDownHandler,
		reposition,
		chunks,
		$_hiddenEvents,
		$_popupDate,
		$moreLinkContent,
		$highlightedDates,
		$currentDate,
		pointerdown_handler,
		event_binding,
		div3_binding
	];
}

class Day$1 extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$2$1,
			create_fragment$2$1,
			safe_not_equal,
			{
				date: 0,
				chunks: 32,
				longChunks: 1,
				iChunks: 2
			},
			null,
			[-1, -1]
		);
	}
}

/* packages/day-grid/src/Week.svelte generated by Svelte v3.55.1 */

function get_each_context$1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[14] = list[i];
	return child_ctx;
}

// (45:4) {#each dates as date}
function create_each_block$1$1(ctx) {
	let day;
	let current;

	day = new Day$1({
			props: {
				date: /*date*/ ctx[14],
				chunks: /*chunks*/ ctx[1],
				longChunks: /*longChunks*/ ctx[2],
				iChunks: /*iChunks*/ ctx[3]
			}
		});

	return {
		c() {
			create_component(day.$$.fragment);
		},
		m(target, anchor) {
			mount_component(day, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const day_changes = {};
			if (dirty & /*dates*/ 1) day_changes.date = /*date*/ ctx[14];
			if (dirty & /*chunks*/ 2) day_changes.chunks = /*chunks*/ ctx[1];
			if (dirty & /*longChunks*/ 4) day_changes.longChunks = /*longChunks*/ ctx[2];
			if (dirty & /*iChunks*/ 8) day_changes.iChunks = /*iChunks*/ ctx[3];
			day.$set(day_changes);
		},
		i(local) {
			if (current) return;
			transition_in(day.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(day.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(day, detaching);
		}
	};
}

function create_fragment$1$1(ctx) {
	let div;
	let div_class_value;
	let current;
	let each_value = /*dates*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1$1(get_each_context$1$1(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", div_class_value = /*$theme*/ ctx[4].days);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*dates, chunks, longChunks, iChunks*/ 15) {
				each_value = /*dates*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (!current || dirty & /*$theme*/ 16 && div_class_value !== (div_class_value = /*$theme*/ ctx[4].days)) {
				attr(div, "class", div_class_value);
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$1$1($$self, $$props, $$invalidate) {
	let $hiddenDays;
	let $_iEvents;
	let $_events;
	let $theme;
	let { dates } = $$props;
	let { _events, _iEvents, hiddenDays, theme } = getContext('state');
	component_subscribe($$self, _events, value => $$invalidate(13, $_events = value));
	component_subscribe($$self, _iEvents, value => $$invalidate(12, $_iEvents = value));
	component_subscribe($$self, hiddenDays, value => $$invalidate(11, $hiddenDays = value));
	component_subscribe($$self, theme, value => $$invalidate(4, $theme = value));
	let chunks, longChunks, iChunks = [];
	let start;
	let end;

	$$self.$$set = $$props => {
		if ('dates' in $$props) $$invalidate(0, dates = $$props.dates);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*dates*/ 1) {
			{
				$$invalidate(9, start = dates[0]);
				$$invalidate(10, end = addDay(cloneDate(dates[dates.length - 1])));
			}
		}

		if ($$self.$$.dirty & /*$_events, start, end, chunks, $hiddenDays*/ 11778) {
			{
				$$invalidate(1, chunks = []);

				for (let event of $_events) {
					if (event.display !== 'background' && eventIntersects(event, start, end)) {
						let chunk = createEventChunk(event, start, end);
						chunks.push(chunk);
					}
				}

				$$invalidate(2, longChunks = prepareEventChunks(chunks, $hiddenDays));
			}
		}

		if ($$self.$$.dirty & /*$_iEvents, start, end, $hiddenDays*/ 7680) {
			$$invalidate(3, iChunks = $_iEvents.map(event => {
				let chunk;

				if (event && eventIntersects(event, start, end)) {
					chunk = createEventChunk(event, start, end);
					prepareEventChunks([chunk], $hiddenDays);
				} else {
					chunk = null;
				}

				return chunk;
			}));
		}
	};

	return [
		dates,
		chunks,
		longChunks,
		iChunks,
		$theme,
		_events,
		_iEvents,
		hiddenDays,
		theme,
		start,
		end,
		$hiddenDays,
		$_iEvents,
		$_events
	];
}

class Week extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1$1, create_fragment$1$1, safe_not_equal, { dates: 0 });
	}
}

/* packages/day-grid/src/View.svelte generated by Svelte v3.55.1 */

function get_each_context$5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[14] = list[i];
	return child_ctx;
}

// (37:0) {#each weeks as dates}
function create_each_block$5(ctx) {
	let week;
	let current;
	week = new Week({ props: { dates: /*dates*/ ctx[14] } });

	return {
		c() {
			create_component(week.$$.fragment);
		},
		m(target, anchor) {
			mount_component(week, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const week_changes = {};
			if (dirty & /*weeks*/ 1) week_changes.dates = /*dates*/ ctx[14];
			week.$set(week_changes);
		},
		i(local) {
			if (current) return;
			transition_in(week.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(week.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(week, detaching);
		}
	};
}

// (36:0) <Body>
function create_default_slot$1(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*weeks*/ ctx[0];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*weeks*/ 1) {
				each_value = /*weeks*/ ctx[0];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$5(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$5(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

function create_fragment$7(ctx) {
	let header;
	let t;
	let body;
	let current;
	header = new Header({});

	body = new Body$1({
			props: {
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(header.$$.fragment);
			t = space();
			create_component(body.$$.fragment);
		},
		m(target, anchor) {
			mount_component(header, target, anchor);
			insert(target, t, anchor);
			mount_component(body, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const body_changes = {};

			if (dirty & /*$$scope, weeks*/ 131073) {
				body_changes.$$scope = { dirty, ctx };
			}

			body.$set(body_changes);
		},
		i(local) {
			if (current) return;
			transition_in(header.$$.fragment, local);
			transition_in(body.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(header.$$.fragment, local);
			transition_out(body.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(header, detaching);
			if (detaching) detach(t);
			destroy_component(body, detaching);
		}
	};
}

function instance$7($$self, $$props, $$invalidate) {
	let $_viewDates;
	let $dayMaxEvents;
	let $_hiddenEvents;
	let $hiddenDays;
	let $_viewClass;
	let { _viewDates, _viewClass, dayMaxEvents, hiddenDays, theme } = getContext('state');
	component_subscribe($$self, _viewDates, value => $$invalidate(7, $_viewDates = value));
	component_subscribe($$self, _viewClass, value => $$invalidate(11, $_viewClass = value));
	component_subscribe($$self, dayMaxEvents, value => $$invalidate(8, $dayMaxEvents = value));
	component_subscribe($$self, hiddenDays, value => $$invalidate(9, $hiddenDays = value));
	let viewState = new State$1(getContext('state'));
	setContext('view-state', viewState);
	let { _hiddenEvents } = viewState;
	component_subscribe($$self, _hiddenEvents, value => $$invalidate(10, $_hiddenEvents = value));
	set_store_value(_viewClass, $_viewClass = 'month', $_viewClass);
	let weeks;
	let days;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$hiddenDays, $dayMaxEvents, $_viewDates, days, weeks*/ 961) {
			{
				$$invalidate(0, weeks = []);
				$$invalidate(6, days = 7 - $hiddenDays.length);
				set_store_value(_hiddenEvents, $_hiddenEvents = {}, $_hiddenEvents);

				for (let i = 0; i < $_viewDates.length / days; ++i) {
					let dates = [];

					for (let j = 0; j < days; ++j) {
						dates.push($_viewDates[i * days + j]);
					}

					weeks.push(dates);
				}
			}
		}
	};

	return [
		weeks,
		_viewDates,
		_viewClass,
		dayMaxEvents,
		hiddenDays,
		_hiddenEvents,
		days,
		$_viewDates,
		$dayMaxEvents,
		$hiddenDays
	];
}

class View$1 extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});
	}
}

var index$1 = {
	createOptions(options) {
		options.dayMaxEvents = false;
		options.dayPopoverFormat = {month: 'long', day: 'numeric', year: 'numeric'};
		options.moreLinkContent = undefined;
		// Common options
		options.buttonText.dayGridMonth = 'month';
		options.theme.uniform = 'ec-uniform';
		options.theme.dayFoot = 'ec-day-foot';
		options.theme.month = 'ec-month';
		options.theme.popup = 'ec-popup';
		options.view = 'dayGridMonth';
		options.views.dayGridMonth = {
			component: View$1,
			dayHeaderFormat: {weekday: 'short'},
			displayEventEnd: false,
			duration: {months: 1},
			monthMode: true,
			titleFormat: {year: 'numeric', month: 'long'}
		};
	},

	createStores(state) {
		state._intlDayPopover = intl(state.locale, state.dayPopoverFormat);
	}
};

/* packages/list/src/Body.svelte generated by Svelte v3.55.1 */

function create_fragment$3(ctx) {
	let div1;
	let div0;
	let div0_class_value;
	let div1_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			attr(div0, "class", div0_class_value = /*$theme*/ ctx[0].content);
			attr(div1, "class", div1_class_value = /*$theme*/ ctx[0].body);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*$theme*/ 1 && div0_class_value !== (div0_class_value = /*$theme*/ ctx[0].content)) {
				attr(div0, "class", div0_class_value);
			}

			if (!current || dirty & /*$theme*/ 1 && div1_class_value !== (div1_class_value = /*$theme*/ ctx[0].body)) {
				attr(div1, "class", div1_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let $theme;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { theme } = getContext('state');
	component_subscribe($$self, theme, value => $$invalidate(0, $theme = value));

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [$theme, theme, $$scope, slots];
}

class Body extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});
	}
}

/* packages/list/src/Event.svelte generated by Svelte v3.55.1 */

function create_fragment$2(ctx) {
	let div2;
	let div0;
	let div0_class_value;
	let t;
	let div1;
	let div1_class_value;
	let setContent_action;
	let div2_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			div2 = element("div");
			div0 = element("div");
			t = space();
			div1 = element("div");
			attr(div0, "class", div0_class_value = /*$theme*/ ctx[0].eventTag);
			attr(div0, "style", /*style*/ ctx[2]);
			attr(div1, "class", div1_class_value = /*$theme*/ ctx[0].eventBody);
			attr(div2, "class", div2_class_value = /*$theme*/ ctx[0].event);
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div0);
			append(div2, t);
			append(div2, div1);
			/*div2_binding*/ ctx[29](div2);

			if (!mounted) {
				dispose = [
					action_destroyer(setContent_action = setContent$1.call(null, div1, /*content*/ ctx[3])),
					listen(div2, "click", function () {
						if (is_function(/*createHandler*/ ctx[19](/*$eventClick*/ ctx[4]))) /*createHandler*/ ctx[19](/*$eventClick*/ ctx[4]).apply(this, arguments);
					}),
					listen(div2, "mouseenter", function () {
						if (is_function(/*createHandler*/ ctx[19](/*$eventMouseEnter*/ ctx[5]))) /*createHandler*/ ctx[19](/*$eventMouseEnter*/ ctx[5]).apply(this, arguments);
					}),
					listen(div2, "mouseleave", function () {
						if (is_function(/*createHandler*/ ctx[19](/*$eventMouseLeave*/ ctx[6]))) /*createHandler*/ ctx[19](/*$eventMouseLeave*/ ctx[6]).apply(this, arguments);
					})
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*$theme*/ 1 && div0_class_value !== (div0_class_value = /*$theme*/ ctx[0].eventTag)) {
				attr(div0, "class", div0_class_value);
			}

			if (dirty[0] & /*style*/ 4) {
				attr(div0, "style", /*style*/ ctx[2]);
			}

			if (dirty[0] & /*$theme*/ 1 && div1_class_value !== (div1_class_value = /*$theme*/ ctx[0].eventBody)) {
				attr(div1, "class", div1_class_value);
			}

			if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*content*/ 8) setContent_action.update.call(null, /*content*/ ctx[3]);

			if (dirty[0] & /*$theme*/ 1 && div2_class_value !== (div2_class_value = /*$theme*/ ctx[0].event)) {
				attr(div2, "class", div2_class_value);
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div2);
			/*div2_binding*/ ctx[29](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let $_view;
	let $eventDidMount;
	let $_intlEventTime;
	let $theme;
	let $eventContent;
	let $displayEventEnd;
	let $eventColor;
	let $eventBackgroundColor;
	let $_resBgColor;
	let $eventClick;
	let $eventMouseEnter;
	let $eventMouseLeave;
	let { chunk } = $$props;
	let { displayEventEnd, eventBackgroundColor, eventColor, eventContent, eventClick, eventDidMount, eventMouseEnter, eventMouseLeave, theme, _view, _intlEventTime, _resBgColor } = getContext('state');
	component_subscribe($$self, displayEventEnd, value => $$invalidate(25, $displayEventEnd = value));
	component_subscribe($$self, eventBackgroundColor, value => $$invalidate(27, $eventBackgroundColor = value));
	component_subscribe($$self, eventColor, value => $$invalidate(26, $eventColor = value));
	component_subscribe($$self, eventContent, value => $$invalidate(24, $eventContent = value));
	component_subscribe($$self, eventClick, value => $$invalidate(4, $eventClick = value));
	component_subscribe($$self, eventDidMount, value => $$invalidate(31, $eventDidMount = value));
	component_subscribe($$self, eventMouseEnter, value => $$invalidate(5, $eventMouseEnter = value));
	component_subscribe($$self, eventMouseLeave, value => $$invalidate(6, $eventMouseLeave = value));
	component_subscribe($$self, theme, value => $$invalidate(0, $theme = value));
	component_subscribe($$self, _view, value => $$invalidate(22, $_view = value));
	component_subscribe($$self, _intlEventTime, value => $$invalidate(23, $_intlEventTime = value));
	component_subscribe($$self, _resBgColor, value => $$invalidate(28, $_resBgColor = value));
	let el;
	let event;
	let style;
	let content;
	let timeText;

	onMount(() => {
		if (is_function($eventDidMount)) {
			$eventDidMount({
				event: toEventWithLocalDates(event),
				timeText,
				el,
				view: toViewWithLocalDates($_view)
			});
		}
	});

	function createHandler(fn) {
		return jsEvent => {
			if (is_function(fn)) {
				fn({
					event: toEventWithLocalDates(event),
					el,
					jsEvent,
					view: toViewWithLocalDates($_view)
				});
			}
		};
	}

	function div2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(1, el);
		});
	}

	$$self.$$set = $$props => {
		if ('chunk' in $$props) $$invalidate(20, chunk = $$props.chunk);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*chunk*/ 1048576) {
			$$invalidate(21, event = chunk.event);
		}

		if ($$self.$$.dirty[0] & /*event, $_resBgColor, $eventBackgroundColor, $eventColor*/ 471859200) {
			{
				// Class & Style
				let bgColor = event.backgroundColor || $_resBgColor(event) || $eventBackgroundColor || $eventColor;

				if (bgColor) {
					$$invalidate(2, style = `background-color:${bgColor};`);
				}
			}
		}

		if ($$self.$$.dirty[0] & /*chunk, $displayEventEnd, $eventContent, $theme, $_intlEventTime, $_view*/ 63963137) {
			{
				// Content
				$$invalidate(3, [timeText, content] = createEventContent(chunk, $displayEventEnd, $eventContent, $theme, $_intlEventTime, $_view), content);
			}
		}
	};

	return [
		$theme,
		el,
		style,
		content,
		$eventClick,
		$eventMouseEnter,
		$eventMouseLeave,
		displayEventEnd,
		eventBackgroundColor,
		eventColor,
		eventContent,
		eventClick,
		eventDidMount,
		eventMouseEnter,
		eventMouseLeave,
		theme,
		_view,
		_intlEventTime,
		_resBgColor,
		createHandler,
		chunk,
		event,
		$_view,
		$_intlEventTime,
		$eventContent,
		$displayEventEnd,
		$eventColor,
		$eventBackgroundColor,
		$_resBgColor,
		div2_binding
	];
}

class Event$1 extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { chunk: 20 }, null, [-1, -1]);
	}
}

/* packages/list/src/Day.svelte generated by Svelte v3.55.1 */

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[24] = list[i];
	return child_ctx;
}

// (68:0) {#if chunks.length}
function create_if_block$1(ctx) {
	let div;
	let t0_value = /*$_intlListDayFormat*/ ctx[7].format(/*date*/ ctx[0]) + "";
	let t0;
	let t1;
	let span;
	let t2_value = /*$_intlListDaySideFormat*/ ctx[8].format(/*date*/ ctx[0]) + "";
	let t2;
	let span_class_value;
	let div_class_value;
	let t3;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let current;
	let mounted;
	let dispose;
	let each_value = /*chunks*/ ctx[2];
	const get_key = ctx => /*chunk*/ ctx[24].event;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$1(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
	}

	return {
		c() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text(t2_value);
			t3 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
			attr(span, "class", span_class_value = /*$theme*/ ctx[5].daySide);

			attr(div, "class", div_class_value = "" + (/*$theme*/ ctx[5].day + (/*isToday*/ ctx[3] ? ' ' + /*$theme*/ ctx[5].today : '') + (/*highlight*/ ctx[4]
			? ' ' + /*$theme*/ ctx[5].highlight
			: '')));
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t0);
			append(div, t1);
			append(div, span);
			append(span, t2);
			/*div_binding*/ ctx[19](div);
			insert(target, t3, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(div, "click", function () {
					if (is_function(/*createClickHandler*/ ctx[16](/*$dateClick*/ ctx[6]))) /*createClickHandler*/ ctx[16](/*$dateClick*/ ctx[6]).apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty & /*$_intlListDayFormat, date*/ 129) && t0_value !== (t0_value = /*$_intlListDayFormat*/ ctx[7].format(/*date*/ ctx[0]) + "")) set_data(t0, t0_value);
			if ((!current || dirty & /*$_intlListDaySideFormat, date*/ 257) && t2_value !== (t2_value = /*$_intlListDaySideFormat*/ ctx[8].format(/*date*/ ctx[0]) + "")) set_data(t2, t2_value);

			if (!current || dirty & /*$theme*/ 32 && span_class_value !== (span_class_value = /*$theme*/ ctx[5].daySide)) {
				attr(span, "class", span_class_value);
			}

			if (!current || dirty & /*$theme, isToday, highlight*/ 56 && div_class_value !== (div_class_value = "" + (/*$theme*/ ctx[5].day + (/*isToday*/ ctx[3] ? ' ' + /*$theme*/ ctx[5].today : '') + (/*highlight*/ ctx[4]
			? ' ' + /*$theme*/ ctx[5].highlight
			: '')))) {
				attr(div, "class", div_class_value);
			}

			if (dirty & /*chunks*/ 4) {
				each_value = /*chunks*/ ctx[2];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$1, each_1_anchor, get_each_context$1);
				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			/*div_binding*/ ctx[19](null);
			if (detaching) detach(t3);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}

			if (detaching) detach(each_1_anchor);
			mounted = false;
			dispose();
		}
	};
}

// (77:4) {#each chunks as chunk (chunk.event)}
function create_each_block$1(key_1, ctx) {
	let first;
	let event;
	let current;
	event = new Event$1({ props: { chunk: /*chunk*/ ctx[24] } });

	return {
		key: key_1,
		first: null,
		c() {
			first = empty();
			create_component(event.$$.fragment);
			this.first = first;
		},
		m(target, anchor) {
			insert(target, first, anchor);
			mount_component(event, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const event_changes = {};
			if (dirty & /*chunks*/ 4) event_changes.chunk = /*chunk*/ ctx[24];
			event.$set(event_changes);
		},
		i(local) {
			if (current) return;
			transition_in(event.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(event.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(first);
			destroy_component(event, detaching);
		}
	};
}

function create_fragment$1(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*chunks*/ ctx[2].length && create_if_block$1(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*chunks*/ ctx[2].length) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*chunks*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let $_view;
	let $highlightedDates;
	let $_events;
	let $theme;
	let $dateClick;
	let $_intlListDayFormat;
	let $_intlListDaySideFormat;
	let { date } = $$props;
	let { _events, _intlDayHeader, _view, date: currentDate, dateClick, highlightedDates, theme } = getContext('state');
	component_subscribe($$self, _events, value => $$invalidate(18, $_events = value));
	component_subscribe($$self, _view, value => $$invalidate(20, $_view = value));
	component_subscribe($$self, dateClick, value => $$invalidate(6, $dateClick = value));
	component_subscribe($$self, highlightedDates, value => $$invalidate(17, $highlightedDates = value));
	component_subscribe($$self, theme, value => $$invalidate(5, $theme = value));
	let { _intlListDayFormat, _intlListDaySideFormat } = getContext('view-state');
	component_subscribe($$self, _intlListDayFormat, value => $$invalidate(7, $_intlListDayFormat = value));
	component_subscribe($$self, _intlListDaySideFormat, value => $$invalidate(8, $_intlListDaySideFormat = value));
	let el;
	let chunks;
	let today = setMidnight(createDate()), isToday, highlight;

	function createClickHandler(fn) {
		return is_function(fn)
		? jsEvent => {
				fn({
					allDay: true,
					date: toLocalDate$1(date),
					dateStr: toISOString(date),
					dayEl: el,
					jsEvent,
					view: toViewWithLocalDates($_view)
				});
			}
		: undefined;
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(1, el);
		});
	}

	$$self.$$set = $$props => {
		if ('date' in $$props) $$invalidate(0, date = $$props.date);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*date, $_events, chunks*/ 262149) {
			{
				$$invalidate(2, chunks = []);
				let start = date;
				let end = addDay(cloneDate(date));

				for (let event of $_events) {
					if (event.display === 'auto' && eventIntersects(event, start, end)) {
						let chunk = createEventChunk(event, start, end);
						chunks.push(chunk);
					}
				}

				sortEventChunks(chunks);
			}
		}

		if ($$self.$$.dirty & /*date, $highlightedDates*/ 131073) {
			{
				$$invalidate(3, isToday = datesEqual(date, today));
				$$invalidate(4, highlight = $highlightedDates.some(d => datesEqual(d, date)));
			}
		}

		if ($$self.$$.dirty & /*el, date*/ 3) {
			// dateFromPoint
			if (el) {
				setFn(el, () => date);
			}
		}
	};

	return [
		date,
		el,
		chunks,
		isToday,
		highlight,
		$theme,
		$dateClick,
		$_intlListDayFormat,
		$_intlListDaySideFormat,
		_events,
		_view,
		dateClick,
		highlightedDates,
		theme,
		_intlListDayFormat,
		_intlListDaySideFormat,
		createClickHandler,
		$highlightedDates,
		$_events,
		div_binding
	];
}

class Day extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { date: 0 });
	}
}

class State {
    constructor(state) {
        this._intlListDayFormat = intl(state.locale, state.listDayFormat);
        this._intlListDaySideFormat = intl(state.locale, state.listDaySideFormat);
    }
}

/* packages/list/src/View.svelte generated by Svelte v3.55.1 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[18] = list[i];
	return child_ctx;
}

// (49:0) {:else}
function create_else_block(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*$_viewDates*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*$_viewDates*/ 2) {
				each_value = /*$_viewDates*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (47:0) {#if noEvents}
function create_if_block(ctx) {
	let div;
	let div_class_value;
	let setContent_action;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			attr(div, "class", div_class_value = /*$theme*/ ctx[3].noEvents);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (!mounted) {
				dispose = [
					action_destroyer(setContent_action = setContent$1.call(null, div, /*content*/ ctx[0])),
					listen(div, "click", /*handleClick*/ ctx[11])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*$theme*/ 8 && div_class_value !== (div_class_value = /*$theme*/ ctx[3].noEvents)) {
				attr(div, "class", div_class_value);
			}

			if (setContent_action && is_function(setContent_action.update) && dirty & /*content*/ 1) setContent_action.update.call(null, /*content*/ ctx[0]);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (50:4) {#each $_viewDates as date}
function create_each_block(ctx) {
	let day;
	let current;
	day = new Day({ props: { date: /*date*/ ctx[18] } });

	return {
		c() {
			create_component(day.$$.fragment);
		},
		m(target, anchor) {
			mount_component(day, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const day_changes = {};
			if (dirty & /*$_viewDates*/ 2) day_changes.date = /*date*/ ctx[18];
			day.$set(day_changes);
		},
		i(local) {
			if (current) return;
			transition_in(day.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(day.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(day, detaching);
		}
	};
}

// (46:0) <Body>
function create_default_slot(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*noEvents*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment(ctx) {
	let body;
	let current;

	body = new Body({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(body.$$.fragment);
		},
		m(target, anchor) {
			mount_component(body, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const body_changes = {};

			if (dirty & /*$$scope, $theme, content, noEvents, $_viewDates*/ 2097167) {
				body_changes.$$scope = { dirty, ctx };
			}

			body.$set(body_changes);
		},
		i(local) {
			if (current) return;
			transition_in(body.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(body.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(body, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $_view;
	let $noEventsClick;
	let $noEventsContent;
	let $_events;
	let $_viewDates;
	let $_viewClass;
	let $theme;
	let { _events, _view, _viewDates, _viewClass, noEventsClick, noEventsContent, theme } = getContext('state');
	component_subscribe($$self, _events, value => $$invalidate(13, $_events = value));
	component_subscribe($$self, _view, value => $$invalidate(14, $_view = value));
	component_subscribe($$self, _viewDates, value => $$invalidate(1, $_viewDates = value));
	component_subscribe($$self, _viewClass, value => $$invalidate(16, $_viewClass = value));
	component_subscribe($$self, noEventsClick, value => $$invalidate(15, $noEventsClick = value));
	component_subscribe($$self, noEventsContent, value => $$invalidate(12, $noEventsContent = value));
	component_subscribe($$self, theme, value => $$invalidate(3, $theme = value));
	let state = new State(getContext('state'));
	setContext('view-state', state);
	set_store_value(_viewClass, $_viewClass = 'list', $_viewClass);
	let noEvents, content;

	function handleClick(jsEvent) {
		if (is_function($noEventsClick)) {
			$noEventsClick({
				jsEvent,
				view: toViewWithLocalDates($_view)
			});
		}
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$_viewDates, $_events*/ 8194) {
			{
				$$invalidate(2, noEvents = true);

				if ($_viewDates.length) {
					let start = $_viewDates[0];
					let end = addDay(cloneDate($_viewDates[$_viewDates.length - 1]));

					for (let event of $_events) {
						if (event.display === 'auto' && event.start < end && event.end > start) {
							$$invalidate(2, noEvents = false);
							break;
						}
					}
				}
			}
		}

		if ($$self.$$.dirty & /*$noEventsContent, content*/ 4097) {
			{
				$$invalidate(0, content = is_function($noEventsContent)
				? $noEventsContent()
				: $noEventsContent);

				if (typeof content === 'string') {
					$$invalidate(0, content = { html: content });
				}
			}
		}
	};

	return [
		content,
		$_viewDates,
		noEvents,
		$theme,
		_events,
		_view,
		_viewDates,
		_viewClass,
		noEventsClick,
		noEventsContent,
		theme,
		handleClick,
		$noEventsContent,
		$_events
	];
}

class View extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

var index = {
	createOptions(options) {
		// Common options
		options.buttonText.listDay = 'list';
		options.buttonText.listWeek = 'list';
		options.buttonText.listMonth = 'list';
		options.buttonText.listYear = 'list';
		options.listDayFormat = {weekday: 'long'};
		options.listDaySideFormat = {year: 'numeric', month: 'long', day: 'numeric'};
		options.noEventsClick = undefined;  // ec option
		options.noEventsContent = 'No events';
		options.theme.daySide = 'ec-day-side';
		options.theme.eventTag = 'ec-event-tag';
		options.theme.list = 'ec-list';
		options.theme.noEvents = 'ec-no-events';
		options.view = 'listWeek';
		options.views.listDay = {
			component: View,
			duration: {days: 1}
		};
		options.views.listWeek = {
			component: View,
			duration: {weeks: 1}
		};
		options.views.listMonth = {
			component: View,
			duration: {months: 1}
		};
		options.views.listYear = {
			component: View,
			duration: {years: 1}
		};
	}
};

const Calendar = (props) => {
    const {
        class: className,
        initialView,
        locale,
        firstDay,
        height,
        headerToolbar,
        buttonText,
        scrollTime,
        views,
        nowIndicator,
        ...rest
    } = props ?? {};
    const element = html`<div class="calendar ${className ?? ""}"></div>`;
    let calendar = null;

    observe(element);
    element.addEventListener("connected", initializeCalendar);

    function initializeCalendar() {
        calendar = new Calendar$1({
            target: element,
            props: {
                plugins: [
                    index$4,
                    index$3,
                    index$2,
                    index$1,
                    index,
                ],
                options: {
                    ...rest,
                    view: initialView || "timeGridWeek",
                    height: height || "100%",
                    headerToolbar: {
                        start: "prev,next today",
                        center: "title",
                        end: "dayGridMonth,timeGridWeek,timeGridDay,listWeek",
                        ...(headerToolbar ?? {}),
                    },
                    locale: locale || "ru",
                    firstDay: firstDay ?? 1,
                    buttonText: (texts) => ({
                        ...texts,
                        ...LOCALE,
                        ...(buttonText ?? {}),
                    }),
                    scrollTime: scrollTime ?? Date.now(),
                    views: {
                        ...views,
                        timeGridWeek: {
                            ...{ pointer: true },
                            ...(views?.timeGridWeek ?? {}),
                        },
                        resourceTimeGridWeek: {
                            ...{ pointer: true },
                            ...(views?.resourceTimeGridWeek ?? {}),
                        },
                    },
                    nowIndicator: nowIndicator ?? true,
                },
            },
        });
    }

    element.setOption = (key, data) => calendar?.setOption?.(key, data);
    element.getOption = (key) => calendar?.getOption?.(key);
    element.getResources = () => calendar?.getOption("resources");
    element.getEvents = () => calendar?.getEvents();

    element.setEvents = (events = []) => {
        calendar.setOption("events", events);
    };

    element.setResources = (resources = []) => {
        calendar.setOption("resources", resources);
    };

    element.addEvent = (event) => {
        calendar.addEvent(event);
    };
    element.updateEvent = (event) => {
        calendar.updateEvent(event);
    };
    element.unselect = () => calendar.unselect();
    element.refetchEvents = () => calendar.refetchEvents();

    return element;
};

const LOCALE = {
    dayGridMonth: "Месяц",
    timeGridWeek: "Неделя",
    timeGridDay: "День",
    listWeek: "Agenda",
    resourceTimeGridDay: "Ресурсы",
    today: "Сегодня",
};

const PROJECT_KEY = "project";

const getUserProject = () => {
    const projectId = Number(localStorage.getItem(PROJECT_KEY));
    if (isNaN(projectId)) return 0;
    return projectId;
};

const MeetingsView = () => {
    const modal = Modal();
    const loader = Loader();
    const calendar = Calendar({
        allDaySlot: false,
        selectable: true,
        select: createNewMeeting,
        editable: false,
        eventDurationEditable: false,
        eventStartEditable: true,
        locale: "ru",
        slotHeight: 34,
        // slotDuration: "0:15:00",
        slotMinTime: "8:00",
        slotMaxTime: "20:00",
        // datesSet: fetchMeetings,
        eventSources: [
            {
                events: fetchMeetings,
            },
        ],
        eventClick: openMeeting,
        eventDrop: updateMeeting,
        buttonText: {
            listMonth: "Список",
        },
        initialView: "timeGridWeek",
        dateClick: openView,
        eventDidMount: handleEventDidMount,
        loading: (isLoading) => {
            loader[isLoading ? "show" : "hide"]();
        },
        flexibleSlotTimeLimits: true,
        headerToolbar: {
            end: "dayGridMonth,timeGridWeek,timeGridDay,listMonth",
        },
        // resources: [{ id: "0", eventBackgroundColor: COLORS[0], title: "0" }],
        views: {
            timeGridWeek: {
                hiddenDays: [0, 6],
            },
            listMonth: {
                eventContent: ListEventContent,
                viewDidMount: handleListDidMount,
            },
        },
        listDayFormat: (date) => {
            const dateTime = DateTime.fromJSDate(date);
            return dateTime.setLocale("ru").toFormat("dd MMMM yyyy, EEEE");
        },
        listDaySideFormat: () => "",
    });
    const contextMenu = o();
    const currentUser = { docid: getUserId(), Name: getUserName() };
    const state = {
        user: o(currentUser),
        project: o({
            docid: getUserProject() > 0 ? getUserProject() : undefined,
        }),
        integerRoles: o([]),
    };

    const statuses = [];
    statuses.isEmpty = function () {
        return this.length === 0;
    };

    const userField = Field({
        reference: CardFileEmployee,
        value: state.user,
        title: "Пользователь",
        onChange: onFilterChange,
        key: "user",
        width: 300,
        isHierarchycal: false,
        initTree: false,
        constFilter: ()=>{
            if (getCurrentRole()!=1 && getCurrentRole()!=7)
               return "docid = "+getUserId()+" or GroupDoc is {BaseInt.Справочники.Persona:"+getUserId()+"}"
        },
    });

    function renderFilters() {
        return html`${userField}`;
    }

    const view = html`<div class="meetings-view">
        <div class="meetings-filters">
            ${renderFilters}
            <${Button} onClick=${navigateToCardFile}> Показать все <//>
        </div>
        ${calendar} ${contextMenu}
    </div>`;

    observe(view);

    view.addEventListener("connected", onConnected);

    function createNewMeeting(event) {
        const data = eventToMeeting(event);

        openMeetingsBlank(data);

        calendar.unselect();
    }

    function openMeetingsBlank(data) {
        const newMeeting = !data.docid;

        data.saveRecord = ()=>{
            blank.saveData(false,true);
        };

        const blank = BlankActivity(data, data.docid);

        blank.cancelButtonAction = () => modal.hide();

        blank.saveData = async (hide = true, refreshData = true) => {
            if (!blank.isValid()) return;
            const blankData = blank.getData();

            loader.show();

            const result = await createOrUpdateRecord(
                settings.targetClass,
                blankData
            );

            if (!result.isOk) {
                console.error(result.data ?? result.error);
                loader.hide();
                return;
            } else if (!blankData.docid) {
                const docid = result.data?.docid ?? result.data?.body?.docid;
                if (docid) {
                    blankData.docid = docid;
                }
            }

            if (newMeeting) {
                await createEvent(blankData);
            } else {
                await updateEvent(blankData);
            }

            if (hide) {
                modal.hide();
            } else if (blankData.docid && refreshData) {
                await blank.refreshData(blankData.docid);
            }
            loader.hide();
        };

        blank.applyButtonAction = () => {
            blank.saveData();
        };

        blank.saveButtonAction = () => {
            blank.saveData(false,true);
        };

        blank.refreshData = async (docid) => {
            const result = await getRecord$1(settings.targetClass, docid);
            if (!(result instanceof Error)) {
                openMeetingsBlank(result);
                updateEvent(result);
            }
        };

        modal.setContent(blank);
        modal.show();
    }

    async function fetchMeetings({ start, end }) {
        start = DateTime.fromJSDate(start).toFormat(defaultFormats.DATE_TIME);
        end = DateTime.fromJSDate(end).toFormat(defaultFormats.DATE_TIME);
        if (statuses.isEmpty()) {
            const results = await Promise.all(
                //НЕОБХОДИМЫЕ СТАТУСЫ
                [1, 2, 3].map((id) => getRecord$1("BaseInt.Status", id))
            );
            statuses.push(...results);
        }
        const result = await getVisitsForCalendar({
            DOB: start,
            DOE: end,
            userId: state.user()?.docid,
            userRole: getCurrentRole(),
        });        

        const getTitle = (meeting)=>{
            let res = "";
            if (meeting.VisitType != "")
                res+='<div class="event-row">'+meeting.VisitType+'</div>';
            if (meeting.Точка != "")
                res+='<div class="event-row">'+meeting.Точка+'</div>';
            if (meeting.Адрес != "")
                res+='<div class="event-row">'+meeting.Адрес+'</div>';                        
            if (meeting.existsFile)
                res+='<div class="event-file"><i class="icon2 icon-file" style="font-size: 16px;"></i></div>';           
            return res;
        };

        if (result.isOk) {
            return result.data.Meeting?.map((meeting) =>  ({
                ...meeting,
                id: meeting.id,
                titleHTML: getTitle(meeting),
                backgroundColor:
                    meeting.backgroundColor != null &&
                    meeting.backgroundColor !== ""
                        ? turboColorToHtml(meeting.backgroundColor)
                        : "var(--color-main)",
                start: DateTime.fromFormat(
                    meeting.start ?? meeting.Start,
                    defaultFormats.DATE_TIME
                ).toJSDate(),
                end: DateTime.fromFormat(
                    meeting.end ?? meeting.End,
                    defaultFormats.DATE_TIME
                ).toJSDate(),
            }));
        }
        return [];
    }

    async function createEvent(meeting) {
        const meetingEvent = await meetingToEvent({ meeting, statuses });
        calendar.addEvent(meetingEvent);
    }

    async function updateEvent(meeting) {        
        const meetingEvent = await meetingToEvent({ meeting, statuses });
        calendar.updateEvent(meetingEvent);
    }

    async function openMeeting({ event }) {
        const docid = Number(event.id);
        const result = await getRecord$1(settings.targetClass, docid);
        if (!(result instanceof Error)) {
            openMeetingsBlank(result);
        }
    }

    async function updateMeeting({ event, oldEvent }) {
        const result = await createOrUpdateRecord(
            settings.targetClass,
            eventToMeeting(event)
        );
        if (result.isOk) {
            return;
        }
        calendar.updateEvent(oldEvent);
    }

    function openView({ view, date }) {
        switch (view.type) {
            case "dayGridMonth": {
                calendar.setOption("date", date);
                calendar.setOption("view", "timeGridWeek");
                break;
            }
            case "timeGridWeek":
            case "listWeek": {
                calendar.setOption("date", date);
                calendar.setOption("view", "timeGridDay");
            }
        }
    }

    function handleEventDidMount(props) {
        calcEventRowsCount(props);
    }
    /**
     *
     * @param {{el: HTMLDivElement}} param0
     * @returns
     */
    function calcEventRowsCount({ el, event, view, ...rest }) {
        if (event.id === "{pointer}") {
            return;
        }
        if (view.type !== "timeGridWeek" && view.type !== "timeGridDay") {
            return;
        }
        const style = getComputedStyle(el);
        /**
         *
         * @param {string} pxString
         * @returns
         */
        const pxToNumber = (pxString) => {
            return Number(pxString.slice(0, -2));
        };
        const lineHeight = pxToNumber(style.lineHeight);
        const height = pxToNumber(style.height);

        el.style.setProperty(
            "--max-lines",
            Math.trunc(height / lineHeight) || 1
        );
    }

    function handleListDidMount(info) {
        addContextMenuToListView();
    }

    function addContextMenuToListView() {
        const calendarBody = qs(".ec-list>.ec-body", calendar);
        if (!calendarBody) return;
        calendarBody.addEventListener("contextmenu", onContextMenuInListView);
    }

    /**
     *
     * @param {MouseEvent} ev
     */
    function onContextMenuInListView(ev) {
        ev.preventDefault();
        console.log(ev.target);

        const handleMouseDown = () => {
            const dateTime = DateTime.now()
                .setLocale("ru")
                .startOf("hour")
                .plus({ hour: 1 });
            const start = dateTime.toJSDate();
            const end = dateTime.plus({ minutes: 30 }).toJSDate();
            const meeting = eventToMeeting({ start, end });
            openMeetingsBlank(meeting);
        };

        const menu = html`<${ContextMenu}>
            <${ContextMenuItem} onMouseDown=${handleMouseDown}>
                Завести встречу
            <//>
        <//>`;
        const computedStyle = getComputedStyle(menu);

        document.body.addEventListener("mousedown", () => contextMenu(null), {
            once: true,
        });
        document.addEventListener(
            "keyup",
            (ev) => {
                if (ev.key !== "Esc" && ev.key !== "Escape") {
                    return;
                }
                if (!contextMenu()) {
                    return;
                }
                contextMenu(null);
            },
            { once: true }
        );

        contextMenu(menu);

        const width = Number(computedStyle.width.slice(0, -2));
        Object.assign(menu.style, {
            top: ev.clientY + "px",
            left: ev.clientX - width / 2 + "px",
        });
    }

    async function onConnected() {
        const [userResult, userProjectResult, integerRolesResult] =
            await Promise.all([
                getRecord$1(
                    CardFileEmployee.settings.targetClass,
                    state.user().docid
                ),
                getHierarchyLevel({
                    targetClass: "Kernel.Settings.Role",
                    id: 7,
                    isHierarchycal: true,
                    start: 1,
                }),
            ]);
        if (!(userResult instanceof Error)) {
            state.user(userResult);
        }
    }

    async function onFilterChange({ key, value }) {
        state[key](value);
        calendar.refetchEvents();
    }
    function navigateToCardFile() {
        navigate("#cardfile/activity");
    }
    return view;
};

const settings = {
    targetClass: "C4C.Документы.Активность",
};

async function meetingToEvent({ meeting, statuses }) {
    const startDate = DateTime.fromFormat(
        meeting["ДатаПлан"],
        defaultFormats.DATE_TIME
    );
    const status = meeting.Status?.docid;
    let backgroundColor;
    if (status==12)
        backgroundColor = turboColorToHtml(3843898);
    else
    {
        const eventDate = new Date(dateToJs(meeting["ДатаПлан"].replace(" ",":")));
        const curDate = new Date();
        if (eventDate<curDate)
            backgroundColor = turboColorToHtml(4474047);
        else
            backgroundColor = turboColorToHtml(16741186);
    }

    const getTitle = async (meeting)=>{
        let existsFile = "";
        const files = await getFilesList({docid: meeting.docid, targetClass:"C4C.Документы.Активность"});
        if (files.data.data?.length > 0)                   
            existsFile= "Есть вложения";                
        const locType = await getRecord$1("C4C.Справочники.ТипАктивности",meeting.ТипАктивности.docid);
        const locPoint = await getRecord$1("C4C.Справочники.Account",meeting.Точка.docid);
        let res = "";
        if (locType.Name != "")
            res+='<div class="event-row">'+locType.Name+'</div>';
        if (locPoint.Name != "")
            res+='<div class="event-row">'+locPoint.Name+'</div>';
        if (meeting.Адрес != "")
            res+='<div class="event-row">'+meeting.Адрес+'</div>';                        
        if (existsFile)
            res+='<div class="event-file"><i class="icon2 icon-file" style="font-size: 16px;"></i></div>';           
        return res;
    };

    const event = {
        id: meeting.docid,
        titleHTML: await getTitle(meeting),
        start: startDate.toJSDate(),
        end: startDate.plus({ hours: meeting["ДлительностьПлан"] }).toJSDate(),
        backgroundColor: backgroundColor,
    };
    return event;
}

function eventToMeeting(event) {
    const start = DateTime.fromJSDate(event.start);
    const end = DateTime.fromJSDate(event.end);
    const docid = event.id ? Number(event.id) : null;
    const meeting = {
        docid: isNaN(docid) || docid == 0 || docid == null ? undefined : docid,
        //ДатаПроведения: start.toFormat(DATE_FORMATS.DATE_TIME),
        ДатаПлан: start.toFormat(defaultFormats.DATE_TIME),
        ДлительностьПлан: end.diff(start).as("hours"),
    };
    return meeting;
}

const ListEventContent = ({ event, timeText }) => {
    const { extendedProps } = event;
    const participants = o(extendedProps?.Members ?? []);
    const element = html`<div
        style="display: flex; justify-content: space-between"
    >
        <div style="flex-grow: 1">
            <${ListEventTitle} event=${event} time=${timeText} />
            <div>${event.title}</div>
        </div>
        <div style="width: 50%; overflow: hidden; display: flex;">
            <${MeetingParticipantsList} participants=${participants} />
        </div>
    </div>`;
    return { domNodes: [element] };
};

const ListEventTitle = ({ event, time }) => {
    const { extendedProps } = event;
    const {
        ProjectName: project,
        Tickets: totalTasks,
        OpenTickets: openTasks,
    } = extendedProps;
    return html`<div
        style="font-weight: bold; display: grid; grid-template-columns: 1fr 1fr"
    >
        <span style="font: inherit">
            ${time}${project ? `, ${project}` : null}
        </span>
        ${totalTasks > 0
            ? html`<span style="font: inherit">
                  <span title="Всего задач" style="font: inherit">
                      ${totalTasks}
                  </span>
                  ${" / "}
                  <span
                      title="Открыто задач"
                      style="font: inherit;color: var(--color-main)"
                  >
                      ${openTasks}
                  </span>
              </span>`
            : null}
    </div>`;
};

const MeetingParticipantsList = ({ participants }) => {
    let count = 0;
    const limit = o(4);
    const hiddenParticipants = o([]);
    const element = html`<${List}
        class="horizontal participants-list"
        style="gap: 0.5em; margin-left: auto;"
    >
        ${() =>
            map(participants, (p) => {
                if (count < limit()) {
                    count++;
                    return html`<${MeetingParticipantItem}>${p.Name}<//>`;
                } else {
                    hiddenParticipants([...hiddenParticipants(), p]);
                }
            })}
        <${AdditionalParticipants} participants=${hiddenParticipants} />
    <//>`;
    element.setLimit = (l) => limit(l);
    return element;
};

const AdditionalParticipants = ({ participants }) => {
    if (participants().length === 0) return null;
    const element = html`<${MeetingParticipantItem}
        style="position: relative"
        class="participants-counter"
    >
        +${participants().length}
    <//>`;
    return element;
};

const MeetingParticipantItem = (props, ...content) => {
    return html`<${ListItem}
        ...${props}
        class="participants-list-item ${props.class ?? ""}"
        style="min-width: fit-content; ${props.style ?? ""}"
    >
        ${content}
    <//>`;
};

const ContextMenu = (props, ...content) => {
    return html`<div ...${props} class="context-menu calendar-context-menu">
        ${content}
    </div>`;
};

const ContextMenuItem = ({ onMouseDown }, ...content) => {
    const element = html`<div class="calendar-context-menu-item">
        ${content}
    </div>`;

    element.addEventListener("mousedown", onMouseDown);

    return element;
};

const Report02 = (props) => {

    let loader = Loader();

    let blank = Blank({ data: "", title: "" });

    let датаПо = blank.createField({
        title: "Дата по",
        key: "датаПо",
        type: "date",
        width: 125,
    });

    let distrib = blank.createField({
        title: "Площадка партнера",
        key: "ПлощадкаПартнера",
        reference: CardAccount,
        width: 200,
    });

    let serviceTerritory = blank.createField({
        title: "Сервисная территория",
        key: "СервиснаяТерритория",
        reference: CardServiceTerritory,
        width: 200,
    });

    let model = blank.createField({
        title: "Модель",
        key: "Модель",
        reference: CardEquipmentModel,
        width: 160,
    });

    let storageArea = blank.createField({
        title: "Зона хранения",
        key: "ЗонаХранения",
        reference: CardStorageArea,
        width: 160,
    });

    датаПо.setValue(getCurrentDateTurbo());

    function refreshReport() {
        if (датаПо.getValue() == null) return;
        // let locFilter=[];        
        // if (distrib.getValue().docid) 
        //     locFilter.push( "ПлощадкаПартнера is {C4C.Справочники.Account:"+distrib.getValue().docid+"}");
        // if (serviceTerritory.getValue().docid)
        //     locFilter.push( "СервиснаяТерритория is {C4C.Справочники.Account:"+serviceTerritory.getValue().docid+"}");
        // if (model.getValue().docid)
        //     locFilter.push( "Оборудование.МодельОборудования is {C4C.Справочники.МодельОборудования:"+model.getValue().docid+"}");
        // if (storageArea.getValue().docid)
        //     locFilter.push( "ЗонаХранения = {C4C.Справочники.ЗонаХранения:"+storageArea.getValue().docid+"}");
        // locFilter=locFilter.join(" and ");

        loader.show();
        GetReport02({
            doe: датаПо.getValue(),
            model: model.getValue(),    
            distrib: distrib.getValue(),
            st: serviceTerritory.getValue(),
            storagearea: storageArea.getValue(),  
        })
            .then((result) => {
                //console.log(result);
                repData(result.data ?? []);
            })
            .catch((error) => {
                console.log(error);
            })
            .finally(() => loader.hide());
    }

    //refreshReport();

    const repData = o([]);

    let refreshButton = html`<${Button} style="margin-right: 10px"
        >Обновить<//
    >`;

    refreshButton.addEventListener("click", () => {
        if (датаПо.getValue() == null)
            return Message$1("Отсутствует дата", "error");

        refreshReport();
    });

    const toolBar = html`<div class="toolbar">
        <div class="filters">
            <h3>02 - Парк оборудования по клиентам</h3>
            ${датаПо}${distrib}${serviceTerritory}${model}${storageArea}
        </div>
        <div class="report-buttons"><${HelpLink} projectId=${3461}/>${refreshButton}</div>
    </div>`;

    const reportBody = html`<div class="report02">
        ${toolBar}
        <div class="scrollable">
            ${map(repData, (data) => ReportViewContaiter$4({ ...props, data }))}
        </div>
    </div>`;
    //console.log(reportBody);
    return reportBody;
};

const ReportViewContaiter$4 = (props) => {
    const repTable = ReportTable$4(props);
    const view = html`<div class="report-view-container">${repTable}</div> `;

    return view;
};

const ReportTable$4 = ({ data, }) => {
    if (!data) return;

    let column_totalRep = [
        {
            id: "Модель",
            text: "Модель",
            order: "Модель",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
        },
    ];

    const columnsRep = data.Columns[0].body;

    columnsRep.forEach((element) => {
        column_totalRep.push({
            id: element.SplitValue,
            text: element.DisplayValue,
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: right;",
            fixWidth: 100,
        });
    });    


    const tableTotalRep = Table({
        column_props: column_totalRep,
        class: "table-total",
    });

    data.Columns.map(({ body }) => body).forEach((columns, rowIndex) => {
        columns.forEach((column) => {
            //console.log(column)
            data.Rows[rowIndex][column.SplitValue] = column.Volume;
        });
    });

    tableTotalRep.createRows(data.Rows);

    const view = html`<div>${tableTotalRep}</div> `;

    return view;
};

const Report03 = (props) => {

    let loader = Loader();

    let blank = Blank({ data: "", title: "" });

    let датаПо = blank.createField({
        title: "Дата по",
        key: "датаПо",
        type: "date",
        width: 125,
    });

    let distrib = blank.createField({
        title: "Площадка партнера",
        key: "ПлощадкаПартнера",
        reference: CardAccount,
        width: 200,
    });

    let serviceTerritory = blank.createField({
        title: "Сервисная территория",
        key: "СервиснаяТерритория",
        reference: CardServiceTerritory,
        width: 200,
    });

    let model = blank.createField({
        title: "Модель",
        key: "Модель",
        reference: CardEquipmentModel,
        width: 160,
    });

    let storageArea = blank.createField({
        title: "Зона хранения",
        key: "ЗонаХранения",
        reference: CardStorageArea,
        width: 160,
    });

    датаПо.setValue(getCurrentDateTurbo());

    function refreshReport() {
        if (датаПо.getValue() == null) return;
        // let locFilter=[];        
        // if (distrib.getValue().docid) 
        //     locFilter.push( "ПлощадкаПартнера is {C4C.Справочники.Account:"+distrib.getValue().docid+"}");
        // if (serviceTerritory.getValue().docid)
        //     locFilter.push( "СервиснаяТерритория is {C4C.Справочники.Account:"+serviceTerritory.getValue().docid+"}");
        // if (model.getValue().docid)
        //     locFilter.push( "Оборудование.МодельОборудования is {C4C.Справочники.МодельОборудования:"+model.getValue().docid+"}");
        // if (storageArea.getValue().docid)
        //     locFilter.push( "ЗонаХранения = {C4C.Справочники.ЗонаХранения:"+storageArea.getValue().docid+"}");
        // locFilter=locFilter.join(" and ");

        loader.show();
        GetReport03({ 
            doe: датаПо.getValue(),
            model: model.getValue(),    
            distrib: distrib.getValue(),
            st: serviceTerritory.getValue(),
            storagearea: storageArea.getValue(),   
        })
            .then((result) => {
                repData(result.data ?? []);
            })
            .catch((error) => {
                console.log(error);
            })
            .finally(() => loader.hide());
    }

    //refreshReport();

    const repData = o([]);

    let refreshButton = html`<${Button} style="margin-right: 10px"
        >Обновить<//
    >`;

    refreshButton.addEventListener("click", () => {
        if (датаПо.getValue() == null)
            return Message$1("Отсутствует дата", "error");

        refreshReport();
    });

    const toolBar = html`<div class="toolbar">
        <div class="filters">
            <h3>03 - Парк оборудования по точкам</h3>
            ${датаПо}${distrib}${serviceTerritory}${model}${storageArea}
        </div>
        <div class="report-buttons"><${HelpLink} projectId=${3462}/>${refreshButton}</div>
    </div>`;

    const reportBody = html`<div class="report03">
        ${toolBar}
        <div class="scrollable">
            ${map(repData, (data) => ReportViewContaiter$3({ ...props, data }))}
        </div>
    </div>`;
    return reportBody;
};

const ReportViewContaiter$3 = (props) => {
    const repTable = ReportTable$3(props);
    const view = html`<div class="report-view-container">${repTable}</div> `;

    return view;
};

const ReportTable$3 = ({ data, }) => {
    if (!data) return;

    let column_totalRep = [
        {
            id: "СервиснаяТерритория",
            text: "Сервисная территория",
            order: "СервиснаяТерритория.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 200,
        },
        {
            id: "ПлощадкаПартнера",
            text: "Площадка партнера",
            order: "ПлощадкаПартнера.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 200,
        },
        {
            id: "Клиент",
            text: "Клиент",
            order: "Клиент.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 200,
        },
        {
            id: "ТорговаяТочка",
            text: "Торговая точка",
            order: "ТорговаяТочка.Name",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 240,
        },
        {
            id: "Оборудование",
            text: "Оборудование",
            order: "Оборудование.ManufacturersNumber",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 150,
        },
    ];

    const columnsRep = data.Columns[0].body;

    columnsRep.forEach((element) => {
        column_totalRep.push({
            id: element.SplitValue,
            text: element.DisplayValue,
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: right;",
            fixWidth: 60,
        });
    });    

    const tableTotalRep = Table({
        column_props: column_totalRep,
        class: "table-total",
    });

    data.Columns.map(({ body }) => body).forEach((columns, rowIndex) => {
        columns.forEach((column) => {
            //console.log(column)
            data.Rows[rowIndex][column.SplitValue] = column.Volume;
        });
    });

    tableTotalRep.createRows(data.Rows);

    const view = html`<div>${tableTotalRep}</div> `;

    return view;
};

const Report04 = (props) => {
    // const { selection = false, filter = "", onAccept } = props;
    const repData = o();
    const tableRef = new Ref();

    let loader = Loader();

    let blank = Blank({ data: "", title: "" });

    let датаПо = blank.createField({
        title: "Дата по",
        key: "датаПо",
        type: "date",
        width: 125,
        value: getCurrentDateJS(),
    });

    let distrib = blank.createField({
        title: "Площадка партнера",
        key: "ПлощадкаПартнера",
        reference: CardAccount,
        width: 200,
    });

    let serviceTerritory = blank.createField({
        title: "Сервисная территория",
        key: "СервиснаяТерритория",
        reference: CardServiceTerritory,
        width: 200,
    });

    let model = blank.createField({
        title: "Модель",
        key: "Модель",
        reference: CardEquipmentModel,
        width: 160,
    });

    let storageArea = blank.createField({
        title: "Зона хранения",
        key: "ЗонаХранения",
        reference: CardStorageArea,
        width: 160,
    });

    function refreshReport() {
        if (датаПо.getValue() == null) return;
        loader.show();
        GetReport04({ 
            doe: датаПо.getValue(),
            model: model.getValue(),    
            distrib: distrib.getValue(),
            st: serviceTerritory.getValue(),
            storagearea: storageArea.getValue(),        
        })
            .then((result) => {
                //console.log(result);
                repData(result.data?.[0]);
            })
            .catch((error) => {
                console.log(error);
            })
            .finally(() => loader.hide());
    }

    let refreshButton = html`<${Button} style="margin-right: 10px">
        Обновить
    <//>`;

    refreshButton.addEventListener("click", () => {
        if (датаПо.getValue() == null)
            return Message$1("Отсутствует дата", "error");

        refreshReport();
    });

    const toolBar = html`<div class="toolbar">
        <div class="filters">
            <h3>04 - Парк оборудования по сервисным территориям</h3>
            ${датаПо}${distrib}${serviceTerritory}${model}${storageArea}
        </div>
        <div class="report-buttons"><${HelpLink} projectId=${3413}/>${refreshButton}</div>
    </div>`;

    const renderTable = on(
        repData,
        () => ReportViewContaiter$2({ ...props, data: repData, ref: tableRef }),
        null,
        true
    );

    const reportBody = html`<div class="report04">
        ${toolBar}
        <div class="scrollable">
            ${renderTable}
        </div>
    </div>`;

    return reportBody;
};

const ReportViewContaiter$2 = (props) => {
    const repTable = ReportTable$2(props);
    const view = html`<div class="report-view-container">${repTable}</div>`;
    return view;
};

const ReportTable$2 = ({ data, selection = false, onSelect, ref }) => {
    if (!data()) return;

    let column_totalRep = [
        {
            id: "Модель",
            text: "Модель",
            order: "Модель",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 300,
        },

    ];

    const columnsRep = data().Columns[0].body;

    columnsRep.forEach((element) => {
        column_totalRep.push({
            id: element.SplitValue,
            text: element.DisplayValue,
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: right;",
            fixWidth: 200,
        });
    });

    if (selection)
        column_totalRep.push({
            id: "Кнопка",
            text: "",
            order: "Модель",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: center;",
            fixWidth: 24,
            type: "checkbox",
        });

    const tableTotalRep = Table({
        column_props: column_totalRep,
        class: "table-total",
    });

    ref.current = tableTotalRep;

    data()
        .Columns.map(({ body }) => body)
        .forEach((columns, rowIndex) => {
            columns.forEach((column) => {
                //console.log(column)
                data().Rows[rowIndex][column.SplitValue] = column.Volume;
            });
        });

    tableTotalRep.createRows(data().Rows);

    return tableTotalRep;
};

const Report06 = (props) => {
    // const { selection = false, filter = "", onAccept } = props;
    const repData = o();
    o();
    const tableRef = new Ref();
    new Ref();

    let loader = Loader();

    let blank = Blank({ data: "", title: "" });

    let датаПо = blank.createField({
        title: "Дата по",
        key: "датаПо",
        type: "date",
        width: 130,
        value: getCurrentDateJS(),
    });

    let serviceTerritory = blank.createField({
        title: "Сервисная территория",
        key: "СервиснаяТерритория",
        reference: CardServiceTerritory,
        width: 200,
    });

    let model = blank.createField({
        title: "Модель",
        key: "Модель",
        reference: CardEquipmentModel,
        width: 200,
    });

    let manufacturerNumber = blank.createField({
        title: "Manufacturer №",
        key: "manufacturerNumber",
        type: "string",
        width: 200,
    });


    function refreshReport(repData) {
        if (датаПо.getValue() == null) return;

        loader.show();
        GetReport06({ 
            doe: датаПо.getValue(),
            model: model.getValue(),
            st: serviceTerritory.getValue(),
            manufacturerNumber : manufacturerNumber.getValue(),
        }).then((result) => {                                
                repData(result.data);
            })
            .catch((error) => {
                console.log(error);
            })
            .finally(() => loader.hide());

    }

    let refreshButton = html`<${Button} style="margin-right: 10px">
        Обновить
    <//>`;

    refreshButton.addEventListener("click", () => {
        if (датаПо.getValue() == null)
            return Message$1("Отсутствует дата", "error");
        if (serviceTerritory.getValue().docid==null && model.getValue().docid==null && manufacturerNumber.getValue()==null)
            return Message$1("Отсутствует фильтр", "error");

        refreshReport(repData);
    });

    const exportExcelBtn = html`<${Button}
        onClick=${() => {
            loader.show();
            exportRep06({
                doe: датаПо.getValue(),
                model: model.getValue(),
                st: serviceTerritory.getValue(),
                manufacturerNumber : manufacturerNumber.getValue(),
            })
            .then((result) => {
                if (result instanceof Error) {
                    console.error(result);
                    return;
                }
                exportJSONToXlsx(result, "export.xlsx");
            })

            .finally(loader.hide);
        }}
    >
        Скачать Excel
    <//>`;

    const toolBar = html`<div class="toolbar">
        <div class="filters">
            <h3>06 - Парк оборудования (подробный)</h3>
            ${датаПо}${serviceTerritory}${model}${manufacturerNumber}
        </div>
        <div class="report-buttons"><${HelpLink} projectId=${3485   }/>${exportExcelBtn}${refreshButton}</div>
    </div>`;

    const renderTable = on(
        repData,
        () => ReportViewContaiter$1({ ...props, data: repData, ref: tableRef }),
        null,
        true
    );

    const reportBody = html`<div class="report06">
        ${toolBar}
        <div class="scrollable">
            ${renderTable}
        </div>
    </div>`;

    return reportBody;
};

const ReportViewContaiter$1 = (props) => {
    const repTable = ReportTable$1(props);
    const view = html`<div class="report-view-container">${repTable}</div>`;
    if (props.exportExcel)
        exportHtmlToExcel({
         table: repTable,
            fileName: `export.xls`,
            name: "export",
        });
    return view;
};

const ReportTable$1 = ({ data, selection = false, ref, exportExcel = false }) => {
    if (!data()) return;
    //console.log(data());
    let column_totalRep = [
        {
            id: "SerialID",
            text: "SerialID",
            order: "SerialID",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 120,
        },
        {
            id: "SolutionBrands",
            text: "Solution Brands",
            order: "SolutionBrands",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 80,
        },
        {
            id: "ManufacturerNumber",
            text: "Manufacturer Number",
            order: "ManufacturerNumber",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 170,
        },
        {
            id: "Position",
            text: "Position",
            order: "Position",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 100,
        },
        {
            id: "ProductExternalID",
            text: "Product External ID",
            order: "ProductExternalID",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
        },
        {
            id: "ProductCategory",
            text: "Registered Product Category",
            order: "ProductCategory",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 140,
        },
        {
            id: "Product",  // Это модель
            text: "Product",
            order: "Product",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 140,
        },

        {
            id: "MachineStatus",  // Вычисляется в Турбо
            text: "Machine status",
            order: "MachineStatus",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 150,
        },
        {
            id: "ServiceTerritory",
            text: "ServiceTerritory",
            order: "ServiceTerritory",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 160,
        },

        {
            id: "ParentTerritoryID",
            text: "Parent Territory ID",
            order: "Parent Territory ID",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 100,
        },

        {
            id: "ParentTerritory",
            text: "Parent Territory",
            order: "ParentTerritory",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 100,
        },


        {
            id: "Customer",  // Площадка партнера
            text: "Customer",
            order: "Customer",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
        },
        {
            id: "ShipToPartyID",        // Площадка id ship to
            text: "Ship to Party id",
            order: "ShipToPartyID",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 100,
        },

        {
            id: "ShipToParty",          // Площадка (тоже самое название)
            text: "Ship to Party",
            order: "ShipToParty",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
        },

        {
            id: "EndCustomerID",        // Иногда старый, когда его нет то новый
            text: "EndCustomerID",
            order: "EndCustomerID",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 140,
        },
        {
            id: "CommercialName",
            text: "CommercialName",
            order: "CommercialName",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
        },
        {
            id: "ExternalID",
            text: "External ID (Distributor)",
            order: "ExternalID",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
        },
        {
            id: "EndCustomerName",
            text: "EndCustomerName",
            order: "EndCustomerName",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
        },
        {
            id: "адресИндекс",
            text: "End сustomer PO code",
            order: "адресИндекс",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 160,
        },
        {
            id: "адресГород",
            text: "End customer city",
            order: "адресГород",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 160,
        },

        {
            id: "InstallationPointID",
            text: "InstallationPointID",
            order: "InstallationPointID",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 120,
        },
        {
            id: "InstallationPointName",
            text: "InstallationPointName",
            order: "InstallationPointName",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
        },
        {
            id: "DateOfLastMovement",
            text: "Date of last movement", // Дата последнего наряда
            order: "DateOfLastMovement",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 100,
        },
        {
            id: "userStatusLastChangedOn",
            text: "User status last changed On", // Дата последнего внутренного перемещения
            order: "userStatusLastChangedOn",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 100,
        },

        {
            id: "Industry",
            text: "Industry", // отрасль
            order: "Industry",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 150,
        },

        {
            id: "Industry1",
            text: "Industry code 1", // сегмент
            order: "Industry1",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 150,
        },

        {
            id: "region",
            text: "state", 
            order: "region",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
        },

        {
            id: "street",
            text: "street",
            order: "street",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
        },

        {
            id: "houseNumber",
            text: "house number",
            order: "houseNumber",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
        },

        {
            id: "addressLine1",
            text: "Address line 1",
            order: "addressLine1",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 180,
        },

        {
            id: "DateOfLastVisit",
            text: "Date of last visit", // Дата последнего визита
            order: "DateOfLastVisit",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 90,
        },

        {
            id: "DateOfNextVisit",
            text: "Date of next visit", // Дата запланированного визита
            order: "DateOfNextVisit",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 90,
        },
        {
            id: "localsegmentation",
            text: "local segmentation", // KA Marker / холдинг
            order: "localsegmentation",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 100,
        },

        {
            id: "additionalName3",
            text: "additional Name 3", // xcrm
            order: "additionalName3",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 100,
        },


        {
            id: "sapChangeDate",
            text: "sap change date", // 
            order: "sapChangeDate",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 100,
        },

        {
            id: "ownerResponsible",
            text: "owner responsible", // 
            order: "ownerResponsible",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 100,
        },

    ];

//    console.log(data());

//    const columnsRep = data();

    // columnsRep.forEach((element) => {
    //     column_totalRep.push({
    //         id: element.SplitValue,
    //         text: element.DisplayValue,
    //         style: "text-align: center; width: 100%; justify-content: center;",
    //         styleCell: "text-align: right;",
    //         fixWidth: 100,
    //     });
    // });

    const tableTotalRep = Table({
        column_props: column_totalRep,
        class: "table-total",
    });

    // ref.current = tableTotalRep;

    // data()
    //     .Columns.map(({ body }) => body)
    //     .forEach((columns, rowIndex) => {
    //         columns.forEach((column) => {
    //             //console.log(column)
    //             data().Rows[rowIndex][column.SplitValue] = column.Volume;
    //         });
    //     });

    tableTotalRep.createRows(data());

    return tableTotalRep;
};

const Report10 = (props) => {

    let loader = Loader();

    let blank = Blank({ data: "", title: "" });

    let датаПо = blank.createField({
        title: "Дата по",
        key: "датаПо",
        type: "date",
        width: 125,
    });

    let persona = blank.createField({
        title: "Пользователь",
        key: "Пользователь",
        reference: CardFileEmployee,
        width: 200,
    });

    датаПо.setValue(getCurrentDateTurbo());

    function refreshReport() {
        if (датаПо.getValue() == null) return;     
        
        loader.show();
        GetReport10({ 
            doe: датаПо.getValue(),
            persona: persona.getValue(),           
        })
            .then((result) => {
                //console.log(result);
                repData(result.data ?? []);
            })
            .catch((error) => {
                console.log(error);
            })
            .finally(() => loader.hide());
    }


    const repData = o([]);

    let refreshButton = html`<${Button} style="margin-right: 10px"
        >Обновить<//
    >`;

    refreshButton.addEventListener("click", () => {
        if (датаПо.getValue() == null)
            return Message$1("Отсутствует дата", "error");

        refreshReport();
    });

    const toolBar = html`<div class="toolbar">
        <div class="filters">
            <h3>10 - Журнал авторизации пользователей</h3>
            ${датаПо}${persona}
        </div>
        <div class="report-buttons"><${HelpLink} projectId=${3548}/>${refreshButton}</div>
    </div>`;

    const reportBody = html`<div class="report10">
        ${toolBar}
        <div class="scrollable">
            ${map(repData, (data) => ReportViewContaiter({ ...props, data }))}
        </div>
    </div>`;
    //console.log(reportBody);
    return reportBody;
};

const ReportViewContaiter = (props) => {
    const repTable = ReportTable(props);
    const view = html`<div class="report-view-container">${repTable}</div> `;

    return view;
};

const ReportTable = ({ data, selection, onMachineSelect }) => {
    if (!data) return;
    
    let column_totalRep = [
        {
            id: "Пользователь",
            text: "Пользователь",
            order: "Пользователь",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 200,
        },
        {
            id: "Email",
            text: "Email",
            order: "Email",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 200,
        },
        {
            id: "Менеджер",
            text: "Менеджер",
            order: "Менеджер",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 200,
        },
        {
            id: "ВремяАвторизации",
            text: "Время авторизации",
            order: "ВремяАвторизации",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 200,
        },
        {
            id: "ВремяВыхода",
            text: "Время выхода",
            order: "ВремяВыхода",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 200,
        },
        {
            id: "ТипУстройства",
            text: "Тип устройства",
            order: "ТипУстройства",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 200,
        },
        {
            id: "АдресСайта",
            text: "Адрес сайта",
            order: "АдресСайта",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 200,
        },
        {
            id: "Регион",
            text: "Регион",
            order: "Регион",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 200,
        },
        {
            id: "СервиснаяТерритория",
            text: "Сервисная территория",
            order: "СервиснаяТерритория",
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: left;",
            fixWidth: 200,
        },
    ];

    const columnsRep = data.Columns[0].body;

    columnsRep.forEach((element) => {
        column_totalRep.push({
            id: element.SplitValue,
            text: element.DisplayValue,
            style: "text-align: center; width: 100%; justify-content: center;",
            styleCell: "text-align: right;",
            fixWidth: 200,
        });
    });    

    const tableTotalRep = Table({
        column_props: column_totalRep,
        class: "table-total",
    });

    data.Columns.map(({ body }) => body).forEach((columns, rowIndex) => {
        columns.forEach((column) => {
            //console.log(column)
            data.Rows[rowIndex][column.SplitValue] = column.Volume;
        });
    });

    tableTotalRep.createRows(data.Rows);

    const view = html`<div>${tableTotalRep}</div> `;

    return view;
};

const routes$2 = {
    // consumption: new ServiceRoute({
    //     service: "consumption",
    //     element: consumption,
    //     //header: "125 - Контроль рабочего времени сотрудника",
    // }),
    
    report01: new ReportRoute({
        report: "report01",
        element: Report01,    
    }),
    
    report02: new ReportRoute({
        report: "report02",
        element: Report02,    
    }),

    report03: new ReportRoute({
        report: "report03",
        element: Report03,    
    }),

    report301: new ReportRoute({
        report: "report301",
        element: Report301,
    }),

    report302: new ReportRoute({
        report: "report302",
        element: Report302,
    }),

    report04: new ReportRoute({
        report: "report04",
        element: Report04,
    }),

    report303: new ReportRoute({
        report: "report303",
        element: Report303,
    }),

    report06: new ReportRoute({
        report: "report06",
        element: Report06
    }),

    report304: new ReportRoute({
        report: "report304",
        element: Report304,
    }),

    report10: new ReportRoute({
        report: "report10",
        element: Report10
    }),


};

const Reports = () => {
    const reportElement = o();
    let lastView = new View$4();

    const onRouteChange = ({ component, match, key }) => {
        const currentView = new View$4(key, match?.groups?.params);
        if (lastView.isEqual(currentView)) return;

        lastView = currentView;

        const params = getSearchParams(currentView.params);

        reportElement(component(params));

        pageAdditionalTitle(routes$2[key].title);
    };

    const element = html`<${Router} routes=${routes$2} onChange=${onRouteChange}>
        <div class="report-view">
            ${reportElement}
        </div>
    <//>`;

    return element;
};

const routes$1 = {
    cardfiles: new Route(/^#cardfile.*$/i, CardFiles),
    services: new Route(/^#service.*$/i, Services),
    reports: new Route(/^#report.*$/i, Reports),
    test: new Route(/^#test$/i, Test),
  //  root: new Route(/^.*$/, Main),
    visits: new Route(/#visits.*$/, MeetingsView, "Визиты"),
    root: new Route(/^.*$/i, Home),

};

// import libraries

const Root = () => {
    const useCustomNavbar = true;
    let lastView = new View$4();
    const element = AppShell({ useCustomNavbar });
    observe(element);

    element.classList.add("shell-application");

    html`<img class="h-75" src="assets/logo.png"></img>`;

    {
        const customNavbar = Navbar({
            parent: element,
            logoMain: html`<img class="logo-full" src="assets/image/logo.png"></img>`,
            logoSmall: html`<img class="logo-small" src="assets/image/logo.png"></img>`,
        });

        element.header = customNavbar;
        element.prepend(element.header);

        element.addEventListener("connected", async (event) => {
            const dataInterface = await getInterface(+localStorage.role);
            customNavbar.Setup(dataInterface);
        });

        element.addEventListener("disconnected", (event) => {
            customNavbar.Reset();
        });
    }

    const onRouteChange = ({ component, key, match }) => {
        const currentView = new View$4(key, match?.groups?.params);

        if (lastView.isEqual(currentView)) return;
        lastView = currentView;
        pageAdditionalTitle(routes$1[key].title);

        element.setView(component());
    };

    const router = html`<${Router} onChange=${onRouteChange} routes=${routes$1}>
        ${element}
    <//>`;

    return router;
};

const routes = {
    ...appRoutes,
    login: new Route(/^#login$/, Login),
    logout: new Route(/^#logout$/, () => "logout page"),
    root: new Route(/^.*$/, Root),
};

///

const customTitle = () =>
    html`<title>
        NP360${() =>
            pageAdditionalTitle() ? " / " + pageAdditionalTitle() : ""}
    </title>`;

document.head.removeChild(document.head.querySelector("title"));
document.head.appendChild(customTitle());

const App = () => {
    let lastView = new View$4();
    const workspace = WorkSpace();
    const onRouteChange = async ({ component, key, match }) => {
        switch (key) {
            case "root": {
                if (isLoggedIn()) break;
                return navigate("/#login");
            }
            case "login": {
                if (!isLoggedIn()) break;
                return navigate("/#");
            }
            case "logout": {
                if (isLoggedIn()) {
                    // send action
                    await logout({session: localStorageService.get("session")}).then(localStorageService.remove("session"));
                    await logOut();
                }
                return navigate("/#login");
            }
            case "registration": {
                if (!isLoggedIn()) break;
                return navigate("/#");
            }
        }

        const currrentView = new View$4(key, match?.groups?.params);

        if (lastView.isEqual(currrentView)) return;
        lastView = currrentView;

        const params = getSearchParams(match?.groups?.params);
        workspace.setView(component(params));
    };
    const element = html`<${Router} onChange=${onRouteChange} routes=${routes}>
        ${workspace}
    <//>`;

    return element;
};

// import app statement
// route_add(/^SOME$/, _ => {
//     app.shell_application.setView(app.shell_application.view_test);
//     app.setView(app.shell_application);
// });

document.body.append(App());

// class View {
//     constructor() {
//         this.view = null;
//         this.subView = null;
//         this.params = null;
//     }
//     setView(view = null, subView = null, params = null) {
//         this.view = view;
//         this.subView = subView;
//         this.params = params;
//     }
//     clear() {
//         this.setView();
//     }
//     isEqual({ view, subView, params }) {
//         return (
//             view === this.view &&
//             subView === this.subView &&
//             JSON.stringify(params) === JSON.stringify(this.params)
//         );
//     }
// }

// const lastView = new View();

// route_add(/^(?<href>.*)$/, (groups) => {
//     if (groups?.href === "login" || groups?.href.split('?')[0] === 'registration') {
//         if (!isLoggedIn()) return;

//         location.href = "#";
//         route_call();

//         return true; // prevent propagation
//     } else {
//         if (isLoggedIn()) return;

//         location.href = "#login";
//         route_call();

//         return true; // prevent propagation
//     }
// });

// route_add(/^registration(?<query>.*)$/, ({ query }) => {
//     let parts = query.split("?");
//     if (parts.length > 1) {
//         const queryArgs = new URLSearchParams(query);
//         const args = {};
//         console.log(queryArgs.get("id"), Array.from(queryArgs.entries));
//         for (const [key, value] of queryArgs.entries()) {
//             args[key] = value;
//         }
//         if(!args.id){
//             location.href = "#login";
//             route_call();
//         }
//         app.setView(app.shell_registration(args));
//     } else {
//         location.href = "#login";
//         route_call();
//     }
// });

// route_add(/^login$/, () => app.setView(app.shell_login));
// route_add(/^logout$/, () => {
//     logOut();

//     location.href = "#login";
//     route_call();
// });

// route_add(/^$/, () => {
//     lastView.setView("root");
//     app.shell_application.setView(app.shell_application.view_root);
//     app.setView(app.shell_application);
// });

// route_add(/^main$/, () => {
//     lastView.setView("main");
//     app.shell_application.setView(app.shell_application.view_main);
//     app.setView(app.shell_application);
// });

// // let lastCardFile = undefined;
// route_add(/^test$/, () => {
//     app.shell_application.setView(app.shell_application.testView());
//     app.setView(app.shell_application);
// });
// route_add(/^cardfile\/(?<query>.*)$/, ({ query }) => {
//     let parts = query.split("?");
//     let params;

//     if (parts.length > 1) {
//         const url_arguments = new URLSearchParams("?" + parts[1]);
//         params = {};
//         for (const [key, value] of url_arguments.entries()) {
//             if (key === "id") {
//                 params.docid = Number(value);
//             } else {
//                 params[key] = value;
//             }
//         }
//     }

//     if (lastView.isEqual({ view: "cardfile", subView: parts[0], params }))
//         return app.setView(app.shell_application);

//     if (lastView.view != "cardfile" || lastView.subView != parts[0]) {
//         app.shell_application.view_card_file.setCardFile(parts[0]);
//         app.shell_application.setView(app.shell_application.view_card_file);
//     }

//     if (params?.docid) {
//         app.shell_application.view_card_file.viewRecord(params);
//     }

//     lastView.setView("cardfile", parts[0], params);

//     app.setView(app.shell_application);
// });

// route_add(/^service\/(?<query>.*)$/, ({ query }) => {
//     const parts = query.split("?");
//     let params;

//     if (parts.length > 1) {
//         const url_arguments = new URLSearchParams("?" + parts[1]);
//         params = {};
//         for (const [key, value] of url_arguments.entries()) {
//             params[key] = value;
//         }
//     }

//     if (lastView.isEqual({ view: "service", subView: parts[0], params }))
//         return app.setView(app.shell_application);

//     app.shell_application.view_service.setService(parts[0], params ?? query);
//     app.shell_application.setView(app.shell_application.view_service);

//     lastView.setView("service", parts[0], params);
//     app.setView(app.shell_application);
// });

// route_add(/^report\/(?<query>.*)$/, ({ query }) => {
//     const parts = query.split("?");
//     let params;

//     if (parts.length > 1) {
//         const url_arguments = new URLSearchParams("?" + parts[1]);
//         params = {};
//         for (const [key, value] of url_arguments.entries()) {
//             params[key] = value;
//         }
//     }

//     if (lastView.isEqual({ view: "report", subView: parts[0], params }))
//         return app.setView(app.shell_application);

//     app.shell_application.reportView.setReport(parts[0], params ?? query);
//     app.shell_application.setView(app.shell_application.reportView);

//     lastView.setView("reportView", parts[0], params);
//     app.setView(app.shell_application);
// });
//# sourceMappingURL=index.js.map
